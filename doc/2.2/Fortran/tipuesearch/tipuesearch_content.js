var tipuesearch = {"pages":[{"title":" NTPoly ","text":"NTPoly Project Overview NTPoly is a massively parallel library for computing the functions of sparse,\nHermitian matrices based on polynomial expansions. For sufficiently sparse\nmatrices, most of the matrix functions in NTPoly can be computed in linear\ntime. Set Up Guide NTPoly is freely available and open source under the MIT license. It can be\ndownloaded from the Github repository. We of course recommend that you download a release version to get started. Installing NTPoly requires the following software: A Fortran Compiler. An MPI Installation (MPI-3 Standard+). CMake (Version 3.2+). The following optional software can greatly enhance the NTPoly experience: BLAS: for multiplying dense matrices, if they emerge in the calculation. A C++ Compiler for building C++ bindings. Doxygen: for building documentation. Python (Version 2.7+): for testing. MPI4PY: for testing. SciPy: for testing. NumPy: for testing. SWIG (Version 3.0+): for building the Python bindings. NTPoly uses CMake as a build system. First, take a look in the Targets\ndirectory. You'll find a list of .cmake files which have example configurations\non popular systems. You should copy one of these files, and create your own\nmymachine.cmake file. Then, cd into the Build directory, and type: cmake -DCMAKE_TOOLCHAIN_FILE=../Targets/mymachine.cmake .. There are a few options you can pass to CMake to modify the build. You can set -DCMAKE_BUILD_TYPE=Debug for debugging purposes. You can set the install\ndirectory using the standard -DCMAKE_INSTALL_PREFIX=/path/to/dir . You can\nalso set -DFORTRAN_ONLY=YES if you want to only build the Fortran interface.\nNote that with just the Fortran interface, it is not possible to perform local\ntests. After that you can build using: make And for the documentation: make doc Online documentation is also\navailable. Further details about the library can be found on the Wiki .\nIf you aren't cross compiling, you can perform local tests using: make test Basic Theory The theory of matrix functions is a long studied branch of matrix algebra.\nMatrix functions have a wide range of applications, including graph problems,\ndifferential equations, and materials science. Common examples of matrix\nfunctions include the matrix exponential: f(A) = e&#94;A. from the study of networks, or the inverse square root: f(A) = A&#94;(-1/2) from quantum chemistry. NTPoly is a massively parallel library that can be used\nto compute a variety of matrix using polynomial expansions. Consider for example\nthe Taylor series expansion of a function f(x) . f(x) = f(0) + f'(0)x + f''(0)x&#94;2/2! + ... We can imagine expanding this from the function of a single variable, to a\nfunction of a matrix: f(A) = f(0) + f'(0)A + f''(0)A&#94;2/2! + ... where matrices can be summed using matrix addition, and raised to a power\nusing matrix multiplication. At the heart of NTPoly are polynomial expansions\nlike this. We implement not only Taylor expansions, but also Chebyshev\npolynomial expansions, and other specialized expansions based on the function\nof interest. When the input matrix A and the output matrix f(A) are sparse, we can\nreplace the dense matrix addition and multiplication routines with sparse\nmatrix routines. This allows us to use NTPoly to efficiently compute many\nfunctions of sparse matrices. Getting Start With Examples In the examples directory, there are a number of different example programs that\nuse NTPoly. You can check the ReadMe.md file in each example directory to\nlearn how to build and run each example. The simplest example is PremadeMatrix,\nwhich includes sample output you can compare to. Feature Outline The following features and methods have been implemented in NTPoly: General Polynomials Standard Polynomials Chebyshev Polynomials Hermite Polynomials Transcendental Functions Trigonometric Functions Exponential and Logarithm Matrix Roots Square Root and Inverse Square Root Matrix p th Root Quantum Chemistry Density Matrix Purification Chemical Potential Calculation Geometry Optimization Other Matrix Inverse/Moore-Penrose Pseudo Inverse Sign Function/Polar Decomposition Load Balancing Matrices File I/O Citation A description of the techniques used in NTPoly can be found in the following\nComputer Physics Communications paper: Dawson, William, and Takahito Nakajima. \"Massively parallel sparse matrix\nfunction calculations with NTPoly.\" Computer Physics Communications (2017). Please cite this paper in accordance to the practices in your field. How To Contribute To begin contributing to NTPoly, take a look at the Wiki pages. The Contributing Guide provides an overview of best development practices. Additionally, there is a Adding New Functionality page which documents how one would go about adding a matrix function to NTPoly.","tags":"home","loc":"index.html"},{"title":"RootSolversModule.F90 – NTPoly","text":"Contents Modules RootSolversModule Source Code RootSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing General Matrix Roots. MODULE RootSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE InverseSolversModule , ONLY : Invert USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteListElement , & & WriteHeader , WriteElement , WriteCitation USE PolynomialSolversModule , ONLY : Polynomial_t , ConstructPolynomial , & & DestructPolynomial , FactorizedCompute , SetCoefficient USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters USE SquareRootSolversModule , ONLY : SquareRoot , InverseSquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: ComputeRoot PUBLIC :: ComputeInverseRoot CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general matrix root. RECURSIVE SUBROUTINE ComputeRoot ( InputMat , OutputMat , root , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables TYPE ( Matrix_ps ) :: TempMat !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Root Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Root\" , value = root ) CALL PrintParameters ( solver_parameters ) END IF !! Handle base cases, or call to general implementation. IF ( root . EQ . 1 ) THEN CALL CopyMatrix ( InputMat , OutputMat ) ELSE IF ( root . EQ . 2 ) THEN CALL SquareRoot ( InputMat , OutputMat , solver_parameters ) ELSE IF ( root . EQ . 3 ) THEN CALL MatrixMultiply ( InputMat , InputMat , TempMat , & & threshold_in = solver_parameters % threshold ) CALL ComputeRootImplementation ( TempMat , OutputMat , 6 , & & solver_parameters ) ELSE IF ( root . EQ . 4 ) THEN CALL SquareRoot ( InputMat , TempMat , solver_parameters ) CALL SquareRoot ( TempMat , OutputMat , solver_parameters ) CALL DestructMatrix ( TempMat ) ELSE CALL ComputeRootImplementation ( InputMat , OutputMat , root , & & solver_parameters ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Actual implementation of computing a general matrix root. SUBROUTINE ComputeRootImplementation ( InputMat , OutputMat , root , & & solver_parameters ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: fixed_parameters !! Local Variables TYPE ( Matrix_ps ) :: RaisedMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Polynomial_t ) :: power_poly INTEGER :: counter !! Set up the solver parameters fixed_parameters % threshold = solver_parameters % threshold fixed_parameters % be_verbose = solver_parameters % be_verbose fixed_parameters % do_load_balancing = solver_parameters % do_load_balancing fixed_parameters % BalancePermutation = solver_parameters % BalancePermutation !! We will use the formula A&#94;(1/x) = A*A&#94;(1/x - 1) !! So first, we raise to the root-1 power CALL ConstructPolynomial ( power_poly , root ) DO counter = 1 , root - 1 CALL SetCoefficient ( power_poly , counter , REAL ( 0.0 , NTREAL )) END DO CALL SetCoefficient ( power_poly , root , REAL ( 1.0 , NTREAL )) CALL FactorizedCompute ( InputMat , RaisedMat , power_poly , & & fixed_parameters ) CALL DestructPolynomial ( power_poly ) !! Now compute the inverse pth root CALL ComputeInverseRoot ( RaisedMat , TempMat , root , solver_parameters ) !! Multiply by the original matrix CALL MatrixMultiply ( InputMat , TempMat , OutputMat , & & threshold_in = solver_parameters % threshold ) !! Cleanup CALL DestructMatrix ( RaisedMat ) CALL DestructMatrix ( TempMat ) END SUBROUTINE ComputeRootImplementation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general inverse matrix root. RECURSIVE SUBROUTINE ComputeInverseRoot ( InputMat , OutputMat , root , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;-1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables TYPE ( Matrix_ps ) :: TempMat !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Inverse Root Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Root\" , value = root ) CALL PrintParameters ( solver_parameters ) END IF !! Handle base cases, or call to general implementation. IF ( root . EQ . 1 ) THEN CALL Invert ( InputMat , OutputMat , solver_parameters ) ELSE IF ( root . EQ . 2 ) THEN CALL InverseSquareRoot ( InputMat , OutputMat , solver_parameters ) ELSE IF ( root . EQ . 3 ) THEN CALL ComputeRoot ( InputMat , TempMat , 3 , solver_parameters ) CALL Invert ( TempMat , OutputMat , solver_parameters ) ELSE IF ( root . EQ . 4 ) THEN CALL SquareRoot ( InputMat , TempMat , solver_parameters ) CALL InverseSquareRoot ( TempMat , OutputMat , solver_parameters ) CALL DestructMatrix ( TempMat ) ELSE CALL ComputeInverseRootImplemention ( InputMat , OutputMat , root , & & solver_parameters ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeInverseRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general inverse matrix root for root > 4. SUBROUTINE ComputeInverseRootImplemention ( InputMat , OutputMat , root , & & solver_parameters_in ) !> Matrix to compute the root of. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The inverse nth root of that matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which inverse root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Constants. REAL ( NTREAL ), PARAMETER :: NEGATIVE_ONE = - 1.0 !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: SqrtMat , FthrtMat TYPE ( Matrix_ps ) :: IdentityMat TYPE ( Matrix_ps ) :: Mk TYPE ( Matrix_ps ) :: IntermediateMat TYPE ( Matrix_ps ) :: IntermediateMatP TYPE ( Matrix_ps ) :: Temp !! Local Variables INTEGER :: target_root REAL ( NTREAL ) :: e_min REAL ( NTREAL ) :: e_max REAL ( NTREAL ) :: scaling_factor REAL ( NTREAL ) :: norm_value !! Temporary Variables INTEGER :: outer_counter INTEGER :: inner_counter TYPE ( MatrixMemoryPool_p ) :: pool !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters_in % be_verbose ) THEN CALL WriteHeader ( \"Root Solver\" ) CALL EnterSubLog CALL WriteCitation ( \"nicholas2008functions\" ) CALL PrintParameters ( solver_parameters ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) scaling_factor = e_max / SQRT ( 2.0 ) ** ( 1.0 / root ) !! Compute the target root (adjust for the fact that we just took the !! fourth root. target_root = 0 IF ( MOD ( root , 4 ) . EQ . 0 ) THEN target_root = root / 4 ELSE IF ( MOD ( root , 4 ) . EQ . 1 . OR . MOD ( root , 4 ) . EQ . 3 ) THEN target_root = root ELSE target_root = ( root - 2 ) / 2 + 1 END IF !! Initialize !! Fourth Root Matrix CALL SquareRoot ( InputMat , SqrtMat , solver_parameters ) CALL SquareRoot ( SqrtMat , FthrtMat , solver_parameters ) CALL DestructMatrix ( SqrtMat ) !! Setup the Matrices CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( FthrtMat , FthrtMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF CALL CopyMatrix ( IdentityMat , OutputMat ) CALL ScaleMatrix ( OutputMat , 1.0 / scaling_factor ) CALL CopyMatrix ( FthrtMat , Mk ) CALL ScaleMatrix ( Mk , 1.0 / ( scaling_factor ** target_root )) CALL DestructMatrix ( FthrtMat ) CALL ConstructEmptyMatrix ( IntermediateMat , InputMat ) CALL ConstructEmptyMatrix ( IntermediateMatP , InputMat ) CALL ConstructEmptyMatrix ( Temp , InputMat ) outer_counter = 1 IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF norm_value = solver_parameters % converge_diff + 1.0d+0 DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF CALL CopyMatrix ( IdentityMat , IntermediateMat ) CALL ScaleMatrix ( IntermediateMat , & & REAL ( target_root + 1 , NTREAL )) CALL IncrementMatrix ( Mk , IntermediateMat , & & alpha_in = NEGATIVE_ONE ) CALL ScaleMatrix ( IntermediateMat , & & REAL ( 1.0 , NTREAL ) / target_root ) CALL MatrixMultiply ( OutputMat , IntermediateMat , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , OutputMat ) CALL CopyMatrix ( IntermediateMat , IntermediateMatP ) DO inner_counter = 1 , target_root - 1 CALL MatrixMultiply ( IntermediateMat , IntermediateMatP , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , IntermediateMatP ) END DO CALL MatrixMultiply ( IntermediateMatP , Mk , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , Mk ) CALL IncrementMatrix ( IdentityMat , Temp , & & alpha_in = NEGATIVE_ONE ) norm_value = MatrixNorm ( Temp ) IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) CALL PrintMatrixInformation ( OutputMat ) END IF IF ( MOD ( root , 4 ) . EQ . 1 . OR . MOD ( root , 4 ) . EQ . 3 ) THEN CALL MatrixMultiply ( OutputMat , OutputMat , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp , Temp , OutputMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) ELSE IF ( MOD ( root , 4 ) . NE . 0 ) THEN CALL MatrixMultiply ( OutputMat , OutputMat , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , OutputMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters_in % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Mk ) CALL DestructMatrix ( IntermediateMat ) CALL DestructMatrix ( IntermediateMatP ) CALL DestructMatrix ( Temp ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE ComputeInverseRootImplemention !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE RootSolversModule","tags":"","loc":"sourcefile/rootsolversmodule.f90.html"},{"title":"ChebyshevSolversModule.F90 – NTPoly","text":"Contents Modules ChebyshevSolversModule Source Code ChebyshevSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Matrix functions based on Chebyshev polynomials. MODULE ChebyshevSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : WriteElement , WriteHeader , EnterSubLog , & & ExitSubLog USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , FillMatrixIdentity , & & PrintMatrixInformation , ConstructEmptyMatrix , DestructMatrix , & & CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a Chebyshev polynomial. TYPE , PUBLIC :: ChebyshevPolynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE ChebyshevPolynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute PUBLIC :: FactorizedCompute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_cheby END INTERFACE INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_cheby END INTERFACE INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_cheby END INTERFACE INTERFACE Compute MODULE PROCEDURE Compute_cheby END INTERFACE INTERFACE FactorizedCompute MODULE PROCEDURE FactorizedCompute_cheby END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a Chebyshev polynomial object. PURE SUBROUTINE ConstructPolynomial_cheby ( this , degree ) !> The polynomial to construct. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this !> Degree of the polynomial. INTEGER , INTENT ( IN ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0 END SUBROUTINE ConstructPolynomial_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a polynomial object. PURE SUBROUTINE DestructPolynomial_cheby ( this ) !> The polynomial to destruct. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set a coefficient of a Chebyshev polynomial. SUBROUTINE SetCoefficient_cheby ( this , degree , coefficient ) !> The polynomial to set. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this !> Degree for which to set the coefficient. INTEGER , INTENT ( IN ) :: degree !> Coefficient value. REAL ( NTREAL ), INTENT ( IN ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Chebyshev Polynomial of the matrix. !> This method uses the standard Chebyshev Polynomial expansion. SUBROUTINE Compute_cheby ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The Chebyshev polynomial to compute. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Tk TYPE ( Matrix_ps ) :: Tkminus1 TYPE ( Matrix_ps ) :: Tkminus2 TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: counter !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF degree = SIZE ( poly % coefficients ) IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Chebyshev Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Standard\" ) CALL WriteElement ( key = \"Degree\" , value = degree - 1 ) CALL PrintParameters ( solver_parameters ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! First Term CALL CopyMatrix ( Identity , Tkminus2 ) IF ( degree == 1 ) THEN CALL CopyMatrix ( Tkminus2 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) ELSE CALL CopyMatrix ( BalancedInput , Tkminus1 ) CALL CopyMatrix ( Tkminus2 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) CALL IncrementMatrix ( Tkminus1 , OutputMat , & & alpha_in = poly % coefficients ( 2 )) IF ( degree > 2 ) THEN CALL MatrixMultiply ( BalancedInput , Tkminus1 , Tk , & & alpha_in = REAL ( 2.0 , NTREAL ), & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( Tkminus2 , Tk , REAL ( - 1.0 , NTREAL )) CALL IncrementMatrix ( Tk , OutputMat , & & alpha_in = poly % coefficients ( 3 )) DO counter = 4 , degree CALL CopyMatrix ( Tkminus1 , Tkminus2 ) CALL CopyMatrix ( Tk , Tkminus1 ) CALL MatrixMultiply ( BalancedInput , Tkminus1 , Tk , & & alpha_in = REAL ( 2.0 , NTREAL ), & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) CALL IncrementMatrix ( Tkminus2 , Tk , & & REAL ( - 1.0 , NTREAL )) CALL IncrementMatrix ( Tk , OutputMat , & & alpha_in = poly % coefficients ( counter )) END DO END IF END IF IF ( solver_parameters % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Identity ) CALL DestructMatrix ( Tk ) CALL DestructMatrix ( Tkminus1 ) CALL DestructMatrix ( Tkminus2 ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE Compute_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Chebyshev Polynomial of the matrix. !> This version first factors the Chebyshev Polynomial and computes the !> function using a divide and conquer algorithm. Based on a simplified !> version of the first method in \\cite liang2003improved . SUBROUTINE FactorizedCompute_cheby ( InputMat , OutputMat , poly , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The Chebyshev polynomial to compute. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ), DIMENSION (:), ALLOCATABLE :: T_Powers TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: log2degree INTEGER :: counter !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF degree = SIZE ( poly % coefficients ) IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Chebyshev Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Recursive\" ) CALL WriteElement ( key = \"Degree\" , value = degree - 1 ) CALL PrintParameters ( solver_parameters ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Construct The X Powers Array !! First, compute how many powers of two are necessary to compute. log2degree = 1 DO WHILE ( 2 ** log2degree . LE . degree ) log2degree = log2degree + 1 END DO ALLOCATE ( T_Powers ( log2degree )) !! Now compute those powers of two CALL CopyMatrix ( Identity , T_Powers ( 1 )) IF ( degree . EQ . 1 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) ELSE CALL CopyMatrix ( BalancedInput , T_Powers ( 2 )) DO counter = 3 , log2degree CALL MatrixMultiply ( T_Powers ( counter - 1 ), T_Powers ( counter - 1 ), & & T_Powers ( counter ), threshold_in = solver_parameters % threshold , & & alpha_in = REAL ( 2.0 , NTREAL ), memory_pool_in = pool ) CALL IncrementMatrix ( Identity , T_Powers ( counter ), & & alpha_in = REAL ( - 1.0 , NTREAL )) END DO !! Call Recursive CALL ComputeRecursive ( T_Powers , poly , OutputMat , & & pool , 1 , solver_parameters ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF DO counter = 1 , log2degree CALL DestructMatrix ( T_Powers ( counter )) END DO DEALLOCATE ( T_Powers ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE FactorizedCompute_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The workhorse routine for the factorized chebyshev computation function. RECURSIVE SUBROUTINE ComputeRecursive ( T_Powers , poly , OutputMat , pool , & & depth , solver_parameters ) !> The precomputed Chebyshev polynomials. TYPE ( Matrix_ps ), DIMENSION (:), INTENT ( IN ) :: T_Powers !> Polynomial coefficients. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The depth of recursion. INTEGER , INTENT ( in ) :: depth !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !> The memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: pool !! Local Data INTEGER :: coefficient_midpoint INTEGER :: left_length , right_length INTEGER :: full_midpoint INTEGER :: counter TYPE ( ChebyshevPolynomial_t ) :: left_poly TYPE ( ChebyshevPolynomial_t ) :: right_poly TYPE ( Matrix_ps ) :: LeftMat TYPE ( Matrix_ps ) :: RightMat !! First Handle The Base Case IF ( SIZE ( poly % coefficients ) . EQ . 1 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) ELSE IF ( SIZE ( poly % coefficients ) . EQ . 2 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) CALL IncrementMatrix ( T_Powers ( 2 ), OutputMat , & & alpha_in = poly % coefficients ( 2 )) ELSE !! Adjust the coefficients. coefficient_midpoint = SIZE ( poly % coefficients ) / 2 left_length = coefficient_midpoint right_length = SIZE ( poly % coefficients ) - coefficient_midpoint ALLOCATE ( left_poly % coefficients ( left_length )) ALLOCATE ( right_poly % coefficients ( right_length )) left_poly % coefficients (:) = poly % coefficients (: coefficient_midpoint ) right_poly % coefficients (:) = poly % coefficients ( coefficient_midpoint + 1 :) DO counter = 2 , SIZE ( left_poly % coefficients ) left_poly % coefficients ( counter ) = left_poly % coefficients ( counter ) - & & poly % coefficients ( SIZE ( poly % coefficients ) - counter + 2 ) END DO !! Left recursion CALL ComputeRecursive ( T_Powers , left_poly , LeftMat , pool , depth + 1 , & & solver_parameters ) !! Right recursion full_midpoint = SIZE ( T_Powers ) - depth + 1 CALL ComputeRecursive ( T_Powers , right_poly , RightMat , pool , depth + 1 , & & solver_parameters ) !! Sum Together CALL MatrixMultiply ( T_Powers ( full_midpoint ), RightMat , & & OutputMat , threshold_in = solver_parameters % threshold , & & alpha_in = REAL ( 2.0 , NTREAL ), memory_pool_in = pool ) CALL IncrementMatrix ( LeftMat , OutputMat ) CALL IncrementMatrix ( T_Powers ( full_midpoint ), & & OutputMat , alpha_in =- 1.0 * right_poly % coefficients ( 1 )) !! Cleanup DEALLOCATE ( left_poly % coefficients ) DEALLOCATE ( right_poly % coefficients ) CALL DestructMatrix ( LeftMat ) CALL DestructMatrix ( RightMat ) END IF END SUBROUTINE ComputeRecursive !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ChebyshevSolversModule","tags":"","loc":"sourcefile/chebyshevsolversmodule.f90.html"},{"title":"NTMPIModule.F90 – NTPoly","text":"Contents Modules NTMPIModule Source Code NTMPIModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module wraps the MPI include statement because on certain platforms !! just writing \"USE MPI\" does not work. MODULE NTMPIModule #if USE_MPIH include \"mpif.h\" #else USE MPI #endif END MODULE","tags":"","loc":"sourcefile/ntmpimodule.f90.html"},{"title":"TrigonometrySolversModule.F90 – NTPoly","text":"Contents Modules TrigonometrySolversModule Source Code TrigonometrySolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Trigonometric functions of a Matrix. MODULE TrigonometrySolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement , WriteCitation USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: Sine PUBLIC :: Cosine PUBLIC :: ScaleSquareTrigonometryTaylor CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the sine of a matrix. SUBROUTINE Sine ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! A temporary matrix to hold the transformation from sine to cosine. TYPE ( Matrix_ps ) :: ShiftedMat TYPE ( Matrix_ps ) :: IdentityMat REAL ( NTREAL ), PARAMETER :: PI = 4 * ATAN ( 1.00_NTREAL ) !! Shift CALL CopyMatrix ( InputMat , ShiftedMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) CALL IncrementMatrix ( IdentityMat , ShiftedMat , & & alpha_in = REAL ( - 1.0_NTREAL * PI / 2.0_NTREAL , NTREAL )) CALL DestructMatrix ( IdentityMat ) IF ( PRESENT ( solver_parameters_in )) THEN CALL ScaleSquareTrigonometry ( ShiftedMat , OutputMat , solver_parameters_in ) ELSE CALL ScaleSquareTrigonometry ( ShiftedMat , OutputMat ) END IF !! Cleanup CALL DestructMatrix ( ShiftedMat ) END SUBROUTINE Sine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the cosine of a matrix. SUBROUTINE Cosine ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in IF ( PRESENT ( solver_parameters_in )) THEN CALL ScaleSquareTrigonometry ( InputMat , OutputMat , solver_parameters_in ) ELSE CALL ScaleSquareTrigonometry ( InputMat , OutputMat ) END IF END SUBROUTINE Cosine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute trigonometric functions of a matrix using a taylor series. SUBROUTINE ScaleSquareTrigonometryTaylor ( InputMat , OutputMat , & & solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( Matrix_ps ) :: IdentityMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: counter !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Trigonometry Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Taylor\" ) CALL WriteCitation ( \"higham2003computing\" ) CALL PrintParameters ( solver_parameters ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0_NTREAL sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 3.0e-3_NTREAL ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0_NTREAL / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL FillMatrixIdentity ( OutputMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Square the scaled matrix. taylor_denom = - 2.0_NTREAL CALL CopyMatrix ( OutputMat , Ak ) CALL MatrixMultiply ( ScaledMat , ScaledMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , ScaledMat ) !! Expand Taylor Series DO counter = 2 , 40 , 2 CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat , & & alpha_in = REAL ( 1.0_NTREAL / taylor_denom , NTREAL )) taylor_denom = taylor_denom * ( counter + 1 ) taylor_denom = - 1.0_NTREAL * taylor_denom * ( counter + 1 ) END DO !! Undo scaling DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) CALL ScaleMatrix ( OutputMat , REAL ( 2.0_NTREAL , NTREAL )) CALL IncrementMatrix ( IdentityMat , OutputMat , & & REAL ( - 1.0_NTREAL , NTREAL )) END DO IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Ak ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ScaleSquareTrigonometryTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute trigonometric functions of a matrix. !> This method uses Chebyshev polynomials. SUBROUTINE ScaleSquareTrigonometry ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( Matrix_ps ) :: IdentityMat !! For Chebyshev Expansion REAL ( NTREAL ), DIMENSION ( 17 ) :: coefficients TYPE ( Matrix_ps ) :: T2 TYPE ( Matrix_ps ) :: T4 TYPE ( Matrix_ps ) :: T6 TYPE ( Matrix_ps ) :: T8 !! Local Variables REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: counter !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Trigonometry Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Chebyshev\" ) CALL WriteCitation ( \"serbin1980algorithm higham2003computing yau1993reducing\" ) CALL PrintParameters ( solver_parameters ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0_NTREAL sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0_NTREAL ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0_NTREAL / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Expand the Chebyshev Polynomial. coefficients ( 1 ) = 7.651976865579664e-01_NTREAL coefficients ( 2 ) = 0 coefficients ( 3 ) = - 2.298069698638004e-01_NTREAL coefficients ( 4 ) = 0 coefficients ( 5 ) = 4.953277928219409e-03_NTREAL coefficients ( 6 ) = 0 coefficients ( 7 ) = - 4.187667600472235e-05_NTREAL coefficients ( 8 ) = 0 coefficients ( 9 ) = 1.884468822397086e-07_NTREAL coefficients ( 10 ) = 0 coefficients ( 11 ) = - 5.261224549346905e-10_NTREAL coefficients ( 12 ) = 0 coefficients ( 13 ) = 9.999906645345580e-13_NTREAL coefficients ( 14 ) = 0 coefficients ( 15 ) = - 2.083597362700025e-15_NTREAL coefficients ( 16 ) = 0 coefficients ( 17 ) = 9.181480886537484e-17_NTREAL !! Basic T Values. CALL MatrixMultiply ( ScaledMat , ScaledMat , T2 , alpha_in = 2.0_NTREAL ,& & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( IdentityMat , T2 , alpha_in =- 1.0_NTREAL ) CALL MatrixMultiply ( T2 , T2 , T4 , alpha_in = 2.0_NTREAL ,& & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( IdentityMat , T4 , alpha_in =- 1.0_NTREAL ) CALL MatrixMultiply ( T4 , T2 , T6 , alpha_in = 2.0_NTREAL ,& & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( T2 , T6 , alpha_in =- 1.0_NTREAL ) CALL MatrixMultiply ( T6 , T2 , T8 , alpha_in = 2.0_NTREAL ,& & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( T4 , T8 , alpha_in =- 1.0_NTREAL ) !! Contribution from the second half. CALL CopyMatrix ( T8 , OutputMat ) CALL ScaleMatrix ( OutputMat , 0.5_NTREAL * coefficients ( 17 )) CALL IncrementMatrix ( T6 , OutputMat , alpha_in = 0.5_NTREAL * coefficients ( 15 )) CALL IncrementMatrix ( T4 , OutputMat , alpha_in = 0.5_NTREAL * coefficients ( 13 )) CALL IncrementMatrix ( T2 , OutputMat , alpha_in = 0.5_NTREAL * coefficients ( 11 )) CALL MatrixMultiply ( T8 , OutputMat , TempMat ,& & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Contribution from the first half. CALL CopyMatrix ( T8 , OutputMat ) CALL ScaleMatrix ( OutputMat , coefficients ( 9 )) CALL IncrementMatrix ( T6 , OutputMat ,& & alpha_in = coefficients ( 7 ) + 0.5_NTREAL * coefficients ( 11 )) CALL IncrementMatrix ( T4 , OutputMat ,& & alpha_in = coefficients ( 5 ) + 0.5_NTREAL * coefficients ( 13 )) CALL IncrementMatrix ( T2 , OutputMat ,& & alpha_in = coefficients ( 3 ) + 0.5_NTREAL * coefficients ( 15 )) CALL IncrementMatrix ( IdentityMat , OutputMat ,& & alpha_in = coefficients ( 1 ) + 0.5_NTREAL * coefficients ( 17 )) CALL IncrementMatrix ( TempMat , OutputMat ) !! Undo scaling DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) CALL ScaleMatrix ( OutputMat , 2.0_NTREAL ) CALL IncrementMatrix ( IdentityMat , OutputMat , - 1.0_NTREAL ) END DO IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( T2 ) CALL DestructMatrix ( T4 ) CALL DestructMatrix ( T6 ) CALL DestructMatrix ( T8 ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ScaleSquareTrigonometry !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TrigonometrySolversModule","tags":"","loc":"sourcefile/trigonometrysolversmodule.f90.html"},{"title":"PMatrixMemoryPoolModule.F90 – NTPoly","text":"Contents Modules PMatrixMemoryPoolModule Source Code PMatrixMemoryPoolModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling scratch memory for distributed matrix multiplication. MODULE PMatrixMemoryPoolModule USE PSMatrixModule , ONLY : Matrix_ps USE MatrixMemoryPoolModule , ONLY : MatrixMemoryPool_lr , MatrixMemoryPool_lc , & & DestructMatrixMemoryPool IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_p !> Grid of local pools. TYPE ( MatrixMemoryPool_lr ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: grid_r !> Grid of local pools (complex). TYPE ( MatrixMemoryPool_lc ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: grid_c END TYPE MatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: DestructMatrixMemoryPool PUBLIC :: CheckMemoryPoolValidity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MatrixMemoryPool_p MODULE PROCEDURE ConstructMatrixMemoryPool_p END INTERFACE INTERFACE DestructMatrixMemoryPool MODULE PROCEDURE DestructMatrixMemoryPool_p END INTERFACE INTERFACE CheckMemoryPoolValidity MODULE PROCEDURE CheckMemoryPoolValidity_p END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct Distributed Matrix Memory Pool object. PURE FUNCTION ConstructMatrixMemoryPool_p ( matrix ) RESULT ( this ) !> A constructed Matrix Memory Pool object. TYPE ( MatrixMemoryPool_p ) :: this !> The associated distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: matrix !! Allocate IF ( matrix % is_complex ) THEN ALLOCATE ( this % grid_c ( matrix % process_grid % number_of_blocks_rows , & & matrix % process_grid % number_of_blocks_columns )) ELSE ALLOCATE ( this % grid_r ( matrix % process_grid % number_of_blocks_rows , & & matrix % process_grid % number_of_blocks_columns )) END IF END FUNCTION ConstructMatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a Distributed Matrix Memory Pool object. PURE SUBROUTINE DestructMatrixMemoryPool_p ( this ) !> Distributed Matrix Memory Pool object to destroy. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: this !! Local Data INTEGER :: row_counter , column_counter #define grid grid_r #include \"distributed_pool_includes/DestructMatrixMemoryPool.f90\" #undef grid #define grid grid_c #include \"distributed_pool_includes/DestructMatrixMemoryPool.f90\" #undef grid END SUBROUTINE DestructMatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given distributed memory pool has been validly allocated to !> handle the given parameters. PURE FUNCTION CheckMemoryPoolValidity_p ( this , matrix ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_p ), INTENT ( IN ) :: this !> The associated matrix to check against. TYPE ( Matrix_ps ), INTENT ( IN ) :: matrix !> True if the memory pool is valid. LOGICAL :: isvalid isvalid = . TRUE . !! Check allocation IF ( matrix % is_complex ) THEN IF (. NOT . ALLOCATED ( this % grid_c )) isvalid = . FALSE . ELSE IF (. NOT . ALLOCATED ( this % grid_r )) isvalid = . FALSE . END IF END FUNCTION CheckMemoryPoolValidity_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PMatrixMemoryPoolModule","tags":"","loc":"sourcefile/pmatrixmemorypoolmodule.f90.html"},{"title":"TripletListModule.F90 – NTPoly","text":"Contents Modules TripletListModule Source Code TripletListModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Storing Lists of Triplets. MODULE TripletListModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER USE TripletModule , ONLY : Triplet_r , Triplet_c , CompareTriplets , & & ConvertTripletType USE MatrixMarketModule , ONLY : MM_SYMMETRIC , MM_SKEW_SYMMETRIC , MM_HERMITIAN USE , INTRINSIC :: ISO_C_BINDING , ONLY : c_int IMPLICIT NONE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a list of triplets. TYPE :: TripletList_r !> Internal representation of the data. TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE :: DATA !> Current number of elements in the triplet list INTEGER :: CurrentSize END TYPE TripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a list of triplets. TYPE :: TripletList_c !> Internal representation of the data. TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE :: DATA !> Current number of elements in the triplet list INTEGER :: CurrentSize END TYPE TripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: TripletList_r PUBLIC :: TripletList_c PUBLIC :: ConstructTripletList PUBLIC :: DestructTripletList PUBLIC :: ResizeTripletList PUBLIC :: AppendToTripletList PUBLIC :: AccumulateTripletList PUBLIC :: SetTripletAt PUBLIC :: GetTripletAt PUBLIC :: SortTripletList PUBLIC :: SymmetrizeTripletList PUBLIC :: GetTripletListSize PUBLIC :: RedistributeTripletLists PUBLIC :: ShiftTripletList PUBLIC :: ConvertTripletListType !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE TripletList_r MODULE PROCEDURE ConstructTripletList_r END INTERFACE INTERFACE TripletList_c MODULE PROCEDURE ConstructTripletList_c END INTERFACE INTERFACE ConstructTripletList MODULE PROCEDURE ConstructTripletListSup_r MODULE PROCEDURE ConstructTripletListSup_c END INTERFACE INTERFACE DestructTripletList MODULE PROCEDURE DestructTripletList_r MODULE PROCEDURE DestructTripletList_c END INTERFACE INTERFACE ResizeTripletList MODULE PROCEDURE ResizeTripletList_r MODULE PROCEDURE ResizeTripletList_c END INTERFACE INTERFACE AppendToTripletList MODULE PROCEDURE AppendToTripletList_r MODULE PROCEDURE AppendToTripletList_c END INTERFACE INTERFACE AccumulateTripletList MODULE PROCEDURE AccumulateTripletList_r MODULE PROCEDURE AccumulateTripletList_c END INTERFACE INTERFACE SetTripletAt MODULE PROCEDURE SetTripletAt_r MODULE PROCEDURE SetTripletAt_c END INTERFACE INTERFACE GetTripletAt MODULE PROCEDURE GetTripletAt_r MODULE PROCEDURE GetTripletAt_c END INTERFACE INTERFACE SortTripletList MODULE PROCEDURE SortTripletList_r MODULE PROCEDURE SortTripletList_c END INTERFACE INTERFACE SortDenseTripletList MODULE PROCEDURE SortDenseTripletList_r MODULE PROCEDURE SortDenseTripletList_c END INTERFACE INTERFACE SymmetrizeTripletList MODULE PROCEDURE SymmetrizeTripletList_r MODULE PROCEDURE SymmetrizeTripletList_c END INTERFACE INTERFACE GetTripletListSize MODULE PROCEDURE GetTripletListSize_r MODULE PROCEDURE GetTripletListSize_c END INTERFACE INTERFACE RedistributeTripletLists MODULE PROCEDURE RedistributeTripletLists_r MODULE PROCEDURE RedistributeTripletLists_c END INTERFACE INTERFACE ShiftTripletList MODULE PROCEDURE ShiftTripletList_r MODULE PROCEDURE ShiftTripletList_c END INTERFACE INTERFACE ConvertTripletListType MODULE PROCEDURE ConvertTripletListToReal MODULE PROCEDURE ConvertTripletListToComplex END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for constructing a triplet list. PURE SUBROUTINE ConstructTripletListSup_r ( this , size_in ) !> The triplet list to construct. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The length of the triplet list (default=0). INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: size_in IF ( PRESENT ( size_in )) THEN this = ConstructTripletList_r ( size_in ) ELSE this = ConstructTripletList_r () END IF END SUBROUTINE ConstructTripletListSup_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for constructing a triplet list. PURE SUBROUTINE ConstructTripletListSup_c ( this , size_in ) !> The triplet list to construct. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The length of the triplet list (default=0). INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: size_in IF ( PRESENT ( size_in )) THEN this = ConstructTripletList_c ( size_in ) ELSE this = ConstructTripletList_c () END IF END SUBROUTINE ConstructTripletListSup_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list. PURE FUNCTION ConstructTripletList_r ( size_in ) RESULT ( this ) !> The triplet list to construct. TYPE ( TripletList_r ) :: this !> The length of the triplet list (default=0). INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: size_in INCLUDE \"triplet_includes/ConstructTripletList.f90\" END FUNCTION ConstructTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list. PURE FUNCTION ConstructTripletList_c ( size_in ) RESULT ( this ) !> The triplet list to construct. TYPE ( TripletList_c ) :: this !> The length of the triplet list (default=0). INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: size_in INCLUDE \"triplet_includes/ConstructTripletList.f90\" END FUNCTION ConstructTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destructs a triplet list. PURE SUBROUTINE DestructTripletList_r ( this ) !> The triplet list to destruct. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this INCLUDE \"triplet_includes/DestructTripletList.f90\" END SUBROUTINE DestructTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destructs a triplet list. PURE SUBROUTINE DestructTripletList_c ( this ) !> The triplet list to destruct. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this INCLUDE \"triplet_includes/DestructTripletList.f90\" END SUBROUTINE DestructTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Increase the size of a triplet list. PURE SUBROUTINE ResizeTripletList_r ( this , size ) !> The triplet list to resize. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> Size to resize to. INTEGER ( KIND = c_int ), INTENT ( IN ) :: size !! Local Data TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE :: temporary_data INCLUDE \"triplet_includes/ResizeTripletList.f90\" END SUBROUTINE ResizeTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Increase the size of a triplet list. PURE SUBROUTINE ResizeTripletList_c ( this , size ) !> The triplet list to resize. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> Size to resize to. INTEGER ( KIND = c_int ), INTENT ( IN ) :: size !! Local Data TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE :: temporary_data INCLUDE \"triplet_includes/ResizeTripletList.f90\" END SUBROUTINE ResizeTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add a value to the end of the triplet list. PURE SUBROUTINE AppendToTripletList_r ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The value to append. TYPE ( Triplet_r ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/AppendToTripletList.f90\" END SUBROUTINE AppendToTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add a value to the end of the triplet list. PURE SUBROUTINE AppendToTripletList_c ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The value to append. TYPE ( Triplet_c ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/AppendToTripletList.f90\" END SUBROUTINE AppendToTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> (Just for a related project) PURE SUBROUTINE AccumulateTripletList_r ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The value to add in. TYPE ( Triplet_r ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/AccumulateTripletList.f90\" END SUBROUTINE AccumulateTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> (Just for a related project) PURE SUBROUTINE AccumulateTripletList_c ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The value to add in. TYPE ( Triplet_c ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/AccumulateTripletList.f90\" END SUBROUTINE AccumulateTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of a triplet at a particular index. PURE SUBROUTINE SetTripletAt_r ( this , index , triplet_value ) !> The triplet list to set. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The index at which to set the triplet. INTEGER ( KIND = c_int ), INTENT ( IN ) :: index !> The value of the triplet to set. TYPE ( Triplet_r ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/SetTripletAt.f90\" END SUBROUTINE SetTripletAt_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of a triplet at a particular index. PURE SUBROUTINE SetTripletAt_c ( this , index , triplet_value ) !> The triplet list to set. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The index at which to set the triplet. INTEGER ( KIND = c_int ), INTENT ( IN ) :: index !> The value of the triplet to set. TYPE ( Triplet_c ), INTENT ( IN ) :: triplet_value INCLUDE \"triplet_includes/SetTripletAt.f90\" END SUBROUTINE SetTripletAt_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the value of a triplet at a particular index. PURE SUBROUTINE GetTripletAt_r ( this , index , triplet_value ) !> The triplet list to get the value from. TYPE ( TripletList_r ), INTENT ( IN ) :: this !> The index from which to get the triplet. INTEGER ( kind = c_int ), INTENT ( IN ) :: index !> The extracted triplet value. TYPE ( Triplet_r ), INTENT ( OUT ) :: triplet_value INCLUDE \"triplet_includes/GetTripletAt.f90\" END SUBROUTINE GetTripletAt_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the value of a triplet at a particular index. PURE SUBROUTINE GetTripletAt_c ( this , index , triplet_value ) !> The triplet list to get the value from. TYPE ( TripletList_c ), INTENT ( IN ) :: this !> The index from which to get the triplet. INTEGER ( kind = c_int ), INTENT ( IN ) :: index !> The extracted triplet value. TYPE ( Triplet_c ), INTENT ( OUT ) :: triplet_value INCLUDE \"triplet_includes/GetTripletAt.f90\" END SUBROUTINE GetTripletAt_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sorts a triplet list by index values. !> Implementation is based on bucket sort. This is why it needs the number of !> matrix columns. Bubble sort is used within a bucket. PURE SUBROUTINE SortTripletList_r ( input_list , matrix_columns , matrix_rows , & & sorted_list , bubble_in ) !> List to be sorted. TYPE ( TripletList_r ), INTENT ( IN ) :: input_list !> This is the highest column value in the list. INTEGER , INTENT ( IN ) :: matrix_columns !> This is the highest row value in the list. INTEGER , INTENT ( IN ) :: matrix_rows !> A now sorted version of the list. This routine will allocate it. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_list !> False if you don't need the final bubble sort. LOGICAL , OPTIONAL , INTENT ( IN ) :: bubble_in !! Local Data TYPE ( Triplet_r ) :: temporary #include \"triplet_includes/SortTripletList.f90\" END SUBROUTINE SortTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sorts a triplet list by index values. !> Implementation is based on bucket sort. This is why it needs the number of !> matrix columns. Bubble sort is used within a bucket. PURE SUBROUTINE SortTripletList_c ( input_list , matrix_columns , matrix_rows , & & sorted_list , bubble_in ) !> List to be sorted. TYPE ( TripletList_c ), INTENT ( IN ) :: input_list !> This is the highest column value in the list. INTEGER , INTENT ( IN ) :: matrix_columns !> This is the highest row value in the list. INTEGER , INTENT ( IN ) :: matrix_rows !> A now sorted version of the list. This routine will allocate it. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_list !> False if you don't need the final bubble sort. LOGICAL , OPTIONAL , INTENT ( IN ) :: bubble_in !! Local Data TYPE ( Triplet_c ) :: temporary #include \"triplet_includes/SortTripletList.f90\" END SUBROUTINE SortTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of entries in a triplet list. PURE FUNCTION GetTripletListSize_r ( triplet_list ) RESULT ( list_size ) !> List to get the size of. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> The number of entries in the triplet list. INTEGER :: list_size INCLUDE \"triplet_includes/GetTripletListSize.f90\" END FUNCTION GetTripletListSize_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of entries in a triplet list. PURE FUNCTION GetTripletListSize_c ( triplet_list ) RESULT ( list_size ) !> List to get the size of. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> The number of entries in the triplet list. INTEGER :: list_size INCLUDE \"triplet_includes/GetTripletListSize.f90\" END FUNCTION GetTripletListSize_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute some triplet lists amongst a set of processors. !> Takes in a list of triplet lists, one list for each processor. Then the !> all to all redistribution is performed along the given communicator. SUBROUTINE RedistributeTripletLists_r ( triplet_lists , comm , local_data_out ) !> A list of triplet lists, one for each process. TYPE ( TripletList_r ), DIMENSION (:), INTENT ( IN ) :: triplet_lists !> The mpi communicator to redistribute along. INTEGER , INTENT ( INOUT ) :: comm !> The resulting local triplet list. TYPE ( TripletList_r ), INTENT ( INOUT ) :: local_data_out !! Local data (type specific) REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: send_buffer_val REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val TYPE ( Triplet_r ) :: temp_triplet #define MPIDATATYPE MPINTREAL #include \"triplet_includes/RedistributeTripletLists.f90\" #undef MPIDATATYPE END SUBROUTINE RedistributeTripletLists_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute some triplet lists amongst a set of processors. !> Takes in a list of triplet lists, one list for each processor. Then the !> all to all redistribution is performed along the given communicator. SUBROUTINE RedistributeTripletLists_c ( triplet_lists , comm , local_data_out ) !> A list of triplet lists, one for each process. TYPE ( TripletList_c ), DIMENSION (:), INTENT ( IN ) :: triplet_lists !> The mpi communicator to redistribute along. INTEGER , INTENT ( INOUT ) :: comm !> The resulting local triplet list. TYPE ( TripletList_c ), INTENT ( INOUT ) :: local_data_out !! Local data (type specific) COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: send_buffer_val COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val TYPE ( Triplet_c ) :: temp_triplet #define MPIDATATYPE MPINTCOMPLEX #include \"triplet_includes/RedistributeTripletLists.f90\" #undef MPIDATATYPE END SUBROUTINE RedistributeTripletLists_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Shift the rows and columns of a triplet list by set values. !> Frequently, we have a triplet list that comes from the global matrix which !> we would like to shift into a local matrix. In that case, just pass !> the negative of the starting row and column (plus 1) to this routine. PURE SUBROUTINE ShiftTripletList_r ( triplet_list , row_shift , column_shift ) !> The triplet list to shift. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> The row offset to shift by. INTEGER , INTENT ( IN ) :: row_shift !> The column offset to shift by. INTEGER , INTENT ( IN ) :: column_shift !! Local Variables INTEGER :: counter INCLUDE \"triplet_includes/ShiftTripletList.f90\" END SUBROUTINE ShiftTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Shift the rows and columns of a triplet list by set values. !> Frequently, we have a triplet list that comes from the global matrix which !> we would like to shift into a local matrix. In that case, just pass !> the negative of the starting row and column (plus 1) to this routine. PURE SUBROUTINE ShiftTripletList_c ( triplet_list , row_shift , column_shift ) !> The triplet list to shift. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> The row offset to shift by. INTEGER , INTENT ( IN ) :: row_shift !> The column offset to shift by. INTEGER , INTENT ( IN ) :: column_shift !! Local Variables INTEGER :: counter INCLUDE \"triplet_includes/ShiftTripletList.f90\" END SUBROUTINE ShiftTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sort a triplet list assuming that the matrix it corresponds to is nearly !> dense. PURE SUBROUTINE SortDenseTripletList_r ( input_list , matrix_columns , & & matrix_rows , sorted_list ) !> The list to sort. TYPE ( TripletList_r ), INTENT ( IN ) :: input_list !> Number of columns for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_columns !> Number of rows for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_rows !> Sorted and ready to use for building matrices. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_list !! Local Variables REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: value_buffer #include \"triplet_includes/SortDenseTripletList.f90\" END SUBROUTINE SortDenseTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sort a triplet list assuming that the matrix it corresponds to is nearly !> dense. PURE SUBROUTINE SortDenseTripletList_c ( input_list , matrix_columns , & & matrix_rows , sorted_list ) !> The list to sort. TYPE ( TripletList_c ), INTENT ( IN ) :: input_list !> Number of columns for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_columns !> Number of rows for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_rows !> Sorted and ready to use for building matrices. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_list !! Local Variables COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: value_buffer #include \"triplet_includes/SortDenseTripletList.f90\" END SUBROUTINE SortDenseTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Symmetrizes an unsymmetric triplet list according to the specified !> symmetry type. SUBROUTINE SymmetrizeTripletList_r ( triplet_list , pattern_type ) !> List to be symmetrized. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> Type of symmetry. INTEGER , INTENT ( IN ) :: pattern_type !! Local variables TYPE ( Triplet_r ) :: temporary , temporary_transpose INTEGER :: counter INTEGER :: initial_size initial_size = triplet_list % CurrentSize SELECT CASE ( pattern_type ) CASE ( MM_SYMMETRIC ) DO counter = 1 , initial_size CALL GetTripletAt ( triplet_list , counter , temporary ) IF ( temporary % index_column . NE . temporary % index_row ) THEN temporary_transpose % index_row = temporary % index_column temporary_transpose % index_column = temporary % index_row temporary_transpose % point_value = temporary % point_value CALL AppendToTripletList ( triplet_list , temporary_transpose ) END IF END DO CASE ( MM_SKEW_SYMMETRIC ) DO counter = 1 , initial_size CALL GetTripletAt ( triplet_list , counter , temporary ) IF ( temporary % index_column . NE . temporary % index_row ) THEN temporary_transpose % index_row = temporary % index_column temporary_transpose % index_column = temporary % index_row temporary_transpose % point_value = - 1.0 * temporary % point_value CALL AppendToTripletList ( triplet_list , temporary_transpose ) END IF END DO END SELECT END SUBROUTINE SymmetrizeTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Symmetrizes an unsymmetric triplet list according to the specified !> symmetry type. SUBROUTINE SymmetrizeTripletList_c ( triplet_list , pattern_type ) !> List to be symmetrized. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> Type of symmetry. INTEGER , INTENT ( IN ) :: pattern_type !! Local variables TYPE ( Triplet_c ) :: temporary , temporary_transpose INTEGER :: counter INTEGER :: initial_size initial_size = triplet_list % CurrentSize SELECT CASE ( pattern_type ) CASE ( MM_SYMMETRIC ) DO counter = 1 , initial_size CALL GetTripletAt ( triplet_list , counter , temporary ) IF ( temporary % index_column . NE . temporary % index_row ) THEN temporary_transpose % index_row = temporary % index_column temporary_transpose % index_column = temporary % index_row temporary_transpose % point_value = temporary % point_value CALL AppendToTripletList ( triplet_list , temporary_transpose ) END IF END DO CASE ( MM_HERMITIAN ) DO counter = 1 , initial_size CALL GetTripletAt ( triplet_list , counter , temporary ) IF ( temporary % index_column . NE . temporary % index_row ) THEN temporary_transpose % index_row = temporary % index_column temporary_transpose % index_column = temporary % index_row temporary_transpose % point_value = CONJG ( temporary % point_value ) CALL AppendToTripletList ( triplet_list , temporary_transpose ) END IF END DO CASE ( MM_SKEW_SYMMETRIC ) DO counter = 1 , initial_size CALL GetTripletAt ( triplet_list , counter , temporary ) IF ( temporary % index_column . NE . temporary % index_row ) THEN temporary_transpose % index_row = temporary % index_column temporary_transpose % index_column = temporary % index_row temporary_transpose % point_value = - 1.0 * temporary % point_value CALL AppendToTripletList ( triplet_list , temporary_transpose ) END IF END DO END SELECT END SUBROUTINE SymmetrizeTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex triplet list to a real triplet list. SUBROUTINE ConvertTripletListToReal ( cin_triplet , rout_triplet ) !> The starting triplet list. TYPE ( TripletList_c ), INTENT ( IN ) :: cin_triplet !> Real valued triplet list. TYPE ( TripletList_r ), INTENT ( INOUT ) :: rout_triplet !! Local Variables INTEGER :: II CALL ConstructTripletList ( rout_triplet , cin_triplet % CurrentSize ) DO II = 1 , cin_triplet % CurrentSize CALL ConvertTripletType ( cin_triplet % data ( II ), rout_triplet % data ( II )) END DO END SUBROUTINE ConvertTripletListToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real triplet to a complex triplet list. SUBROUTINE ConvertTripletListToComplex ( rin_triplet , cout_triplet ) !> The starting triplet list. TYPE ( TripletList_r ), INTENT ( IN ) :: rin_triplet !> Complex valued triplet list. TYPE ( TripletList_c ), INTENT ( INOUT ) :: cout_triplet !! Local Variables INTEGER :: II CALL ConstructTripletList ( cout_triplet , rin_triplet % CurrentSize ) DO II = 1 , rin_triplet % CurrentSize CALL ConvertTripletType ( rin_triplet % data ( II ), cout_triplet % data ( II )) END DO END SUBROUTINE ConvertTripletListToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TripletListModule","tags":"","loc":"sourcefile/tripletlistmodule.f90.html"},{"title":"SolverParametersModule.F90 – NTPoly","text":"Contents Modules SolverParametersModule Source Code SolverParametersModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Storing The Parameters For Iterative Solvers. MODULE SolverParametersModule USE DataTypesModule , ONLY : NTREAL USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader USE PermutationModule , ONLY : Permutation_t , DestructPermutation IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A class for passing parameters to an iterative solver. TYPE , PUBLIC :: SolverParameters_t !> When do we consider a calculation converged. REAL ( NTREAL ) :: converge_diff !> Maximum number of iterations of a solver before termination. INTEGER :: max_iterations !> Threshold for sparse multiplication and addition. REAL ( NTREAL ) :: threshold !> If true, the sparse solver prints out information each loop iteration. LOGICAL :: be_verbose !> If true, the sparse solver will try and load balance before calculation. LOGICAL :: do_load_balancing !> The permutation used for load balancing. TYPE ( Permutation_t ) :: BalancePermutation END TYPE SolverParameters_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE SolverParameters_t MODULE PROCEDURE SolverParameters_init END INTERFACE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SetParametersConvergeDiff PUBLIC :: SetParametersMaxIterations PUBLIC :: SetParametersThreshold PUBLIC :: SetParametersBeVerbose PUBLIC :: SetParametersLoadBalance PUBLIC :: PrintParameters PUBLIC :: DestructSolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The default convergence difference. REAL ( NTREAL ), PARAMETER , PUBLIC :: CONVERGENCE_DIFF_CONST = 1 e - 6 !> The default maximum number of iterations. INTEGER , PARAMETER , PUBLIC :: MAX_ITERATIONS_CONST = 1000 CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a data type which stores iterative solver parameters. PURE FUNCTION SolverParameters_init ( converge_diff_in , threshold_in , & & max_iterations_in , be_verbose_in , BalancePermutation_in ) RESULT ( this ) !> Converge_diff_in the difference between iterations to consider !> a calculation converged. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: converge_diff_in !> The zero threshold REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !> The maximum number of iterations to perform INTEGER , INTENT ( IN ), OPTIONAL :: max_iterations_in !> Whether to print during the calculation (default = False) LOGICAL , INTENT ( IN ), OPTIONAL :: be_verbose_in !> For load balancing TYPE ( Permutation_t ), INTENT ( IN ), OPTIONAL :: BalancePermutation_in TYPE ( SolverParameters_t ) :: this !! Optional Parameters IF (. NOT . PRESENT ( converge_diff_in )) THEN this % converge_diff = CONVERGENCE_DIFF_CONST ELSE this % converge_diff = converge_diff_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN this % threshold = 0.0 ELSE this % threshold = threshold_in END IF IF (. NOT . PRESENT ( max_iterations_in )) THEN this % max_iterations = MAX_ITERATIONS_CONST ELSE this % max_iterations = max_iterations_in END IF IF (. NOT . PRESENT ( be_verbose_in )) THEN this % be_verbose = . FALSE . ELSE this % be_verbose = be_verbose_in END IF IF (. NOT . PRESENT ( BalancePermutation_in )) THEN this % do_load_balancing = . FALSE . ELSE this % do_load_balancing = . TRUE . this % BalancePermutation = BalancePermutation_in END IF END FUNCTION SolverParameters_init !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the convergence difference. PURE SUBROUTINE SetParametersConvergeDiff ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. REAL ( NTREAL ), INTENT ( IN ) :: new_value this % converge_diff = new_value END SUBROUTINE SetParametersConvergeDiff !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the max iterations. PURE SUBROUTINE SetParametersMaxIterations ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. INTEGER , INTENT ( IN ) :: new_value this % max_iterations = new_value END SUBROUTINE SetParametersMaxIterations !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the threshold. PURE SUBROUTINE SetParametersThreshold ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. REAL ( NTREAL ), INTENT ( IN ) :: new_value this % threshold = new_value END SUBROUTINE SetParametersThreshold !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the verbosity. PURE SUBROUTINE SetParametersBeVerbose ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. LOGICAL , INTENT ( IN ) :: new_value this % be_verbose = new_value END SUBROUTINE SetParametersBeVerbose !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the load balance. PURE SUBROUTINE SetParametersLoadBalance ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. TYPE ( Permutation_t ), INTENT ( IN ) :: new_value this % do_load_balancing = . TRUE . this % BalancePermutation = new_value END SUBROUTINE SetParametersLoadBalance !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the iterative solver parameter values. SUBROUTINE PrintParameters ( this ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( IN ) :: this CALL WriteHeader ( \"Solver Parameters\" ) CALL EnterSubLog CALL WriteElement ( key = \"be_verbose\" , value = this % be_verbose ) CALL WriteElement ( key = \"do_load_balancing\" , value = this % do_load_balancing ) CALL WriteElement ( key = \"converge_diff\" , value = this % converge_diff ) CALL WriteElement ( key = \"threshold\" , value = this % threshold ) CALL WriteElement ( key = \"max_iterations\" , value = this % max_iterations ) CALL ExitSubLog END SUBROUTINE PrintParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Cleanup the solver parameters datastructure. PURE SUBROUTINE DestructSolverParameters ( this ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this CALL DestructPermutation ( this % BalancePermutation ) END SUBROUTINE DestructSolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SolverParametersModule","tags":"","loc":"sourcefile/solverparametersmodule.f90.html"},{"title":"MatrixMapsModule.F90 – NTPoly","text":"Contents Modules MatrixMapsModule Source Code MatrixMapsModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Simplfiying Per Element Operations on Matrices. MODULE MatrixMapsModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & GetMatrixTripletList , FillMatrixFromTripletList USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & DestructTripletList , AppendToTripletList , GetTripletAt , & & ConstructTripletList USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MapMatrix_psr PUBLIC :: MapMatrix_psc PUBLIC :: MapTripletList !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MapMatrix_psr MODULE PROCEDURE MapMatrix_psr MODULE PROCEDURE MapMatrixArray_psr END INTERFACE INTERFACE MapMatrix_psc MODULE PROCEDURE MapMatrix_psc MODULE PROCEDURE MapMatrixArray_psc END INTERFACE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MapTripletList MODULE PROCEDURE MapTripletList_r MODULE PROCEDURE MapTripletList_c MODULE PROCEDURE MapTripletListArray_r MODULE PROCEDURE MapTripletListArray_c END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (real). SUBROUTINE MapMatrix_psr ( inmat , outmat , proc ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ) :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !! Local Variables TYPE ( TripletList_r ) :: inlist , outlist #include \"map_includes/MapMatrix.f90\" END SUBROUTINE MapMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (complex). SUBROUTINE MapMatrix_psc ( inmat , outmat , proc ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ) :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !! Local Variables TYPE ( TripletList_c ) :: inlist , outlist #include \"map_includes/MapMatrix.f90\" END SUBROUTINE MapMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletList_r ( inlist , outlist , proc , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_r ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_r ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ) :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_r ) :: temp #include \"map_includes/MapTripletList.f90\" END SUBROUTINE MapTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletList_c ( inlist , outlist , proc , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_c ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_c ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ) :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_c ) :: temp #include \"map_includes/MapTripletList.f90\" END SUBROUTINE MapTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (real). SUBROUTINE MapMatrixArray_psr ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ) :: val !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_r ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArray_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (complex). SUBROUTINE MapMatrixArray_psc ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ) :: val !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_c ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArray_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletListArray_r ( inlist , outlist , proc , supp_in , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_r ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_r ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ) :: val !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_r ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArray_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletListArray_c ( inlist , outlist , proc , supp_in , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_c ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_c ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ) :: row !> The column value of an element. INTEGER , INTENT ( INOUT ) :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ) :: val !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_c ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArray_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMapsModule","tags":"","loc":"sourcefile/matrixmapsmodule.f90.html"},{"title":"TimerModule.F90 – NTPoly","text":"Contents Modules TimerModule Source Code TimerModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to do timings. MODULE TimerModule USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader USE ProcessGridModule , ONLY : global_grid USE NTMPIModule IMPLICIT NONE PRIVATE LOGICAL :: is_initialized = . FALSE . CHARACTER ( len = 20 ), DIMENSION (:), ALLOCATABLE :: timer_list DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: start_times DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: elapsed_times !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: RegisterTimer PUBLIC :: StartTimer PUBLIC :: StopTimer PUBLIC :: PrintTimer PUBLIC :: PrintAllTimers PUBLIC :: PrintAllTimersDistributed CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Register a timer with the timer module.  Call this before using that timer. SUBROUTINE RegisterTimer ( timer_name ) !> Name of the timer. CHARACTER ( len =* ), INTENT ( IN ) :: timer_name !! Local Data CHARACTER ( len = 20 ), DIMENSION (:), ALLOCATABLE :: temp_timer_list DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: temp_start_times DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: temp_elapsed_times IF ( is_initialized ) THEN ALLOCATE ( temp_timer_list ( SIZE ( timer_list ) + 1 )) ALLOCATE ( temp_start_times ( SIZE ( start_times ) + 1 )) ALLOCATE ( temp_elapsed_times ( SIZE ( elapsed_times ) + 1 )) temp_timer_list (: SIZE ( timer_list )) = timer_list temp_start_times (: SIZE ( start_times )) = start_times temp_elapsed_times (: SIZE ( elapsed_times )) = elapsed_times CALL MOVE_ALLOC ( temp_timer_list , timer_list ) CALL MOVE_ALLOC ( temp_start_times , start_times ) CALL MOVE_ALLOC ( temp_elapsed_times , elapsed_times ) timer_list ( SIZE ( timer_list )) = timer_name elapsed_times ( SIZE ( timer_list )) = 0 ELSE ALLOCATE ( timer_list ( 1 )) ALLOCATE ( start_times ( 1 )) ALLOCATE ( elapsed_times ( 1 )) timer_list ( 1 ) = timer_name elapsed_times ( 1 ) = 0 is_initialized = . TRUE . END IF END SUBROUTINE RegisterTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Start the clock running for a given timer. SUBROUTINE StartTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( len =* ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: timer_position DOUBLE PRECISION :: temp_time temp_time = MPI_WTIME () timer_position = GetTimerPosition ( timer_name ) IF ( timer_position > 0 ) THEN start_times ( timer_position ) = temp_time END IF END SUBROUTINE StartTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Stop the clock for a given timer. SUBROUTINE StopTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( len =* ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: timer_position DOUBLE PRECISION :: temp_elapsed_time DOUBLE PRECISION :: temp_start_time timer_position = GetTimerPosition ( timer_name ) IF ( timer_position > 0 ) THEN temp_elapsed_time = MPI_WTIME () temp_start_time = start_times ( timer_position ) elapsed_times ( timer_position ) = elapsed_times ( timer_position ) + & & temp_elapsed_time - temp_start_time END IF END SUBROUTINE StopTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for a given timer. SUBROUTINE PrintTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( len =* ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: timer_position timer_position = GetTimerPosition ( timer_name ) CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog IF ( timer_position > 0 ) THEN CALL WriteElement ( key = timer_name , & & value = elapsed_times ( timer_position )) END IF CALL ExitSubLog END SUBROUTINE PrintTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for each timer on this process. SUBROUTINE PrintAllTimers () !! Local Data INTEGER :: timer_position CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog DO timer_position = LBOUND ( timer_list , dim = 1 ), UBOUND ( timer_list , dim = 1 ) CALL WriteElement ( key = timer_list ( timer_position ), & & value = elapsed_times ( timer_position )) END DO CALL ExitSubLog END SUBROUTINE PrintAllTimers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for each timer based on the max value across !> processes. SUBROUTINE PrintAllTimersDistributed () !! Local Data INTEGER :: timer_position DOUBLE PRECISION :: elapsed DOUBLE PRECISION :: max_time INTEGER :: ierr CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog DO timer_position = LBOUND ( timer_list , dim = 1 ), UBOUND ( timer_list , dim = 1 ) elapsed = elapsed_times ( timer_position ) CALL MPI_Allreduce ( elapsed , max_time , 1 , MPI_DOUBLE , MPI_MAX , & & global_grid % global_comm , ierr ) CALL WriteElement ( key = timer_list ( timer_position ), & & value = max_time ) END DO CALL ExitSubLog END SUBROUTINE PrintAllTimersDistributed !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Figure out the position in the timer list where timer_name is. !> This is a utility routine. FUNCTION GetTimerPosition ( timer_name ) RESULT ( timer_position ) !! Parameters !> Name of the timer. CHARACTER ( len =* ), INTENT ( IN ) :: timer_name !> The position of the timer. 0 means the timer hasn't been registered. INTEGER :: timer_position !! Local Data INTEGER :: counter LOGICAL :: not_found not_found = . TRUE . IF ( is_initialized ) THEN DO counter = 1 , SIZE ( timer_list ) IF ( timer_name . EQ . timer_list ( counter )) THEN not_found = . FALSE . EXIT END IF END DO END IF IF ( not_found ) THEN timer_position = 0 ELSE timer_position = counter END IF END FUNCTION GetTimerPosition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TimerModule","tags":"","loc":"sourcefile/timermodule.f90.html"},{"title":"LoadBalancerModule.F90 – NTPoly","text":"Contents Modules LoadBalancerModule Source Code LoadBalancerModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for load balancing the matrix multiplication calculation. MODULE LoadBalancerModule USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p USE PSMatrixAlgebraModule , ONLY : MatrixMultiply USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & DestructMatrix , FillMatrixPermutation USE PermutationModule , ONLY : Permutation_t IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: PermuteMatrix PUBLIC :: UndoPermuteMatrix CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Apply a permutation to a matrix. SUBROUTINE PermuteMatrix ( mat , mat_out , permutation , memorypool_in ) !> The matrix to permute. TYPE ( Matrix_ps ), INTENT ( IN ) :: mat !> The permuted matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: mat_out !> The permutation to apply. TYPE ( Permutation_t ), INTENT ( IN ) :: permutation !> Memory pool to use TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ), OPTIONAL :: memorypool_in !! Local Variables TYPE ( Matrix_ps ) :: PermuteRows , PermuteColumns TYPE ( Matrix_ps ) :: Temp !! Build Permutation Matrices CALL ConstructEmptyMatrix ( PermuteRows , mat ) CALL ConstructEmptyMatrix ( PermuteColumns , mat ) CALL FillMatrixPermutation ( PermuteRows , permutation % index_lookup , & & permute_rows_in = . TRUE .) CALL FillMatrixPermutation ( PermuteColumns , permutation % index_lookup , & & permute_rows_in = . FALSE .) CALL ConstructEmptyMatrix ( Temp , mat ) !! Permute Matrices. IF ( PRESENT ( memorypool_in )) THEN CALL MatrixMultiply ( PermuteRows , mat , Temp , & & memory_pool_in = memorypool_in ) CALL MatrixMultiply ( Temp , PermuteColumns , mat_out , & & memory_pool_in = memorypool_in ) ELSE CALL MatrixMultiply ( PermuteRows , mat , Temp ) CALL MatrixMultiply ( Temp , PermuteColumns , mat_out ) END IF CALL DestructMatrix ( PermuteRows ) CALL DestructMatrix ( PermuteColumns ) CALL DestructMatrix ( Temp ) END SUBROUTINE PermuteMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Undo a permutation applied to a matrix. SUBROUTINE UndoPermuteMatrix ( mat , mat_out , permutation , memorypool_in ) !> Matrix to undo permutation of. TYPE ( Matrix_ps ), INTENT ( IN ) :: mat !> Unpermuted matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: mat_out !> Permutation to remove. TYPE ( Permutation_t ), INTENT ( IN ) :: permutation !> Memory pool to use. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ), OPTIONAL :: memorypool_in !! Local Variables TYPE ( Matrix_ps ) :: PermuteRows , PermuteColumns TYPE ( Matrix_ps ) :: Temp !! Build Permutation Matrices CALL ConstructEmptyMatrix ( PermuteRows , mat ) CALL ConstructEmptyMatrix ( PermuteColumns , mat ) CALL FillMatrixPermutation ( PermuteRows , permutation % index_lookup , & & permute_rows_in = . TRUE .) CALL FillMatrixPermutation ( PermuteColumns , permutation % index_lookup , & & permute_rows_in = . FALSE .) CALL ConstructEmptyMatrix ( Temp , mat ) !! Permute Matrices. IF ( PRESENT ( memorypool_in )) THEN CALL MatrixMultiply ( PermuteColumns , mat , Temp , & & memory_pool_in = memorypool_in ) CALL MatrixMultiply ( Temp , PermuteRows , mat_out , & & memory_pool_in = memorypool_in ) ELSE CALL MatrixMultiply ( PermuteColumns , mat , Temp ) CALL MatrixMultiply ( Temp , PermuteRows , mat_out ) END IF !! Cleanup CALL DestructMatrix ( PermuteRows ) CALL DestructMatrix ( PermuteColumns ) CALL DestructMatrix ( Temp ) END SUBROUTINE UndoPermuteMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LoadBalancerModule","tags":"","loc":"sourcefile/loadbalancermodule.f90.html"},{"title":"GemmTasksModule.F90 – NTPoly","text":"Contents Modules GemmTasksModule Source Code GemmTasksModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module contains some enumerators which name the tasks for Gemm. MODULE GemmTasksModule IMPLICIT NONE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress ENUMERATOR :: TaskRunningA !> First we gather the blocks of A and send the size. ENUMERATOR :: LocalGatherA !> After the local gather, we then send the size to the other tasks. ENUMERATOR :: SendSizeA !> Next we compose those blocks of A into one big send buffer and send. ENUMERATOR :: ComposeA !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterA !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerA !> Wait for the data values to be gathered, ENUMERATOR :: WaitDataA !> Need to adjusts indices, transpose the values of A. ENUMERATOR :: AdjustIndicesA !> Just waiting on that last task. ENUMERATOR :: CleanupA !> No more work to do. ENUMERATOR :: FinishedA END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress ENUMERATOR :: TaskRunningB !> First we gather the blocks of B and send the size. ENUMERATOR :: LocalGatherB !> Next we compose those blocks of B into one big send buffer and send. ENUMERATOR :: LocalComposeB !> After the local gather, we then send the size to the other tasks. ENUMERATOR :: SendSizeB !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterB !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerB !> Wait for the data values to be gathered, and then adjusts the indices. ENUMERATOR :: WaitDataB !> Need to adjusts indices of B. ENUMERATOR :: AdjustIndicesB !> Just waiting on that last task. ENUMERATOR :: CleanupB !> No more work to do. ENUMERATOR :: FinishedB END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress. ENUMERATOR :: TaskRunningAB !> A and B matrix both missing, so it can't do gemm. ENUMERATOR :: AwaitingAB !> Actually call gemm and compute a block, and send its size. ENUMERATOR :: GemmAB !> After the local Gemm, we then send the size to the other tasks. ENUMERATOR :: SendSizeAB !> Start sending the data for summing. ENUMERATOR :: GatherAndSumAB !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterAB !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerAB !> Wait for the data values to be gathered. Once receive, we increment. ENUMERATOR :: WaitDataAB !> Sum up the gathered matrices. ENUMERATOR :: LocalSumAB !> Just waiting on that last task. ENUMERATOR :: CleanupAB !> No more work to do. enumerator :: FinishedAB END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE GemmTasksModule","tags":"","loc":"sourcefile/gemmtasksmodule.f90.html"},{"title":"MatrixMemoryPoolModule.F90 – NTPoly","text":"Contents Modules MatrixMemoryPoolModule Source Code MatrixMemoryPoolModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling scratch memory for matrix multiplication. !> The purpose of this module is to avoid having to allocate memory on the !> heap during a matrix multiply, and to manage the underlying hash table. MODULE MatrixMemoryPoolModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE TripletModule , ONLY : Triplet_r , Triplet_c USE , INTRINSIC :: ISO_C_BINDING , ONLY : c_int IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_lr PRIVATE !> Shape of matrix: columns INTEGER , PUBLIC :: columns !> Shape of matrix: rows INTEGER , PUBLIC :: rows !> storage for actual values added to the matrix. TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE , PUBLIC :: pruned_list !> storage for potential values added to the matrix. REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: value_array !> true if an element has been pushed to this part of the matrix. LOGICAL , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: dirty_array !> Storage space for indices, hashed. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: hash_index !> Internal storage space for amount of items added to a bucket. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: inserted_per_bucket !> Size of the buckets. INTEGER , PUBLIC :: hash_size END TYPE MatrixMemoryPool_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_lc PRIVATE !> Shape of matrix: columns INTEGER , PUBLIC :: columns !> Shape of matrix: rows INTEGER , PUBLIC :: rows !> storage for actual values added to the matrix. TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE , PUBLIC :: pruned_list !> storage for potential values added to the matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: value_array !> true if an element has been pushed to this part of the matrix. LOGICAL , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: dirty_array !> Storage space for indices, hashed. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: hash_index !> Internal storage space for amount of items added to a bucket. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: inserted_per_bucket !> Size of the buckets. INTEGER , PUBLIC :: hash_size END TYPE MatrixMemoryPool_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructMatrixMemoryPool PUBLIC :: DestructMatrixMemoryPool PUBLIC :: CheckMemoryPoolValidity PUBLIC :: SetPoolSparsity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MatrixMemoryPool_lr MODULE PROCEDURE ConstructMatrixMemoryPool_lr END INTERFACE INTERFACE MatrixMemoryPool_lc MODULE PROCEDURE ConstructMatrixMemoryPool_lc END INTERFACE INTERFACE ConstructMatrixMemoryPool MODULE PROCEDURE ConstructMatrixMemoryPoolSub_lr MODULE PROCEDURE ConstructMatrixMemoryPoolSub_lc END INTERFACE INTERFACE DestructMatrixMemoryPool MODULE PROCEDURE DestructMatrixMemoryPool_lr MODULE PROCEDURE DestructMatrixMemoryPool_lc END INTERFACE INTERFACE CheckMemoryPoolValidity MODULE PROCEDURE CheckMemoryPoolValidity_lr MODULE PROCEDURE CheckMemoryPoolValidity_lc END INTERFACE INTERFACE SetPoolSparsity MODULE PROCEDURE SetPoolSparsity_lr MODULE PROCEDURE SetPoolSparsity_lc END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the constructor. SUBROUTINE ConstructMatrixMemoryPoolSub_lr ( this , columns , rows , sparsity_in ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lr ), TARGET :: this !> Number of columns in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in IF ( PRESENT ( sparsity_in )) THEN this = MatrixMemoryPool_lr ( columns , rows , sparsity_in ) ELSE this = MatrixMemoryPool_lr ( columns , rows ) END IF END SUBROUTINE ConstructMatrixMemoryPoolSub_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the constructor. SUBROUTINE ConstructMatrixMemoryPoolSub_lc ( this , columns , rows , sparsity_in ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lc ), TARGET :: this !> Number of columns in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in IF ( PRESENT ( sparsity_in )) THEN this = MatrixMemoryPool_lc ( columns , rows , sparsity_in ) ELSE this = MatrixMemoryPool_lc ( columns , rows ) END IF END SUBROUTINE ConstructMatrixMemoryPoolSub_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct Matrix Memory Pool object. FUNCTION ConstructMatrixMemoryPool_lr ( columns , rows , sparsity_in ) RESULT ( this ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lr ), TARGET :: this !> Number of columns in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in INCLUDE \"dense_includes/ConstructMatrixMemoryPool.f90\" END FUNCTION ConstructMatrixMemoryPool_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct Matrix Memory Pool object. FUNCTION ConstructMatrixMemoryPool_lc ( columns , rows , sparsity_in ) RESULT ( this ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lc ), TARGET :: this !> Number of columns in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER ( kind = c_int ), INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in INCLUDE \"dense_includes/ConstructMatrixMemoryPool.f90\" END FUNCTION ConstructMatrixMemoryPool_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A destructor for a matrix memory pool PURE SUBROUTINE DestructMatrixMemoryPool_lr ( this ) !> The matrix being destructed. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: this INCLUDE \"dense_includes/DestructMatrixMemoryPool.f90\" END SUBROUTINE DestructMatrixMemoryPool_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A destructor for a matrix memory pool PURE SUBROUTINE DestructMatrixMemoryPool_lc ( this ) !> The matrix being destructed. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: this INCLUDE \"dense_includes/DestructMatrixMemoryPool.f90\" END SUBROUTINE DestructMatrixMemoryPool_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given memory pool has been validly allocated to handle !> the given parameters. PURE FUNCTION CheckMemoryPoolValidity_lr ( this , columns , rows ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_lr ), INTENT ( in ) :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> true if the memory pool is valid. LOGICAL :: isvalid INCLUDE \"dense_includes/CheckMemoryPoolValidity.f90\" END FUNCTION CheckMemoryPoolValidity_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given memory pool has been validly allocated to handle !> Checks if a given memory pool has been validly allocated to handle !> the given parameters. PURE FUNCTION CheckMemoryPoolValidity_lc ( this , columns , rows ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_lc ), INTENT ( in ) :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> true if the memory pool is valid. LOGICAL :: isvalid INCLUDE \"dense_includes/CheckMemoryPoolValidity.f90\" END FUNCTION CheckMemoryPoolValidity_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sets the expected sparsity of the matrix, which helps with hashing. SUBROUTINE SetPoolSparsity_lr ( this , sparsity ) !> The memory pool to set the sparsity of. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ), TARGET :: this !> The sparsity value. REAL ( NTREAL ), INTENT ( IN ) :: sparsity INCLUDE \"dense_includes/SetPoolSparsity.f90\" END SUBROUTINE SetPoolSparsity_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sets the expected sparsity of the matrix, which helps with hashing. SUBROUTINE SetPoolSparsity_lc ( this , sparsity ) !> The memory pool to set the sparsity of. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ), TARGET :: this !> The sparsity value. REAL ( NTREAL ), INTENT ( IN ) :: sparsity INCLUDE \"dense_includes/SetPoolSparsity.f90\" END SUBROUTINE SetPoolSparsity_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMemoryPoolModule","tags":"","loc":"sourcefile/matrixmemorypoolmodule.f90.html"},{"title":"DensityMatrixSolversModule.F90 – NTPoly","text":"Contents Modules DensityMatrixSolversModule Source Code DensityMatrixSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Solving Quantum Chemistry Systems using Purification. MODULE DensityMatrixSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : WriteElement , WriteListElement , WriteHeader , & & WriteCitation , EnterSubLog , ExitSubLog USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & DotMatrix , MatrixTrace , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , DestructMatrix , & & CopyMatrix , PrintMatrixInformation , FillMatrixIdentity USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: PM PUBLIC :: TRS2 PUBLIC :: TRS4 PUBLIC :: HPCP PUBLIC :: EnergyDensityMatrix ! PUBLIC :: HPCPPlus CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the PM method. !! Based on the PM algorithm presented in \\cite palser1998canonical SUBROUTINE PM ( Hamiltonian , InverseSquareRoot , nel , Density , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InverseSquareRoot !> The number of electrons. INTEGER , INTENT ( IN ) :: nel !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Density !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingHamiltonian TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: X_k , X_k2 , X_k3 , TempMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: factor REAL ( NTREAL ) :: lambda , alpha , alpha1 , alpha2 REAL ( NTREAL ) :: a1 , a2 , a3 REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: trace_value2 REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value2 !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: outer_counter , inner_counter INTEGER :: total_iterations !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"PM\" ) CALL WriteCitation ( \"palser1998canonical\" ) CALL PrintParameters ( solver_parameters ) END IF ALLOCATE ( sigma_array ( solver_parameters % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Density , Hamiltonian ) CALL ConstructEmptyMatrix ( WorkingHamiltonian , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k2 , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k3 , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) CALL ConstructEmptyMatrix ( Identity , Hamiltonian ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL MatrixMultiply ( InverseSquareRoot , Hamiltonian , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , WorkingHamiltonian , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingHamiltonian , WorkingHamiltonian , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WorkingHamiltonian , e_min , e_max ) !! Initialize CALL CopyMatrix ( WorkingHamiltonian , X_k ) !! Compute lambda CALL MatrixTrace ( X_k , trace_value ) lambda = trace_value / X_k % actual_matrix_dimension !! Compute alpha alpha1 = nel * 0.5_NTREAL / ( e_max - lambda ) alpha2 = ( X_k % actual_matrix_dimension - nel * 0.5_NTREAL ) / ( lambda - e_min ) alpha = MIN ( alpha1 , alpha2 ) factor = - alpha / X_k % actual_matrix_dimension CALL ScaleMatrix ( X_k , factor ) factor = ( alpha * lambda + nel * 0.5_NTREAL ) / X_k % actual_matrix_dimension CALL IncrementMatrix ( Identity , X_k , alpha_in = factor ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) !! Compute X_k3 CALL MatrixMultiply ( X_k , X_k2 , X_k3 , & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) !! Compute X_k - X_k2 CALL CopyMatrix ( X_k , TempMat ) CALL IncrementMatrix ( X_k2 , TempMat , & & alpha_in =- 1.0_NTREAL , & & threshold_in = solver_parameters % threshold ) !! Compute Sigma CALL MatrixTrace ( TempMat , trace_value ) CALL DotMatrix ( TempMat , X_k , trace_value2 ) sigma_array ( outer_counter ) = trace_value2 / trace_value IF ( sigma_array ( outer_counter ) . GT . 0.5_NTREAL ) THEN a1 = 0.0_NTREAL a2 = 1.0_NTREAL + 1.0_NTREAL / sigma_array ( outer_counter ) a3 = - 1.0_NTREAL / sigma_array ( outer_counter ) ELSE a1 = ( 1.0_NTREAL - 2.0_NTREAL * sigma_array ( outer_counter )) & & / ( 1.0_NTREAL - sigma_array ( outer_counter )) a2 = ( 1.0_NTREAL + sigma_array ( outer_counter )) & & / ( 1.0_NTREAL - sigma_array ( outer_counter )) a3 = - 1.0_NTREAL / ( 1.0_NTREAL - sigma_array ( outer_counter )) END IF !! Update X_k CALL ScaleMatrix ( X_k , a1 ) CALL IncrementMatrix ( X_k2 , X_k , & & alpha_in = a2 , & & threshold_in = solver_parameters % threshold ) CALL IncrementMatrix ( X_k3 , X_k , & & alpha_in = a3 , & & threshold_in = solver_parameters % threshold ) !! Energy value based convergence energy_value2 = energy_value CALL DotMatrix ( X_k , WorkingHamiltonian , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value2 ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( \"Energy_Value\" , value = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( InverseSquareRoot , X_k , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , Density , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( WorkingHamiltonian ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( X_k3 ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO outer_counter = 1 , solver_parameters % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO inner_counter = 1 , total_iterations IF ( sigma_array ( inner_counter ) . GT . 0.5_NTREAL ) THEN zero_value = (( 1.0_NTREAL + sigma_array ( inner_counter )) & & * zero_value ** 2 ) - ( zero_value ** 3 ) zero_value = zero_value / sigma_array ( inner_counter ) ELSE zero_value = (( 1.0_NTREAL - 2.0_NTREAL * & & sigma_array ( inner_counter )) * zero_value ) & & + (( 1.0_NTREAL + sigma_array ( inner_counter )) * & & zero_value ** 2 ) - ( zero_value ** 3 ) zero_value = zero_value / ( 1.0_NTREAL - sigma_array ( inner_counter )) END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . & & solver_parameters % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = lambda - & & ( Hamiltonian % actual_matrix_dimension * midpoint - nel * 0.5_NTREAL ) / alpha END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE PM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the TRS2 method. !! Based on the TRS2 algorithm presented in \\cite niklasson2002. SUBROUTINE TRS2 ( Hamiltonian , InverseSquareRoot , nel , Density , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InverseSquareRoot !> The number of electrons. INTEGER , INTENT ( IN ) :: nel !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Density !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingHamiltonian TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: X_k , X_k2 , TempMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value2 !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: outer_counter , inner_counter INTEGER :: total_iterations !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"TRS2\" ) CALL WriteCitation ( \"niklasson2002expansion\" ) CALL PrintParameters ( solver_parameters ) END IF ALLOCATE ( sigma_array ( solver_parameters % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Density , Hamiltonian ) CALL ConstructEmptyMatrix ( WorkingHamiltonian , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k2 , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) CALL ConstructEmptyMatrix ( Identity , Hamiltonian ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL MatrixMultiply ( InverseSquareRoot , Hamiltonian , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , WorkingHamiltonian , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingHamiltonian , WorkingHamiltonian , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WorkingHamiltonian , e_min , e_max ) !! Initialize CALL CopyMatrix ( WorkingHamiltonian , X_k ) CALL ScaleMatrix ( X_k , - 1.0_NTREAL ) CALL IncrementMatrix ( Identity , X_k , alpha_in = e_max ) CALL ScaleMatrix ( X_k , 1.0_NTREAL / ( e_max - e_min )) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute Sigma CALL MatrixTrace ( X_k , trace_value ) IF ( nel * 0.5_NTREAL - trace_value . LT . 0.0_NTREAL ) THEN sigma_array ( outer_counter ) = - 1.0_NTREAL ELSE sigma_array ( outer_counter ) = 1.0_NTREAL END IF !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) !! Update X_k IF ( sigma_array ( outer_counter ) . GT . 0.0_NTREAL ) THEN CALL ScaleMatrix ( X_k , 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , X_k , & & alpha_in =- 1.0_NTREAL , & & threshold_in = solver_parameters % threshold ) ELSE CALL CopyMatrix ( X_k2 , X_k ) END IF !! Energy value based convergence energy_value2 = energy_value CALL DotMatrix ( X_k , WorkingHamiltonian , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value2 ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( \"Energy_Value\" , value = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( InverseSquareRoot , X_k , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , Density , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( WorkingHamiltonian ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO outer_counter = 1 , solver_parameters % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO inner_counter = 1 , total_iterations IF ( sigma_array ( inner_counter ) . LT . 0.0_NTREAL ) THEN zero_value = zero_value * zero_value ELSE zero_value = 2.0_NTREAL * zero_value - zero_value * zero_value END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . & & solver_parameters % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = e_max + ( e_min - e_max ) * midpoint END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE TRS2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the TRS4 method. !! Based on the TRS4 algorithm presented in \\cite niklasson2002 SUBROUTINE TRS4 ( Hamiltonian , InverseSquareRoot , nel , Density , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InverseSquareRoot !> The number of electrons. INTEGER , INTENT ( IN ) :: nel !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Density !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in REAL ( NTREAL ), PARAMETER :: sigma_min = 0.0_NTREAL REAL ( NTREAL ), PARAMETER :: sigma_max = 6.0_NTREAL !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingHamiltonian TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: X_k , X_k2 , Fx_right , GX_right , TempMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value2 !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b REAL ( NTREAL ) :: tempfx , tempgx !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: outer_counter , inner_counter INTEGER :: total_iterations REAL ( NTREAL ) :: trace_fx , trace_gx !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"TRS4\" ) CALL WriteCitation ( \"niklasson2002expansion\" ) CALL PrintParameters ( solver_parameters ) END IF ALLOCATE ( sigma_array ( solver_parameters % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Density , Hamiltonian ) CALL ConstructEmptyMatrix ( WorkingHamiltonian , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k , Hamiltonian ) CALL ConstructEmptyMatrix ( X_k2 , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) CALL ConstructEmptyMatrix ( Fx_right , Hamiltonian ) CALL ConstructEmptyMatrix ( Gx_right , Hamiltonian ) CALL ConstructEmptyMatrix ( Identity , Hamiltonian ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL MatrixMultiply ( InverseSquareRoot , Hamiltonian , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , WorkingHamiltonian , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingHamiltonian , WorkingHamiltonian , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WorkingHamiltonian , e_min , e_max ) !! Initialize CALL CopyMatrix ( WorkingHamiltonian , X_k ) CALL ScaleMatrix ( X_k , - 1.0_NTREAL ) CALL IncrementMatrix ( Identity , X_k , alpha_in = e_max ) CALL ScaleMatrix ( X_k , 1.0_NTREAL / ( e_max - e_min )) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Compute Fx_right CALL CopyMatrix ( X_k2 , Fx_right ) CALL ScaleMatrix ( Fx_right , - 3.0_NTREAL ) CALL IncrementMatrix ( X_k , Fx_right , alpha_in = 4.0_NTREAL ) !! Compute Gx_right CALL CopyMatrix ( Identity , Gx_right ) CALL IncrementMatrix ( X_k , Gx_right , alpha_in =- 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , Gx_right ) !! Compute Traces CALL DotMatrix ( X_k2 , Fx_right , trace_fx ) CALL DotMatrix ( X_k2 , Gx_right , trace_gx ) !! Avoid Overflow IF ( ABS ( trace_gx ) . LT . 1.0e-14_NTREAL ) THEN EXIT END IF !! Compute Sigma sigma_array ( outer_counter ) = ( nel * 0.5_NTREAL - trace_fx ) / trace_gx !! Update The Matrix IF ( sigma_array ( outer_counter ) . GT . sigma_max ) THEN CALL CopyMatrix ( X_k , TempMat ) CALL ScaleMatrix ( TempMat , 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , TempMat , alpha_in =- 1.0_NTREAL ) ELSE IF ( sigma_array ( outer_counter ) . LT . sigma_min ) THEN CALL CopyMatrix ( X_k2 , TempMat ) ELSE CALL ScaleMatrix ( Gx_right , sigma_array ( outer_counter )) CALL IncrementMatrix ( Fx_right , Gx_right ) CALL MatrixMultiply ( X_k2 , Gx_right , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) END IF CALL IncrementMatrix ( TempMat , X_k , alpha_in =- 1.0_NTREAL ) CALL CopyMatrix ( TempMat , X_k ) !! Energy value based convergence energy_value2 = energy_value CALL DotMatrix ( X_k , WorkingHamiltonian , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value2 ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( \"Energy_Value\" , value = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( InverseSquareRoot , X_k , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , Density , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( WorkingHamiltonian ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( Fx_right ) CALL DestructMatrix ( Gx_right ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO outer_counter = 1 , solver_parameters % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO inner_counter = 1 , total_iterations IF ( sigma_array ( inner_counter ) . GT . sigma_max ) THEN zero_value = 2.0_NTREAL * zero_value - zero_value * zero_value ELSE IF ( sigma_array ( inner_counter ) . LT . sigma_min ) THEN zero_value = zero_value * zero_value ELSE tempfx = ( zero_value * zero_value ) * & & ( 4.0_NTREAL * zero_value - & & 3.0_NTREAL * zero_value * zero_value ) tempgx = ( zero_value * zero_value ) * ( 1.0_NTREAL - zero_value ) & & * ( 1.0_NTREAL - zero_value ) zero_value = tempfx + sigma_array ( inner_counter ) * tempgx END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . & & solver_parameters % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = e_max + ( e_min - e_max ) * midpoint END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE TRS4 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the HPCP method. !! Based on the algorithm presented in \\cite truflandier2016communication. SUBROUTINE HPCP ( Hamiltonian , InverseSquareRoot , nel , Density , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InverseSquareRoot !> The number of electrons. INTEGER , INTENT ( IN ) :: nel !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Density !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingHamiltonian TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: D1 , DH , DDH , D2DH !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: beta_1 , beta_2 REAL ( NTREAL ) :: beta , beta_bar REAL ( NTREAL ) :: sigma , sigma_bar REAL ( NTREAL ) :: mu REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value , norm_value2 REAL ( NTREAL ) :: energy_value , energy_value2 !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: outer_counter , inner_counter INTEGER :: total_iterations INTEGER :: matrix_dimension !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"HPCP\" ) CALL WriteCitation ( \"truflandier2016communication\" ) CALL PrintParameters ( solver_parameters ) END IF ALLOCATE ( sigma_array ( solver_parameters % max_iterations )) matrix_dimension = Hamiltonian % actual_matrix_dimension !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Density , Hamiltonian ) CALL ConstructEmptyMatrix ( WorkingHamiltonian , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) CALL ConstructEmptyMatrix ( D1 , Hamiltonian ) CALL ConstructEmptyMatrix ( DH , Hamiltonian ) CALL ConstructEmptyMatrix ( DDH , Hamiltonian ) CALL ConstructEmptyMatrix ( D2DH , Hamiltonian ) CALL ConstructEmptyMatrix ( Identity , Hamiltonian ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL MatrixMultiply ( InverseSquareRoot , Hamiltonian , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , WorkingHamiltonian , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingHamiltonian , WorkingHamiltonian , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the initial matrix. CALL GershgorinBounds ( WorkingHamiltonian , e_min , e_max ) CALL MatrixTrace ( WorkingHamiltonian , mu ) mu = mu / matrix_dimension sigma_bar = ( matrix_dimension - 0.5_NTREAL * nel ) / matrix_dimension sigma = 1.0_NTREAL - sigma_bar beta = sigma / ( e_max - mu ) beta_bar = sigma_bar / ( mu - e_min ) beta_1 = sigma beta_2 = MIN ( beta , beta_bar ) !! Initialize CALL CopyMatrix ( Identity , D1 ) CALL ScaleMatrix ( D1 , beta_1 ) CALL CopyMatrix ( Identity , TempMat ) CALL ScaleMatrix ( TempMat , mu ) CALL IncrementMatrix ( WorkingHamiltonian , TempMat , - 1.0_NTREAL ) CALL ScaleMatrix ( TempMat , beta_2 ) CALL IncrementMatrix ( TempMat , D1 ) trace_value = 0.0_NTREAL !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL norm_value2 = norm_value energy_value = 0.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute the hole matrix DH CALL CopyMatrix ( D1 , DH ) CALL IncrementMatrix ( Identity , DH , alpha_in =- 1.0_NTREAL ) CALL ScaleMatrix ( DH , - 1.0_NTREAL ) !! Compute DDH, as well as convergence check CALL MatrixMultiply ( D1 , DH , DDH , threshold_in = solver_parameters % threshold ,& & memory_pool_in = pool ) CALL MatrixTrace ( DDH , trace_value ) norm_value = ABS ( trace_value ) !! Compute D2DH CALL MatrixMultiply ( D1 , DDH , D2DH , & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) !! Compute Sigma CALL MatrixTrace ( D2DH , sigma_array ( outer_counter )) sigma_array ( outer_counter ) = sigma_array ( outer_counter ) / trace_value CALL CopyMatrix ( D1 , TempMat ) !! Compute D1 + 2*D2DH CALL IncrementMatrix ( D2DH , D1 , alpha_in = 2.0_NTREAL ) !! Compute D1 + 2*D2DH -2*Sigma*DDH CALL IncrementMatrix ( DDH , D1 , & & alpha_in =- 1.0_NTREAL * 2.0_NTREAL * sigma_array ( outer_counter )) !! Energy value based convergence energy_value2 = energy_value CALL DotMatrix ( D1 , WorkingHamiltonian , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value2 ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( \"Energy_Value\" , value = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( D1 ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( D1 , D1 , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( InverseSquareRoot , D1 , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , Density , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( WorkingHamiltonian ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( D1 ) CALL DestructMatrix ( DH ) CALL DestructMatrix ( DDH ) CALL DestructMatrix ( D2DH ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO outer_counter = 1 , solver_parameters % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO inner_counter = 1 , total_iterations zero_value = zero_value + & & 2.0_NTREAL * (( zero_value ** 2 ) * ( 1.0_NTREAL - zero_value ) & & - sigma_array ( inner_counter ) * & & zero_value * ( 1.0_NTREAL - zero_value )) END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . & & solver_parameters % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = mu + ( beta_1 - midpoint ) / beta_2 END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE HPCP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the HPCP+ method. !! Based on the algorithm presented in \\cite truflandier2016communication !! @param[in] Hamiltonian the matrix to compute the corresponding density from. !! @param[in] InverseSquareRoot of the overlap matrix. !! @param[in] nel the number of electrons. !! @param[out] Density the density matrix computed by this routine. !! @param[out] energy_value_out the energy of the system (optional). !! @param[out] chemical_potential_out the chemical potential (optional). !! @param[in] solver_parameters_in parameters for the solver (optional). SUBROUTINE HPCPPlus ( Hamiltonian , InverseSquareRoot , nel , Density , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !! Parameters TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian TYPE ( Matrix_ps ), INTENT ( IN ) :: InverseSquareRoot INTEGER , INTENT ( IN ) :: nel TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Density REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: & & solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingHamiltonian TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: D1 , DH , DDH , D2DH !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: beta_1 , beta_2 REAL ( NTREAL ) :: beta_1_h , beta_2_h REAL ( NTREAL ) :: a , b , c , d REAL ( NTREAL ) :: one_third REAL ( NTREAL ) :: mixing_interior , mixing_value REAL ( NTREAL ) :: beta , beta_bar REAL ( NTREAL ) :: sigma , sigma_bar REAL ( NTREAL ) :: mu REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value2 !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: outer_counter , inner_counter INTEGER :: total_iterations INTEGER :: matrix_dimension !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"HPCP+\" ) CALL WriteCitation ( \"truflandier2016communication\" ) CALL PrintParameters ( solver_parameters ) END IF ALLOCATE ( sigma_array ( solver_parameters % max_iterations )) matrix_dimension = Hamiltonian % actual_matrix_dimension !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Density , Hamiltonian ) CALL ConstructEmptyMatrix ( WorkingHamiltonian , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) CALL ConstructEmptyMatrix ( D1 , Hamiltonian ) CALL ConstructEmptyMatrix ( DH , Hamiltonian ) CALL ConstructEmptyMatrix ( DDH , Hamiltonian ) CALL ConstructEmptyMatrix ( D2DH , Hamiltonian ) CALL ConstructEmptyMatrix ( Identity , Hamiltonian ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL MatrixMultiply ( InverseSquareRoot , Hamiltonian , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , WorkingHamiltonian , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingHamiltonian , WorkingHamiltonian , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the initial matrix. CALL GershgorinBounds ( WorkingHamiltonian , e_min , e_max ) CALL MatrixTrace ( WorkingHamiltonian , mu ) mu = mu / matrix_dimension sigma_bar = ( matrix_dimension - 0.5_NTREAL * nel ) / matrix_dimension sigma = 1.0_NTREAL - sigma_bar beta = sigma / (( e_max ) - mu ) beta_bar = sigma_bar / ( mu - ( e_min )) beta_1 = sigma beta_1_h = sigma_bar beta_2 = MIN ( beta , beta_bar ) beta_2_h = - 1.0_NTREAL * MAX ( beta , beta_bar ) !! Initialize CALL CopyMatrix ( Identity , D1 ) CALL ScaleMatrix ( D1 , beta_1 ) CALL CopyMatrix ( Identity , TempMat ) CALL ScaleMatrix ( TempMat , mu ) CALL IncrementMatrix ( WorkingHamiltonian , TempMat , & & - 1.0_NTREAL ) CALL ScaleMatrix ( TempMat , beta_2 ) CALL IncrementMatrix ( TempMat , D1 ) CALL CopyMatrix ( Identity , DH ) CALL ScaleMatrix ( DH , beta_1_h ) CALL CopyMatrix ( Identity , TempMat ) CALL ScaleMatrix ( TempMat , mu ) CALL IncrementMatrix ( WorkingHamiltonian , TempMat , - 1.0_NTREAL ) CALL ScaleMatrix ( TempMat , beta_2_h ) CALL IncrementMatrix ( TempMat , DH ) CALL CopyMatrix ( Identity , TempMat ) CALL IncrementMatrix ( DH , TempMat , - 1.0_NTREAL ) CALL DotMatrix ( D1 , D1 , a ) CALL DotMatrix ( TempMat , TempMat , b ) CALL DotMatrix ( D1 , TempMat , c ) one_third = 1.0_NTREAL / 3.0_NTREAL IF ( sigma < one_third ) THEN d = ( nel * 0.5_NTREAL ) - 2.0_NTREAL * one_third * ( nel * 0.5_NTREAL ) ELSE d = ( nel * 0.5_NTREAL ) - & & 2.0_NTREAL * one_third * ( matrix_dimension - nel * 0.5_NTREAL ) END IF mixing_interior = SQRT (( 2.0_NTREAL * c - 2.0_NTREAL * b ) ** 2 & & - 4.0_NTREAL * ( a + b - 2.0_NTREAL * c ) * ( b - d )) mixing_value = (( 2.0_NTREAL * b - 2.0_NTREAL * c ) + mixing_interior ) & & / ( 2.0_NTREAL * ( a + b - 2.0_NTREAL * c )) IF (. NOT . mixing_value . LE . 1.0_NTREAL & & . AND . mixing_value . GE . 0.0_NTREAL ) THEN mixing_value = (( 2.0_NTREAL * b - 2.0_NTREAL * c ) - mixing_interior ) & & / ( 2.0_NTREAL * ( a + b - 2.0_NTREAL * c )) ENDIF CALL ScaleMatrix ( D1 , mixing_value ) CALL CopyMatrix ( Identity , TempMat ) CALL IncrementMatrix ( DH , TempMat , - 1.0_NTREAL ) CALL IncrementMatrix ( TempMat , D1 , 1.0_NTREAL - mixing_value ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute the hole matrix DH CALL CopyMatrix ( D1 , DH ) CALL IncrementMatrix ( Identity , DH , alpha_in =- 1.0_NTREAL ) CALL ScaleMatrix ( DH , - 1.0_NTREAL ) !! Compute DDH, as well as convergence check CALL MatrixMultiply ( D1 , DH , DDH , threshold_in = solver_parameters % threshold ,& & memory_pool_in = pool ) CALL MatrixTrace ( DDH , trace_value ) norm_value = ABS ( trace_value ) !! Compute D2DH CALL MatrixMultiply ( D1 , DDH , D2DH , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Compute Sigma CALL MatrixTrace ( D2DH , sigma_array ( outer_counter )) sigma_array ( outer_counter ) = sigma_array ( outer_counter ) / trace_value CALL CopyMatrix ( D1 , TempMat ) !! Compute D1 + 2*D2DH CALL IncrementMatrix ( D2DH , D1 , alpha_in = 2.0_NTREAL ) !! Compute D1 + 2*D2DH -2*Sigma*DDH CALL IncrementMatrix ( DDH , D1 , & & alpha_in =- 1.0_NTREAL * 2.0_NTREAL * sigma_array ( outer_counter )) !! Energy value based convergence energy_value2 = energy_value CALL DotMatrix ( D1 , WorkingHamiltonian , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value2 ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( \"Energy_Value\" , value = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( D1 ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( D1 , D1 , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( InverseSquareRoot , D1 , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , InverseSquareRoot , Density , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( WorkingHamiltonian ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( D1 ) CALL DestructMatrix ( DH ) CALL DestructMatrix ( DDH ) CALL DestructMatrix ( D2DH ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO outer_counter = 1 , solver_parameters % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO inner_counter = 1 , total_iterations zero_value = zero_value + & & 2.0_NTREAL * (( zero_value * zero_value ) * ( 1.0_NTREAL - zero_value )& & - sigma_array ( inner_counter ) * & & ( zero_value * ( 1.0_NTREAL - zero_value ))) END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . & & solver_parameters % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = mu + ( beta_1 - midpoint ) / beta_2 END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE HPCPPlus !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the energy-weighted density matrix. SUBROUTINE EnergyDensityMatrix ( Hamiltonian , Density , EnergyDensity , & & threshold_in ) !> The matrix to compute from. TYPE ( Matrix_ps ), INTENT ( IN ) :: Hamiltonian !> The density matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: Density !> The energy-weighted density matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: EnergyDensity !> Threshold for flushing small values (default = 0). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Handling Optional Parameters REAL ( NTREAL ) :: threshold !! Local Matrices TYPE ( Matrix_ps ) :: TempMat !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( threshold_in )) THEN threshold = threshold_in ELSE threshold = 0.0_NTREAL END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( EnergyDensity , Hamiltonian ) CALL ConstructEmptyMatrix ( TempMat , Hamiltonian ) !! EDM = DM * H * DM CALL MatrixMultiply ( Density , Hamiltonian , TempMat , & & threshold_in = threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , Density , EnergyDensity , & & threshold_in = threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( TempMat ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE EnergyDensityMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DensityMatrixSolversModule","tags":"","loc":"sourcefile/densitymatrixsolversmodule.f90.html"},{"title":"MatrixReduceModule.F90 – NTPoly","text":"Contents Modules MatrixReduceModule Source Code MatrixReduceModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for reducing matrices across processes. MODULE MatrixReduceModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , MPINTCOMPLEX , MPINTINTEGER USE SMatrixAlgebraModule , ONLY : IncrementMatrix USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , ConstructEmptyMatrix , & & DestructMatrix , CopyMatrix USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data structure to stores internal information about a reduce call. TYPE , PUBLIC :: ReduceHelper_t !> Number of processors involved in this gather. INTEGER :: comm_size !> A request object for gathering outer indices. INTEGER :: outer_request !> A request object for gathering inner indices. INTEGER :: inner_request !> A request object for gathering data. INTEGER :: data_request !> The error code after an MPI call. INTEGER :: error_code !> Number of values to gather from each process. INTEGER , DIMENSION (:), ALLOCATABLE :: values_per_process !> The displacements for where those gathered values should go. INTEGER , DIMENSION (:), ALLOCATABLE :: displacement #ifdef NOIALLGATHER !> For mpi backup, a list of request objets for outer indices. INTEGER , DIMENSION (:), ALLOCATABLE :: outer_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: outer_recv_request_list !> For mpi backup, a list of request objects for inner indices. INTEGER , DIMENSION (:), ALLOCATABLE :: inner_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: inner_recv_request_list !> For mpi backup, a list of request object for data. INTEGER , DIMENSION (:), ALLOCATABLE :: data_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: data_recv_request_list #endif END TYPE ReduceHelper_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ReduceAndComposeMatrixSizes PUBLIC :: ReduceAndComposeMatrixData PUBLIC :: ReduceAndComposeMatrixCleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ReduceAndSumMatrixSizes PUBLIC :: ReduceAndSumMatrixData PUBLIC :: ReduceAndSumMatrixCleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: TestReduceSizeRequest PUBLIC :: TestReduceInnerRequest PUBLIC :: TestReduceDataRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ReduceAndComposeMatrixSizes MODULE PROCEDURE ReduceAndComposeMatrixSizes_lsr MODULE PROCEDURE ReduceAndComposeMatrixSizes_lsc END INTERFACE INTERFACE ReduceAndComposeMatrixData MODULE PROCEDURE ReduceAndComposeMatrixData_lsr MODULE PROCEDURE ReduceAndComposeMatrixData_lsc END INTERFACE INTERFACE ReduceAndComposeMatrixCleanup MODULE PROCEDURE ReduceAndComposeMatrixCleanup_lsr MODULE PROCEDURE ReduceAndComposeMatrixCleanup_lsc END INTERFACE INTERFACE ReduceAndSumMatrixSizes MODULE PROCEDURE ReduceAndSumMatrixSizes_lsr MODULE PROCEDURE ReduceAndSumMatrixSizes_lsc END INTERFACE INTERFACE ReduceAndSumMatrixData MODULE PROCEDURE ReduceAndSumMatrixData_lsr MODULE PROCEDURE ReduceAndSumMatrixData_lsc END INTERFACE INTERFACE ReduceAndSumMatrixCleanup MODULE PROCEDURE ReduceAndSumMatrixCleanup_lsr MODULE PROCEDURE ReduceAndSumMatrixCleanup_lsc END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndComposeMatrixSizes_lsr ( matrix , communicator , & & gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !> The  helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndComposeMatrixSizes_sendrecv.f90\" #else INCLUDE \"comm_includes/ReduceAndComposeMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndComposeMatrixSizes_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndComposeMatrixSizes_lsc ( matrix , communicator , & & gathered_matrix , helper ) !! The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !! The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !! The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndComposeMatrixSizes_sendrecv.f90\" #else INCLUDE \"comm_includes/ReduceAndComposeMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndComposeMatrixSizes_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second function to call, will gather the data and align it one matrix !! @param[inout] SUBROUTINE ReduceAndComposeMatrixData_lsr ( matrix , communicator , & & gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndComposeMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTREAL , & & II - 1 , 4 , communicator , helper % data_send_request_list ( II ), & & grid_error ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , MPINTREAL , & & II - 1 , 4 , communicator , & & helper % data_recv_request_list ( II ), grid_error ) END DO #else INCLUDE \"comm_includes/ReduceAndComposeMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTREAL ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTREAL , communicator , helper % data_request , & & grid_error ) #endif END SUBROUTINE ReduceAndComposeMatrixData_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second function to call, will gather the data and align it one matrix !! next to another. !! @param[in] matrix to send. !! @param[inout] communicator to send along. !! @param[inout] gathered_matrix the matrix we are gathering. !! @param[inout] helper a helper associated with this gather. SUBROUTINE ReduceAndComposeMatrixData_lsc ( matrix , communicator , & & gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndComposeMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX , & & II - 1 , 4 , communicator , helper % data_send_request_list ( II ), & & grid_error ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , & & MPINTCOMPLEX , II - 1 , 4 , communicator , & & helper % data_recv_request_list ( II ), grid_error ) END DO #else INCLUDE \"comm_includes/ReduceAndComposeMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTCOMPLEX , communicator , & & helper % data_request , grid_error ) #endif END SUBROUTINE ReduceAndComposeMatrixData_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Third function to call, finishes setting up the matrices. PURE SUBROUTINE ReduceAndComposeMatrixCleanup_lsr ( matrix , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper INCLUDE \"comm_includes/ReduceAndComposeMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndComposeMatrixCleanup_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Third function to call, finishes setting up the matrices. PURE SUBROUTINE ReduceAndComposeMatrixCleanup_lsc ( matrix , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper INCLUDE \"comm_includes/ReduceAndComposeMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndComposeMatrixCleanup_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndSumMatrixSizes_lsr ( matrix , communicator , & & gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !> The  helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndSumMatrixSizes_sendrecv.f90\" #else INCLUDE \"comm_includes/ReduceAndSumMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndSumMatrixSizes_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndSumMatrixSizes_lsc ( matrix , communicator , & & gathered_matrix , helper ) !! The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !! The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !! The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndSumMatrixSizes_sendrecv.f90\" #else INCLUDE \"comm_includes/ReduceAndSumMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndSumMatrixSizes_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second routine to call for gathering and summing up the data. SUBROUTINE ReduceAndSumMatrixData_lsr ( matrix , gathered_matrix , communicator , & & helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndSumMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTREAL , & & II - 1 , 4 , communicator , helper % data_send_request_list ( II ), & & grid_error ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , MPINTREAL , & & II - 1 , 4 , communicator , & & helper % data_recv_request_list ( II ), grid_error ) END DO #else INCLUDE \"comm_includes/ReduceAndSumMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTREAL ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTREAL , communicator , helper % data_request , & & grid_error ) #endif END SUBROUTINE ReduceAndSumMatrixData_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second routine to call for gathering and summing up the data. !! @param[in] matrix to send. !! @param[inout] communicator to send along. !! @param[inout] helper a helper associated with this gather. SUBROUTINE ReduceAndSumMatrixData_lsc ( matrix , gathered_matrix , communicator , & & helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: communicator !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER INCLUDE \"comm_includes/ReduceAndSumMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX , & & II - 1 , 4 , communicator , helper % data_send_request_list ( II ), & & grid_error ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , & & MPINTCOMPLEX , II - 1 , 4 , communicator , & & helper % data_recv_request_list ( II ), grid_error ) END DO #else INCLUDE \"comm_includes/ReduceAndSumMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTCOMPLEX , communicator , & & helper % data_request , grid_error ) #endif END SUBROUTINE ReduceAndSumMatrixData_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Finally routine to sum up the matrices. PURE SUBROUTINE ReduceAndSumMatrixCleanup_lsr ( matrix , gathered_matrix , & & threshold , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The gathered_matrix the matrix being gathered. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !! Local Data TYPE ( Matrix_lsr ) :: temporary_matrix , sum_matrix INCLUDE \"comm_includes/ReduceAndSumMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndSumMatrixCleanup_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Finally routine to sum up the matrices. PURE SUBROUTINE ReduceAndSumMatrixCleanup_lsc ( matrix , gathered_matrix , & & threshold , helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The threshold the threshold for flushing values. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !! Local Data TYPE ( Matrix_lsc ) :: temporary_matrix , sum_matrix INCLUDE \"comm_includes/ReduceAndSumMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndSumMatrixCleanup_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the size of the matrices is complete. FUNCTION TestReduceSizeRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % outer_send_request_list ), & & helper % outer_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % outer_recv_request_list ), & & helper % outer_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % outer_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceSizeRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the inner indices of the matrices is complete. FUNCTION TestReduceInnerRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % inner_send_request_list ), & & helper % inner_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % inner_recv_request_list ), & & helper % inner_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % inner_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceInnerRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the data of the matrices is complete. FUNCTION TestReduceDataRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % data_send_request_list ), & & helper % data_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % data_recv_request_list ), & & helper % data_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % data_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceDataRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixReduceModule","tags":"","loc":"sourcefile/matrixreducemodule.f90.html"},{"title":"SMatrixModule.F90 – NTPoly","text":"Contents Modules SMatrixModule Source Code SMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling locally stored CSR matrices. MODULE SMatrixModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE MatrixMarketModule , ONLY : ParseMMHeader USE TripletListModule , ONLY : TripletList_r , TripletList_c , SortTripletList , & & DestructTripletList , ConstructTripletList , AppendToTripletList , & & SymmetrizeTripletList , ConvertTripletListType USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a local, real CSR matrix. TYPE , PUBLIC :: Matrix_lsr INTEGER , DIMENSION (:), ALLOCATABLE :: outer_index !< Outer indices INTEGER , DIMENSION (:), ALLOCATABLE :: inner_index !< Inner indices REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: values !< Values INTEGER :: rows !< Matrix dimension: rows INTEGER :: columns !< Matrix dimension: columns END TYPE Matrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a local, complex CSR matrix. TYPE , PUBLIC :: Matrix_lsc INTEGER , DIMENSION (:), ALLOCATABLE :: outer_index !< Outer indices INTEGER , DIMENSION (:), ALLOCATABLE :: inner_index !< Inner indices COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: values !< Values INTEGER :: rows !< Matrix dimension: rows INTEGER :: columns !< Matrix dimension: columns END TYPE Matrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Construct/Destruct PUBLIC :: ConstructEmptyMatrix PUBLIC :: ConstructMatrixFromFile PUBLIC :: ConstructMatrixFromTripletList PUBLIC :: DestructMatrix PUBLIC :: CopyMatrix !! Basic Accessors PUBLIC :: GetMatrixRows PUBLIC :: GetMatrixColumns PUBLIC :: ExtractMatrixRow PUBLIC :: ExtractMatrixColumn !! Routines for splitting and composing PUBLIC :: SplitMatrix PUBLIC :: SplitMatrixColumns PUBLIC :: ComposeMatrix PUBLIC :: ComposeMatrixColumns !! ETC PUBLIC :: ConvertMatrixType PUBLIC :: TransposeMatrix PUBLIC :: ConjugateMatrix PUBLIC :: PrintMatrix PUBLIC :: MatrixToTripletList !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE Matrix_lsr MODULE PROCEDURE ConstructEmptyMatrix_lsr MODULE PROCEDURE ConstructMatrixFromFile_lsr MODULE PROCEDURE ConstructMatrixFromTripletList_lsr END INTERFACE INTERFACE Matrix_lsc MODULE PROCEDURE ConstructEmptyMatrix_lsc MODULE PROCEDURE ConstructMatrixFromFile_lsc MODULE PROCEDURE ConstructMatrixFromTripletList_lsc END INTERFACE INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrixSub_lsr MODULE PROCEDURE ConstructEmptyMatrixSub_lsc END INTERFACE INTERFACE ConstructMatrixFromFile MODULE PROCEDURE ConstructMatrixFromFileSub_lsr MODULE PROCEDURE ConstructMatrixFromFileSub_lsc END INTERFACE INTERFACE ConstructMatrixFromTripletList MODULE PROCEDURE ConstructMatrixFromTripletListSub_lsr MODULE PROCEDURE ConstructMatrixFromTripletListSub_lsc END INTERFACE INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_lsr MODULE PROCEDURE DestructMatrix_lsc END INTERFACE INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_lsr MODULE PROCEDURE CopyMatrix_lsc END INTERFACE INTERFACE GetMatrixRows MODULE PROCEDURE GetMatrixRows_lsr MODULE PROCEDURE GetMatrixRows_lsc END INTERFACE INTERFACE GetMatrixColumns MODULE PROCEDURE GetMatrixColumns_lsr MODULE PROCEDURE GetMatrixColumns_lsc END INTERFACE INTERFACE ExtractMatrixRow MODULE PROCEDURE ExtractMatrixRow_lsr MODULE PROCEDURE ExtractMatrixRow_lsc END INTERFACE INTERFACE ExtractMatrixColumn MODULE PROCEDURE ExtractMatrixColumn_lsr MODULE PROCEDURE ExtractMatrixColumn_lsc END INTERFACE INTERFACE SplitMatrix MODULE PROCEDURE SplitMatrix_lsr MODULE PROCEDURE SplitMatrix_lsc END INTERFACE INTERFACE SplitMatrixColumns MODULE PROCEDURE SplitMatrixColumns_lsr MODULE PROCEDURE SplitMatrixColumns_lsc END INTERFACE INTERFACE ComposeMatrix MODULE PROCEDURE ComposeMatrix_lsr MODULE PROCEDURE ComposeMatrix_lsc END INTERFACE INTERFACE ComposeMatrixColumns MODULE PROCEDURE ComposeMatrixColumns_lsr MODULE PROCEDURE ComposeMatrixColumns_lsc END INTERFACE INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_lsr MODULE PROCEDURE TransposeMatrix_lsc END INTERFACE INTERFACE ConjugateMatrix MODULE PROCEDURE ConjugateMatrix_lsc END INTERFACE INTERFACE PrintMatrix MODULE PROCEDURE PrintMatrix_lsr MODULE PROCEDURE PrintMatrix_lsc END INTERFACE INTERFACE MatrixToTripletList MODULE PROCEDURE MatrixToTripletList_lsr MODULE PROCEDURE MatrixToTripletList_lsc END INTERFACE INTERFACE ConvertMatrixType MODULE PROCEDURE ConvertMatrixType_lsrtolsc MODULE PROCEDURE ConvertMatrixType_lsctolsr END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine type wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSub_lsr ( this , rows , columns , zero_in ) !> The matrix to construct. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in IF ( PRESENT ( zero_in )) THEN this = ConstructEmptyMatrix_lsr ( rows , columns , zero_in ) ELSE this = ConstructEmptyMatrix_lsr ( rows , columns ) ENDIF END SUBROUTINE ConstructEmptyMatrixSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine type wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSub_lsc ( this , rows , columns , zero_in ) !> The matrix to construct. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in IF ( PRESENT ( zero_in )) THEN this = ConstructEmptyMatrix_lsc ( rows , columns , zero_in ) ELSE this = ConstructEmptyMatrix_lsc ( rows , columns ) ENDIF END SUBROUTINE ConstructEmptyMatrixSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a sparse matrix with a certain number of columns !> and rows. Will allocate storage for the outer values, nothing else unless !> you set zero_in to true. PURE FUNCTION ConstructEmptyMatrix_lsr ( rows , columns , zero_in ) RESULT ( this ) !> The matrix to construct. TYPE ( Matrix_lsr ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in INCLUDE \"sparse_includes/ConstructEmptyMatrix.f90\" END FUNCTION ConstructEmptyMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a sparse matrix with a certain number of columns !> and rows. Will allocate storage for the outer values, nothing else unless !> you set zero_in to true. PURE FUNCTION ConstructEmptyMatrix_lsc ( rows , columns , zero_in ) RESULT ( this ) !> The matrix to construct. TYPE ( Matrix_lsc ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in INCLUDE \"sparse_includes/ConstructEmptyMatrix.f90\" END FUNCTION ConstructEmptyMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the construct from file function. SUBROUTINE ConstructMatrixFromFileSub_lsr ( this , file_name ) !> The matrix being constructed. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name this = ConstructMatrixFromFile_lsr ( file_name ) END SUBROUTINE ConstructMatrixFromFileSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE ConstructMatrixFromFileSub_lsc ( this , file_name ) !> The matrix being constructed. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name this = ConstructMatrixFromFile_lsc ( file_name ) END SUBROUTINE ConstructMatrixFromFileSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a sparse matrix by reading in a matrix market file. FUNCTION ConstructMatrixFromFile_lsr ( file_name ) RESULT ( this ) !> The matrix being constructed. TYPE ( Matrix_lsr ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Local Data TYPE ( TripletList_r ) :: triplet_list TYPE ( TripletList_r ) :: sorted_triplet_list TYPE ( Triplet_r ) :: temporary #include \"sparse_includes/ConstructMatrixFromFile.f90\" END FUNCTION ConstructMatrixFromFile_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a sparse matrix by reading in a matrix market file. FUNCTION ConstructMatrixFromFile_lsc ( file_name ) RESULT ( this ) !> The matrix being constructed. TYPE ( Matrix_lsc ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Local Data TYPE ( TripletList_c ) :: triplet_list TYPE ( TripletList_c ) :: sorted_triplet_list TYPE ( Triplet_c ) :: temporary REAL ( NTREAL ) :: real_val , comp_val #define ISCOMPLEX #include \"sparse_includes/ConstructMatrixFromFile.f90\" #undef ISCOMPLEX END FUNCTION ConstructMatrixFromFile_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the triplet list based constructor. PURE SUBROUTINE ConstructMatrixFromTripletListSub_lsr ( this , triplet_list , & & rows , columns ) !> The matrix being constructed TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns this = ConstructMatrixFromTripletList_lsr ( triplet_list , rows , columns ) END SUBROUTINE ConstructMatrixFromTripletListSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the triplet list based constructor. PURE SUBROUTINE ConstructMatrixFromTripletListSub_lsc ( this , triplet_list , & & rows , columns ) !> The matrix being constructed TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns this = ConstructMatrixFromTripletList_lsc ( triplet_list , rows , columns ) END SUBROUTINE ConstructMatrixFromTripletListSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a sparse matrix from a \\b SORTED triplet list. !> The triplet list must be sorted to efficiently fill in the matrix. This !> constructor assumes \\b you have already sorted the triplet list. PURE FUNCTION ConstructMatrixFromTripletList_lsr ( triplet_list , rows , columns ) & & RESULT ( this ) !> The matrix being constructed TYPE ( Matrix_lsr ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns #define ISCOMPLEX #include \"sparse_includes/ConstructMatrixFromTripletList.f90\" #undef ISCOMPLEX END FUNCTION ConstructMatrixFromTripletList_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a sparse matrix from a \\b SORTED triplet list. !> The triplet list must be sorted to efficiently fill in the matrix. This !> constructor assumes \\b you have already sorted the triplet list. PURE FUNCTION ConstructMatrixFromTripletList_lsc ( triplet_list , rows , columns ) & & RESULT ( this ) !> The matrix being constructed TYPE ( Matrix_lsc ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns INCLUDE \"sparse_includes/ConstructMatrixFromTripletList.f90\" END FUNCTION ConstructMatrixFromTripletList_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Explicitly destruct a sparse matrix. PURE SUBROUTINE DestructMatrix_lsr ( this ) !> The matrix to free up. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this INCLUDE \"sparse_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Explicitly destruct a sparse matrix. PURE SUBROUTINE DestructMatrix_lsc ( this ) !> The matrix to free up. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this INCLUDE \"sparse_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a sparse matrix in a safe way. PURE SUBROUTINE CopyMatrix_lsr ( matA , matB ) !> Matrix to copy TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matB INCLUDE \"sparse_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a sparse matrix in a safe way. PURE SUBROUTINE CopyMatrix_lsc ( matA , matB ) !> Matrix to copy TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matB INCLUDE \"sparse_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of rows of a matrix. PURE FUNCTION GetMatrixRows_lsr ( this ) RESULT ( rows ) !> The matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The number of rows. INTEGER :: rows INCLUDE \"sparse_includes/GetMatrixRows.f90\" END FUNCTION GetMatrixRows_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of rows of a matrix. PURE FUNCTION GetMatrixRows_lsc ( this ) RESULT ( rows ) !> The matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The number of rows. INTEGER :: rows INCLUDE \"sparse_includes/GetMatrixRows.f90\" END FUNCTION GetMatrixRows_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of columns of a matrix. PURE FUNCTION GetMatrixColumns_lsr ( this ) RESULT ( columns ) !! The matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The number of columns. INTEGER :: columns INCLUDE \"sparse_includes/GetMatrixColumns.f90\" END FUNCTION GetMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of columns of a matrix. PURE FUNCTION GetMatrixColumns_lsc ( this ) RESULT ( columns ) !! The matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The number of columns. INTEGER :: columns INCLUDE \"sparse_includes/GetMatrixColumns.f90\" END FUNCTION GetMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a row from the matrix. PURE SUBROUTINE ExtractMatrixRow_lsr ( this , row_number , row_out ) !> The matrix to extract from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The row to extract. INTEGER , INTENT ( IN ) :: row_number !> The matrix representing that row. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: row_out !! Temporary Variables REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: value_buffer INCLUDE \"sparse_includes/ExtractMatrixRow.f90\" END SUBROUTINE ExtractMatrixRow_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a row from the matrix. PURE SUBROUTINE ExtractMatrixRow_lsc ( this , row_number , row_out ) !> The matrix to extract from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The row to extract. INTEGER , INTENT ( IN ) :: row_number !> The matrix representing that row. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: row_out !! Temporary Variables COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: value_buffer INCLUDE \"sparse_includes/ExtractMatrixRow.f90\" END SUBROUTINE ExtractMatrixRow_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a column from the matrix. PURE SUBROUTINE ExtractMatrixColumn_lsr ( this , column_number , column_out ) !> The matrix to extract from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The column to extract. INTEGER , INTENT ( IN ) :: column_number !> The column representing that row. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: column_out INCLUDE \"sparse_includes/ExtractMatrixColumn.f90\" END SUBROUTINE ExtractMatrixColumn_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a column from the matrix. PURE SUBROUTINE ExtractMatrixColumn_lsc ( this , column_number , column_out ) !> The matrix to extract from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The column to extract. INTEGER , INTENT ( IN ) :: column_number !> The column representing that row. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: column_out INCLUDE \"sparse_includes/ExtractMatrixColumn.f90\" END SUBROUTINE ExtractMatrixColumn_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix and return it in a separate matrix. !> The current implementation has you go from matrix to triplet list, !> triplet list to transposed triplet list. The triplet list must then be !> sorted and then the return matrix is constructed. PURE SUBROUTINE TransposeMatrix_lsr ( this , matT ) !> The matrix to be transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The input matrix transposed. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matT INCLUDE \"sparse_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix and return it in a separate matrix. !> The current implementation has you go from matrix to triplet list, !> triplet list to transposed triplet list. The triplet list must then be !> sorted and then the return matrix is constructed. PURE SUBROUTINE TransposeMatrix_lsc ( this , matT ) !> The matrix to be transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The input matrix transposed. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matT INCLUDE \"sparse_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_lsr ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_lsr ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: out_matrix !! Local Data TYPE ( Matrix_lsr ), DIMENSION ( block_columns ) :: merged_columns TYPE ( Matrix_lsr ) :: Temp TYPE ( Matrix_lsr ), DIMENSION ( block_rows , block_columns ) :: mat_t INCLUDE \"sparse_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_lsc ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_lsc ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: out_matrix !! Local Data TYPE ( Matrix_lsc ), DIMENSION ( block_columns ) :: merged_columns TYPE ( Matrix_lsc ) :: Temp TYPE ( Matrix_lsc ), DIMENSION ( block_rows , block_columns ) :: mat_t INCLUDE \"sparse_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of !> the first matrix are followed by the columns of the matrices in the list. PURE SUBROUTINE ComposeMatrixColumns_lsr ( mat_list , out_matrix ) !> A list of matrices to compose. TYPE ( Matrix_lsr ), DIMENSION (:), INTENT ( IN ) :: mat_list !> out_matrix = [Matrix 1 | Matrix 2, ...]. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: out_matrix INCLUDE \"sparse_includes/ComposeMatrixColumns.f90\" END SUBROUTINE ComposeMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of !> the first matrix are followed by the columns of the matrices in the list. PURE SUBROUTINE ComposeMatrixColumns_lsc ( mat_list , out_matrix ) !> A list of matrices to compose. TYPE ( Matrix_lsc ), DIMENSION (:), INTENT ( IN ) :: mat_list !> out_matrix = [Matrix 1 | Matrix 2, ...]. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: out_matrix INCLUDE \"sparse_includes/ComposeMatrixColumns.f90\" END SUBROUTINE ComposeMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_lsr ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_lsr ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in !! Local Data TYPE ( Matrix_lsr ), DIMENSION ( block_columns ) :: column_split TYPE ( Matrix_lsr ), DIMENSION ( block_rows ) :: row_split TYPE ( Matrix_lsr ) :: Temp INCLUDE \"sparse_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_lsc ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_lsc ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in !! Local Data TYPE ( Matrix_lsc ), DIMENSION ( block_columns ) :: column_split TYPE ( Matrix_lsc ), DIMENSION ( block_rows ) :: row_split TYPE ( Matrix_lsc ) :: Temp INCLUDE \"sparse_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a matrix into into small blocks based on the specified offsets. PURE SUBROUTINE SplitMatrixColumns_lsr ( this , num_blocks , block_sizes , & & split_list ) !> This matrix to perform this operation on. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Number of blocks to split into. INTEGER , INTENT ( IN ) :: num_blocks !> The sizes used for splitting. INTEGER , DIMENSION ( num_blocks ), INTENT ( IN ) :: block_sizes !> 1D array of blocks. TYPE ( Matrix_lsr ), DIMENSION ( num_blocks ), INTENT ( INOUT ) :: split_list INCLUDE \"sparse_includes/SplitMatrixColumns.f90\" END SUBROUTINE SplitMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a matrix into into small blocks based on the specified offsets. PURE SUBROUTINE SplitMatrixColumns_lsc ( this , num_blocks , block_sizes , & & split_list ) !> This matrix to perform this operation on. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Number of blocks to split into. INTEGER , INTENT ( IN ) :: num_blocks !> The sizes used for splitting. INTEGER , DIMENSION ( num_blocks ), INTENT ( IN ) :: block_sizes !> 1D array of blocks. TYPE ( Matrix_lsc ), DIMENSION ( num_blocks ), INTENT ( INOUT ) :: split_list INCLUDE \"sparse_includes/SplitMatrixColumns.f90\" END SUBROUTINE SplitMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list from a matrix. PURE SUBROUTINE MatrixToTripletList_lsr ( this , triplet_list ) !> The matrix to construct the triplet list from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The triplet list we created. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !! Local Variables TYPE ( Triplet_r ) :: temporary INCLUDE \"sparse_includes/MatrixToTripletList.f90\" END SUBROUTINE MatrixToTripletList_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list from a matrix. PURE SUBROUTINE MatrixToTripletList_lsc ( this , triplet_list ) !> The matrix to construct the triplet list from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The triplet list we created. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !! Local Variables TYPE ( Triplet_c ) :: temporary INCLUDE \"sparse_includes/MatrixToTripletList.f90\" END SUBROUTINE MatrixToTripletList_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a sparse matrix to the console. SUBROUTINE PrintMatrix_lsr ( this , file_name_in ) !> The matrix to be printed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Optionally you can pass a file to print to. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Local Data TYPE ( TripletList_r ) :: triplet_list #include \"sparse_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a sparse matrix to the console. SUBROUTINE PrintMatrix_lsc ( this , file_name_in ) !> The matrix to be printed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Optionally you can pass a file to print to. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Local Data TYPE ( TripletList_c ) :: triplet_list #define ISCOMPLEX #include \"sparse_includes/PrintMatrix.f90\" #undef ISCOMPLEX END SUBROUTINE PrintMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Every value in the matrix is changed into its complex conjugate. PURE SUBROUTINE ConjugateMatrix_lsc ( this ) !> The matrix to compute the complex conjugate of. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this this % values = CONJG ( this % values ) END SUBROUTINE ConjugateMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex matrix to a real matrix. SUBROUTINE ConvertMatrixType_lsrtolsc ( cin , rout ) !> The starting matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: cin !> Real valued matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: rout !! Local Variables TYPE ( TripletList_c ) :: in_list TYPE ( TripletList_r ) :: out_list CALL MatrixToTripletList ( cin , in_list ) CALL ConvertTripletListType ( in_list , out_list ) CALL ConstructMatrixFromTripletList ( rout , out_list , cin % rows , cin % columns ) CALL DestructTripletList ( in_list ) CALL DestructTripletList ( out_list ) END SUBROUTINE ConvertMatrixType_lsrtolsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real matrix to a complex matrix. SUBROUTINE ConvertMatrixType_lsctolsr ( rin , cout ) !> The starting matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: rin !> The complex valued matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: cout !! Local Variables TYPE ( TripletList_r ) :: in_list TYPE ( TripletList_c ) :: out_list CALL MatrixToTripletList ( rin , in_list ) CALL ConvertTripletListType ( in_list , out_list ) CALL ConstructMatrixFromTripletList ( cout , out_list , rin % rows , rin % columns ) CALL DestructTripletList ( in_list ) CALL DestructTripletList ( out_list ) END SUBROUTINE ConvertMatrixType_lsctolsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SMatrixModule","tags":"","loc":"sourcefile/smatrixmodule.f90.html"},{"title":"DataTypesModule.F90 – NTPoly","text":"Contents Modules DataTypesModule Source Code DataTypesModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to store specifications for basic data types. MODULE DataTypesModule USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_DOUBLE , C_DOUBLE_COMPLEX IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The precision of floating point numbers we will use in this program. INTEGER , PARAMETER , PUBLIC :: NTREAL = C_DOUBLE !> MPI floating point datatype with the precision we will use in this program. INTEGER , PUBLIC :: MPINTREAL = MPI_DOUBLE_PRECISION !> The complex numbers we will use in this program. INTEGER , PARAMETER , PUBLIC :: NTCOMPLEX = C_DOUBLE_COMPLEX !> MPI complex datatype with the precision we will use in this program. INTEGER , PARAMETER , PUBLIC :: MPINTCOMPLEX = MPI_DOUBLE_COMPLEX !> MPI Integer type we will use in this program. INTEGER , PARAMETER , PUBLIC :: MPINTINTEGER = MPI_INT !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DataTypesModule","tags":"","loc":"sourcefile/datatypesmodule.f90.html"},{"title":"ExponentialSolversModule.F90 – NTPoly","text":"Contents Modules ExponentialSolversModule Source Code ExponentialSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Matrix Exponentials and Logarithms. MODULE ExponentialSolversModule USE ChebyshevSolversModule , ONLY : ChebyshevPolynomial_t , Compute , & & ConstructPolynomial , DestructPolynomial , FactorizedCompute , & & SetCoefficient USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds , PowerBounds USE LinearSolversModule , ONLY : CGSolver USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , ScaleMatrix , & & IncrementMatrix USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE RootSolversModule , ONLY : ComputeRoot USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters USE SquareRootSolversModule , ONLY : SquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: ComputeExponential PUBLIC :: ComputeExponentialPade PUBLIC :: ComputeExponentialTaylor PUBLIC :: ComputeLogarithm PUBLIC :: ComputeLogarithmTaylor CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix. SUBROUTINE ComputeExponential ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters TYPE ( SolverParameters_t ) :: sub_solver_parameters TYPE ( SolverParameters_t ) :: psub_solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool !! For Chebyshev Expansion TYPE ( ChebyshevPolynomial_t ) :: polynomial !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF sub_solver_parameters = solver_parameters psub_solver_parameters = solver_parameters psub_solver_parameters % max_iterations = 10 IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Chebyshev\" ) CALL PrintParameters ( solver_parameters ) END IF CALL ConstructEmptyMatrix ( OutputMat , InputMat ) !! Scale the matrix CALL PowerBounds ( InputMat , spectral_radius , psub_solver_parameters ) sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) sub_solver_parameters % threshold = sub_solver_parameters % threshold / sigma_val IF ( solver_parameters % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , value = sigma_val ) END IF !! Expand Chebyshev Series CALL ConstructPolynomial ( polynomial , 16 ) CALL SetCoefficient ( polynomial , 1 , 1.266065877752007e+00_NTREAL ) CALL SetCoefficient ( polynomial , 2 , 1.130318207984970e+00_NTREAL ) CALL SetCoefficient ( polynomial , 3 , 2.714953395340771e-01_NTREAL ) CALL SetCoefficient ( polynomial , 4 , 4.433684984866504e-02_NTREAL ) CALL SetCoefficient ( polynomial , 5 , 5.474240442092110e-03_NTREAL ) CALL SetCoefficient ( polynomial , 6 , 5.429263119148932e-04_NTREAL ) CALL SetCoefficient ( polynomial , 7 , 4.497732295351912e-05_NTREAL ) CALL SetCoefficient ( polynomial , 8 , 3.198436462630565e-06_NTREAL ) CALL SetCoefficient ( polynomial , 9 , 1.992124801999838e-07_NTREAL ) CALL SetCoefficient ( polynomial , 10 , 1.103677287249654e-08_NTREAL ) CALL SetCoefficient ( polynomial , 11 , 5.505891628277851e-10_NTREAL ) CALL SetCoefficient ( polynomial , 12 , 2.498021534339559e-11_NTREAL ) CALL SetCoefficient ( polynomial , 13 , 1.038827668772902e-12_NTREAL ) CALL SetCoefficient ( polynomial , 14 , 4.032447357431817e-14_NTREAL ) CALL SetCoefficient ( polynomial , 15 , 2.127980007794583e-15_NTREAL ) CALL SetCoefficient ( polynomial , 16 , - 1.629151584468762e-16_NTREAL ) CALL Compute ( ScaledMat , OutputMat , polynomial , sub_solver_parameters ) !CALL FactorizedChebyshevCompute(ScaledMat,OutputMat,polynomial, & !     & sub_solver_parameters) !! Undo the scaling by squaring at the end. !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( solver_parameters % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructPolynomial ( polynomial ) CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeExponential !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix using a pade approximation. !> Be warned, the pade method can result in a lot of intermediate fill. SUBROUTINE ComputeExponentialPade ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters TYPE ( SolverParameters_t ) :: sub_solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: IdentityMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: B1 , B2 , B3 TYPE ( Matrix_ps ) :: P1 , P2 TYPE ( Matrix_ps ) :: LeftMat , RightMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Pade\" ) CALL PrintParameters ( solver_parameters ) END IF !! Setup CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Scale the matrix spectral_radius = MatrixNorm ( InputMat ) sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) IF ( solver_parameters % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , value = sigma_val ) CALL WriteElement ( key = \"Scaling_Steps\" , value = sigma_counter ) END IF !! Sub Solver Parameters sub_solver_parameters = solver_parameters sub_solver_parameters % threshold = sub_solver_parameters % threshold / sigma_val !! Power Matrices CALL MatrixMultiply ( ScaledMat , ScaledMat , B1 , & & threshold_in = sub_solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( B1 , B1 , B2 , & & threshold_in = sub_solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( B2 , B2 , B3 , & & threshold_in = sub_solver_parameters % threshold , memory_pool_in = pool ) !! Polynomials - 1 CALL CopyMatrix ( IdentityMat , P1 ) CALL ScaleMatrix ( P1 , 1729728 0.0_NTREAL ) CALL IncrementMatrix ( B1 , P1 , alpha_in = 199584 0.0_NTREAL ) CALL IncrementMatrix ( B2 , P1 , alpha_in = 2520 0.0_NTREAL ) CALL IncrementMatrix ( B3 , P1 , alpha_in = 5 6.0_NTREAL ) !! Polynomials - 2 CALL CopyMatrix ( IdentityMat , TempMat ) CALL ScaleMatrix ( TempMat , 864864 0.0_NTREAL ) CALL IncrementMatrix ( B1 , TempMat , alpha_in = 27720 0.0_NTREAL ) CALL IncrementMatrix ( B2 , TempMat , alpha_in = 151 2.0_NTREAL ) CALL IncrementMatrix ( B3 , TempMat ) CALL MatrixMultiply ( ScaledMat , TempMat , P2 , & & threshold_in = sub_solver_parameters % threshold , memory_pool_in = pool ) !! Left and Right CALL CopyMatrix ( P1 , LeftMat ) CALL IncrementMatrix ( P2 , LeftMat , - 1.0_NTREAL ) CALL CopyMatrix ( P1 , RightMat ) CALL IncrementMatrix ( P2 , RightMat , 1.0_NTREAL ) CALL CGSolver ( LeftMat , OutputMat , RightMat , sub_solver_parameters ) !! Undo the scaling by squaring at the end. DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( solver_parameters % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( B1 ) CALL DestructMatrix ( B2 ) CALL DestructMatrix ( B3 ) CALL DestructMatrix ( P1 ) CALL DestructMatrix ( P2 ) CALL DestructMatrix ( LeftMat ) CALL DestructMatrix ( RightMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeExponentialPade !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix using a taylor series expansion. !> This is only really useful if you have a very small spectrum, because !> quite a bit of scaling is required. SUBROUTINE ComputeExponentialTaylor ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters TYPE ( SolverParameters_t ) :: psub_solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF psub_solver_parameters = solver_parameters psub_solver_parameters % max_iterations = 10 IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Taylor\" ) CALL PrintParameters ( solver_parameters ) END IF !! Compute The Scaling Factor CALL PowerBounds ( InputMat , spectral_radius , psub_solver_parameters ) !! Figure out how much to scale the matrix. sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 3.0e-8 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL FillMatrixIdentity ( OutputMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Expand Taylor Series taylor_denom = 1.0 CALL CopyMatrix ( OutputMat , Ak ) DO counter = 1 , 10 taylor_denom = taylor_denom * counter CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat ) END DO DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrix ( TempMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeExponentialTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the logarithm of a matrix. SUBROUTINE ComputeLogarithm ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: IdentityMat !! For Chebyshev Expansion TYPE ( ChebyshevPolynomial_t ) :: polynomial !! Local Variables TYPE ( SolverParameters_t ) :: i_sub_solver_parameters TYPE ( SolverParameters_t ) :: p_sub_solver_parameters TYPE ( SolverParameters_t ) :: f_sub_solver_parameters REAL ( NTREAL ) :: spectral_radius INTEGER :: sigma_val INTEGER :: sigma_counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF i_sub_solver_parameters = solver_parameters p_sub_solver_parameters = solver_parameters p_sub_solver_parameters % max_iterations = 16 f_sub_solver_parameters = solver_parameters IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Logarithm Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Chebyshev\" ) CALL PrintParameters ( solver_parameters ) END IF !! Setup CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Copy to a temporary matrix for scaling. CALL CopyMatrix ( InputMat , ScaledMat ) !! Compute The Scaling Factor sigma_val = 1 sigma_counter = 1 CALL PowerBounds ( InputMat , spectral_radius , p_sub_solver_parameters ) DO WHILE ( spectral_radius . GT . SQRT ( 2.0 )) spectral_radius = SQRT ( spectral_radius ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO IF ( solver_parameters % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , value = sigma_val ) END IF f_sub_solver_parameters % threshold = & & f_sub_solver_parameters % threshold / REAL ( 2 ** ( sigma_counter - 1 ), NTREAL ) CALL ComputeRoot ( InputMat , ScaledMat , sigma_val , i_sub_solver_parameters ) !! Shift Scaled Matrix CALL IncrementMatrix ( IdentityMat , ScaledMat , & & alpha_in = REAL ( - 1.0 , NTREAL )) !! Expand Chebyshev Series CALL ConstructPolynomial ( polynomial , 32 ) CALL SetCoefficient ( polynomial , 1 , - 0.485101351704_NTREAL ) CALL SetCoefficient ( polynomial , 2 , 1.58828112379_NTREAL ) CALL SetCoefficient ( polynomial , 3 , - 0.600947731795_NTREAL ) CALL SetCoefficient ( polynomial , 4 , 0.287304748177_NTREAL ) CALL SetCoefficient ( polynomial , 5 , - 0.145496447103_NTREAL ) CALL SetCoefficient ( polynomial , 6 , 0.0734013668818_NTREAL ) CALL SetCoefficient ( polynomial , 7 , - 0.0356277942958_NTREAL ) CALL SetCoefficient ( polynomial , 8 , 0.0161605505166_NTREAL ) CALL SetCoefficient ( polynomial , 9 , - 0.0066133591188_NTREAL ) CALL SetCoefficient ( polynomial , 10 , 0.00229833505456_NTREAL ) CALL SetCoefficient ( polynomial , 11 , - 0.000577804103964_NTREAL ) CALL SetCoefficient ( polynomial , 12 , 2.2849332964e-05_NTREAL ) CALL SetCoefficient ( polynomial , 13 , 8.37426826403e-05_NTREAL ) CALL SetCoefficient ( polynomial , 14 , - 6.10822859027e-05_NTREAL ) CALL SetCoefficient ( polynomial , 15 , 2.58132364523e-05_NTREAL ) CALL SetCoefficient ( polynomial , 16 , - 5.87577322647e-06_NTREAL ) CALL SetCoefficient ( polynomial , 17 , - 8.56711062722e-07_NTREAL ) CALL SetCoefficient ( polynomial , 18 , 1.52066488969e-06_NTREAL ) CALL SetCoefficient ( polynomial , 19 , - 7.12760496253e-07_NTREAL ) CALL SetCoefficient ( polynomial , 20 , 1.23102245249e-07_NTREAL ) CALL SetCoefficient ( polynomial , 21 , 6.03168259043e-08_NTREAL ) CALL SetCoefficient ( polynomial , 22 , - 5.1865499826e-08_NTREAL ) CALL SetCoefficient ( polynomial , 23 , 1.43185107512e-08_NTREAL ) CALL SetCoefficient ( polynomial , 24 , 2.58449717089e-09_NTREAL ) CALL SetCoefficient ( polynomial , 25 , - 3.73189861771e-09_NTREAL ) CALL SetCoefficient ( polynomial , 26 , 1.18469334815e-09_NTREAL ) CALL SetCoefficient ( polynomial , 27 , 1.51569931066e-10_NTREAL ) CALL SetCoefficient ( polynomial , 28 , - 2.89595999673e-10_NTREAL ) CALL SetCoefficient ( polynomial , 29 , 1.26720668874e-10_NTREAL ) CALL SetCoefficient ( polynomial , 30 , - 3.00079067694e-11_NTREAL ) CALL SetCoefficient ( polynomial , 31 , 3.91175568865e-12_NTREAL ) CALL SetCoefficient ( polynomial , 32 , - 2.21155654398e-13_NTREAL ) CALL FactorizedCompute ( ScaledMat , OutputMat , polynomial , & & f_sub_solver_parameters ) !! Scale Back CALL ScaleMatrix ( OutputMat , & & REAL ( 2 ** ( sigma_counter - 1 ), NTREAL )) !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructPolynomial ( polynomial ) CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeLogarithm !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the logarithm of a matrix using a taylor series expansion. SUBROUTINE ComputeLogarithmTaylor ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: IdentityMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables TYPE ( SolverParameters_t ) :: sub_solver_parameters REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF sub_solver_parameters = solver_parameters IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Logarithm Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Taylor\" ) CALL PrintParameters ( solver_parameters ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0 sigma_counter = 1 CALL CopyMatrix ( InputMat , ScaledMat ) !do while (spectral_radius/sigma_val .gt. 1.1e-5) DO WHILE ( spectral_radius / sigma_val . GT . 1.1e-7 ) CALL SquareRoot ( ScaledMat , TempMat , sub_solver_parameters ) CALL CopyMatrix ( TempMat , ScaledMat ) CALL GershgorinBounds ( ScaledMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Setup Matrices CALL IncrementMatrix ( IdentityMat , ScaledMat , & & alpha_in = REAL ( - 1.0 , NTREAL )) CALL CopyMatrix ( IdentityMat , Ak ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Ak , Ak , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Expand taylor series. CALL CopyMatrix ( ScaledMat , OutputMat ) DO counter = 2 , 10 IF ( MOD ( counter , 2 ) . EQ . 0 ) THEN taylor_denom = - 1 * counter ELSE taylor_denom = counter END IF CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat , & & alpha_in = 1.0 / taylor_denom ) END DO !! Undo scaling. CALL ScaleMatrix ( OutputMat , REAL ( 2 ** sigma_counter , NTREAL )) !! Undo load balancing. IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE ComputeLogarithmTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ExponentialSolversModule","tags":"","loc":"sourcefile/exponentialsolversmodule.f90.html"},{"title":"PermutationModule.F90 – NTPoly","text":"Contents Modules PermutationModule Source Code PermutationModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for load balancing the matrix multiplication calculation. MODULE PermutationModule USE DataTypesModule , ONLY : NTREAL USE ProcessGridModule , ONLY : global_grid , ProcessGrid_t USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data structure for storing permutations. TYPE , PUBLIC :: Permutation_t !> For each row/column, what index does it correspond to in the !> unperturbed matrix. INTEGER , DIMENSION (:), ALLOCATABLE :: index_lookup !> For each row/column in the unperturbed, what index does it correspond to !> in this matrix. INTEGER , DIMENSION (:), ALLOCATABLE :: reverse_index_lookup END TYPE Permutation_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructDefaultPermutation PUBLIC :: ConstructReversePermutation PUBLIC :: ConstructRandomPermutation PUBLIC :: ConstructLimitedRandomPermutation PUBLIC :: DestructPermutation CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that preserves the original order. SUBROUTINE ConstructDefaultPermutation ( this , matrix_dimension ) !> The permutation to construct. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The dimension of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !! Local Data INTEGER :: counter ALLOCATE ( this % index_lookup ( matrix_dimension )) ALLOCATE ( this % reverse_index_lookup ( matrix_dimension )) !! Fill by counting. fill : DO counter = 1 , matrix_dimension this % index_lookup ( counter ) = counter this % reverse_index_lookup ( counter ) = counter END DO fill END SUBROUTINE ConstructDefaultPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that reverses the original order. SUBROUTINE ConstructReversePermutation ( this , matrix_dimension ) !> A permutation that reverses the original order. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The size of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !! Local Data INTEGER :: counter ALLOCATE ( this % index_lookup ( matrix_dimension )) ALLOCATE ( this % reverse_index_lookup ( matrix_dimension )) !! Fill by counting. fill : DO counter = 1 , matrix_dimension this % index_lookup ( counter ) = matrix_dimension - counter + 1 this % reverse_index_lookup ( counter ) = counter END DO fill END SUBROUTINE ConstructReversePermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that has a random order. !> Implements Knuth shuffle. SUBROUTINE ConstructRandomPermutation ( this , matrix_dimension , & & process_grid_in ) !> A permutation that reverses the original order. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The size of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !> A permutation should be shared amongst these processes. !> This is to synchronize random number across processes. TYPE ( ProcessGrid_t ), INTENT ( INOUT ), OPTIONAL :: process_grid_in !! Local Data INTEGER :: counter INTEGER :: random_integer REAL ( KIND = NTREAL ) :: rand_temp INTEGER :: swap_space INTEGER :: ierr !! First fill by counting. CALL ConstructDefaultPermutation ( this , matrix_dimension ) !! Do the shuffle shuffle : DO counter = matrix_dimension , 1 , - 1 CALL RANDOM_NUMBER ( rand_temp ) random_integer = FLOOR ( matrix_dimension * rand_temp ) + 1 swap_space = this % index_lookup ( matrix_dimension ) this % index_lookup ( matrix_dimension ) = this % index_lookup ( random_integer ) this % index_lookup ( random_integer ) = swap_space END DO shuffle !! Broadcast the lookup (so each process has the same value) IF ( PRESENT ( process_grid_in )) THEN CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , process_grid_in % global_comm , ierr ) ELSE CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , global_grid % global_comm , ierr ) END IF !! Compute the reverse lookup reverse : DO counter = 1 , matrix_dimension this % reverse_index_lookup ( this % index_lookup ( counter )) = counter END DO reverse END SUBROUTINE ConstructRandomPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that has a random order, but there is no !> permutation from beyond the actual matrix dimension. SUBROUTINE ConstructLimitedRandomPermutation ( this , actual_matrix_dimension , & & logical_matrix_dimension , process_grid_in ) !> The permutation to construct. TYPE ( Permutation_t ), INTENT ( inout ) :: this !> Actual size of the matrix. INTEGER , INTENT ( IN ) :: actual_matrix_dimension !> Padded size of the matrix. INTEGER , INTENT ( IN ) :: logical_matrix_dimension !> A permutation should be shared amongst these processes. !> This is to synchronize random number across processes. TYPE ( ProcessGrid_t ), INTENT ( INOUT ), OPTIONAL :: process_grid_in !! Local Data INTEGER :: counter INTEGER :: random_integer REAL ( KIND = NTREAL ) :: rand_temp INTEGER :: swap_space INTEGER :: ierr !! First fill by counting. CALL ConstructDefaultPermutation ( this , logical_matrix_dimension ) !! Do the shuffle shuffle : DO counter = actual_matrix_dimension , 1 , - 1 CALL RANDOM_NUMBER ( rand_temp ) random_integer = FLOOR ( actual_matrix_dimension * rand_temp ) + 1 swap_space = this % index_lookup ( actual_matrix_dimension ) this % index_lookup ( actual_matrix_dimension ) = & & this % index_lookup ( random_integer ) this % index_lookup ( random_integer ) = swap_space END DO shuffle !! Broadcast the lookup (so each process has the same value) IF ( PRESENT ( process_grid_in )) THEN CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , process_grid_in % global_comm , ierr ) ELSE CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , global_grid % global_comm , ierr ) END IF !! Compute the reverse lookup reverse : DO counter = 1 , logical_matrix_dimension this % reverse_index_lookup ( this % index_lookup ( counter )) = counter END DO reverse END SUBROUTINE ConstructLimitedRandomPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a permutation object. PURE SUBROUTINE DestructPermutation ( this ) !> The permutation to destruct. TYPE ( Permutation_t ), INTENT ( inout ) :: this IF ( ALLOCATED ( this % index_lookup )) THEN DEALLOCATE ( this % index_lookup ) END IF IF ( ALLOCATED ( this % reverse_index_lookup )) THEN DEALLOCATE ( this % reverse_index_lookup ) END IF END SUBROUTINE DestructPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PermutationModule","tags":"","loc":"sourcefile/permutationmodule.f90.html"},{"title":"LinearSolversModule.F90 – NTPoly","text":"Contents Modules LinearSolversModule Source Code LinearSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Solve the matrix equation AX = B MODULE LinearSolversModule USE DataTypesModule , ONLY : NTREAL USE DMatrixModule , ONLY : DestructMatrix USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader , WriteListElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixNorm , & & MatrixMultiply , MatrixTrace , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & TransposeMatrix , DestructMatrix , ConjugateMatrix , CopyMatrix , & & FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: CGSolver CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Solve the matrix equation AX = B using the conjugate gradient method. SUBROUTINE CGSolver ( AMat , XMat , BMat , solver_parameters_in ) !> The matrix A, must be hermitian, positive definite. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The solved for matrix X. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: XMat !> The right hand side. TYPE ( Matrix_ps ), INTENT ( IN ) :: BMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: ABalanced TYPE ( Matrix_ps ) :: BBalanced TYPE ( Matrix_ps ) :: RMat , PMat , QMat TYPE ( Matrix_ps ) :: RMatT , PMatT TYPE ( Matrix_ps ) :: TempMat !! Temporary Variables INTEGER :: outer_counter REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool REAL ( NTREAL ) :: top , bottom , new_top , step_size !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF !! Print out parameters IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Linear Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"CG\" ) CALL PrintParameters ( solver_parameters ) END IF !! Setup all the matrices CALL ConstructEmptyMatrix ( Identity , AMat ) CALL FillMatrixIdentity ( Identity ) CALL ConstructEmptyMatrix ( ABalanced , AMat ) CALL ConstructEmptyMatrix ( BBalanced , AMat ) CALL ConstructEmptyMatrix ( RMat , AMat ) CALL ConstructEmptyMatrix ( PMat , AMat ) CALL ConstructEmptyMatrix ( QMat , AMat ) CALL ConstructEmptyMatrix ( TempMat , AMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( AMat , ABalanced , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BMat , BBalanced , & & solver_parameters % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( AMat , ABalanced ) CALL CopyMatrix ( BMat , BBalanced ) END IF !! Initial Matrix Values CALL CopyMatrix ( Identity , XMat ) !! Compute residual CALL MatrixMultiply ( ABalanced , Xmat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( BBalanced , RMat ) CALL IncrementMatrix ( TempMat , RMat , - 1.0_NTREAL ) CALL CopyMatrix ( RMat , PMat ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteListElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF !! Compute the Step Size CALL MatrixMultiply ( ABalanced , PMat , QMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL TransposeMatrix ( RMat , RMatT ) IF ( RMatT % is_complex ) THEN CALL ConjugateMatrix ( RMatT ) END IF CALL MatrixMultiply ( RMatT , RMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , top ) CALL TransposeMatrix ( PMat , PMatT ) IF ( PMatT % is_complex ) THEN CALL ConjugateMatrix ( PMatT ) END IF CALL MatrixMultiply ( PMatT , QMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , bottom ) step_size = top / bottom !! Update CALL IncrementMatrix ( PMat , XMat , alpha_in = step_size ) norm_value = ABS ( step_size * MatrixNorm ( PMat )) CALL IncrementMatrix ( QMat , RMat , alpha_in =- 1.0_NTREAL * step_size ) !! Update PMat CALL TransposeMatrix ( RMat , RMatT ) IF ( RMatT % is_complex ) THEN CALL ConjugateMatrix ( RMatT ) END IF CALL MatrixMultiply ( RMatT , RMat , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , new_top ) step_size = new_top / top CALL ScaleMatrix ( PMat , step_size ) CALL IncrementMatrix ( RMat , PMat ) END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) CALL PrintMatrixInformation ( XMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( XMat , XMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( RMat ) CALL DestructMatrix ( PMat ) CALL DestructMatrix ( QMat ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( ABalanced ) CALL DestructMatrix ( BBalanced ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE CGSolver !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LinearSolversModule","tags":"","loc":"sourcefile/linearsolversmodule.f90.html"},{"title":"HermiteSolversModule.F90 – NTPoly","text":"Contents Modules HermiteSolversModule Source Code HermiteSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing matrix functions based on Hermite polynomials. !! The Physicist variety. MODULE HermiteSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a Hermite polynomial. TYPE , PUBLIC :: HermitePolynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE HermitePolynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_horner END INTERFACE INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_horner END INTERFACE INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_horner END INTERFACE INTERFACE Compute MODULE PROCEDURE Compute_horner END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a Hermite polynomial object. PURE SUBROUTINE ConstructPolynomial_horner ( this , degree ) !> The polynomial to construct. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this !> The degree of the polynomial. INTEGER , INTENT ( in ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0 END SUBROUTINE ConstructPolynomial_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a Hermite polynomial object. PURE SUBROUTINE DestructPolynomial_horner ( this ) !> The polynomial to destruct. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set a coefficient of a Hermite polynomial. SUBROUTINE SetCoefficient_horner ( this , degree , coefficient ) !> The polynomial to set. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this !> The degree for which to set the coefficient. INTEGER , INTENT ( in ) :: degree !> Coefficient value to set. REAL ( NTREAL ), INTENT ( in ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Hermite Polynomial of the matrix. !> This method uses the standard Hermite Polynomial expansion. SUBROUTINE Compute_horner ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( in ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( inout ) :: OutputMat !> Polynomial to compute. TYPE ( HermitePolynomial_t ), INTENT ( in ) :: poly !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( in ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Hk TYPE ( Matrix_ps ) :: Hkminus1 TYPE ( Matrix_ps ) :: Hkplus1 TYPE ( Matrix_ps ) :: Hkprime TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: counter !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF degree = SIZE ( poly % coefficients ) IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Hermite Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Standard\" ) CALL WriteElement ( key = \"Degree\" , value = degree - 1 ) CALL PrintParameters ( solver_parameters ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Recursive expansion CALL CopyMatrix ( Identity , Hkminus1 ) CALL CopyMatrix ( Hkminus1 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) IF ( degree . GT . 1 ) THEN CALL CopyMatrix ( BalancedInput , Hk ) CALL ScaleMatrix ( Hk , REAL ( 2.0 , KIND = NTREAL )) CALL IncrementMatrix ( Hk , OutputMat , & & alpha_in = poly % coefficients ( 2 )) IF ( degree . GT . 2 ) THEN CALL CopyMatrix ( Hkminus1 , Hkprime ) CALL ScaleMatrix ( Hkprime , REAL ( 2.0 , NTREAL )) DO counter = 3 , degree CALL MatrixMultiply ( BalancedInput , Hk , Hkplus1 , & & alpha_in = REAL ( 2.0 , NTREAL ), & & threshold_in = solver_parameters % threshold , & & memory_pool_in = pool ) CALL IncrementMatrix ( Hkprime , Hkplus1 , & & alpha_in = REAL ( - 1.0 , NTREAL )) CALL CopyMatrix ( Hk , Hkprime ) CALL ScaleMatrix ( Hkprime , & & REAL ( 2 * ( counter - 1 ), KIND = NTREAL )) CALL CopyMatrix ( Hk , Hkminus1 ) CALL CopyMatrix ( Hkplus1 , Hk ) CALL IncrementMatrix ( Hk , OutputMat , & & alpha_in = poly % coefficients ( counter )) END DO END IF END IF IF ( solver_parameters % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Identity ) CALL DestructMatrix ( Hk ) CALL DestructMatrix ( Hkminus1 ) CALL DestructMatrix ( Hkplus1 ) CALL DestructMatrix ( Hkprime ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE Compute_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE HermiteSolversModule","tags":"","loc":"sourcefile/hermitesolversmodule.f90.html"},{"title":"SMatrixAlgebraModule.F90 – NTPoly","text":"Contents Modules SMatrixAlgebraModule Source Code SMatrixAlgebraModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for performing linear algebra using sparse matrices. MODULE SMatrixAlgebraModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE DMatrixModule , ONLY : Matrix_ldr , Matrix_ldc , ConstructMatrixDFromS , & & ConstructMatrixSFromD , MultiplyMatrix , DestructMatrix USE MatrixMemoryPoolModule , ONLY : MatrixMemoryPool_lr , MatrixMemoryPool_lc , & & DestructMatrixMemoryPool , CheckMemoryPoolValidity , SetPoolSparsity , & & ConstructMatrixMemoryPool USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , CopyMatrix , & & TransposeMatrix , ConjugateMatrix , ConstructMatrixFromTripletList , & & ConstructEmptyMatrix USE SVectorModule , ONLY : AddSparseVectors , PairwiseMultiplyVectors USE TripletListModule , ONLY : TripletList_r , TripletList_c , SortTripletList , & & DestructTripletList , ConstructTripletList IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ScaleMatrix PUBLIC :: IncrementMatrix PUBLIC :: DotMatrix PUBLIC :: PairwiseMultiplyMatrix PUBLIC :: MatrixMultiply PUBLIC :: MatrixColumnNorm PUBLIC :: MatrixNorm PUBLIC :: MatrixGrandSum !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ScaleMatrix MODULE PROCEDURE ScaleMatrix_lsr MODULE PROCEDURE ScaleMatrix_lsc MODULE PROCEDURE ScaleMatrix_lsc_c END INTERFACE INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_lsr MODULE PROCEDURE IncrementMatrix_lsc END INTERFACE INTERFACE DotMatrix MODULE PROCEDURE DotMatrix_lsr MODULE PROCEDURE DotMatrix_lsc END INTERFACE INTERFACE PairwiseMultiplyMatrix MODULE PROCEDURE PairwiseMultiplyMatrix_lsr MODULE PROCEDURE PairwiseMultiplyMatrix_lsc END INTERFACE INTERFACE MatrixMultiply MODULE PROCEDURE GemmMatrix_lsr MODULE PROCEDURE GemmMatrix_lsc END INTERFACE INTERFACE MatrixColumnNorm MODULE PROCEDURE MatrixColumnNorm_lsr MODULE PROCEDURE MatrixColumnNorm_lsc END INTERFACE INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_lsr MODULE PROCEDURE MatrixNorm_lsc END INTERFACE INTERFACE MatrixGrandSum MODULE PROCEDURE MatrixGrandSum_lsr MODULE PROCEDURE MatrixGrandSum_lsc END INTERFACE INTERFACE MultiplyBlock MODULE PROCEDURE MultiplyBlock_lsr MODULE PROCEDURE MultiplyBlock_lsc END INTERFACE INTERFACE PruneList MODULE PROCEDURE PruneList_lsr MODULE PROCEDURE PruneList_lsc END INTERFACE INTERFACE SparseBranch MODULE PROCEDURE SparseBranch_lsr MODULE PROCEDURE SparseBranch_lsc END INTERFACE INTERFACE DenseBranch MODULE PROCEDURE DenseBranch_lsr MODULE PROCEDURE DenseBranch_lsc END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsr ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matA !> Constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant INCLUDE \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsc ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matA !> Constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant INCLUDE \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsc_c ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matA !> Constant scale factor. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: constant INCLUDE \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsc_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY). !> This will utilize the sparse vector addition routine. PURE SUBROUTINE IncrementMatrix_lsr ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matB !> Multiplier (default=1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default=0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Variables TYPE ( Matrix_lsr ) :: matC INCLUDE \"sparse_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY). !> This will utilize the sparse vector addition routine. PURE SUBROUTINE IncrementMatrix_lsc ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matB !> Multiplier (default=1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default=0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Variables TYPE ( Matrix_lsc ) :: matC INCLUDE \"sparse_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply two matrices. !> This will utilize the sparse vector pairwise multiply routine. PURE SUBROUTINE PairwiseMultiplyMatrix_lsr ( matA , matB , matC ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !! Local Variables TYPE ( Matrix_lsr ) :: TempMat INCLUDE \"sparse_includes/PairwiseMultiplyMatrix.f90\" END SUBROUTINE PairwiseMultiplyMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply two matrices. !> This will utilize the sparse vector pairwise routine. PURE SUBROUTINE PairwiseMultiplyMatrix_lsc ( matA , matB , matC ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !! Local Variables TYPE ( Matrix_lsc ) :: TempMat INCLUDE \"sparse_includes/PairwiseMultiplyMatrix.f90\" END SUBROUTINE PairwiseMultiplyMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Product = sum(MatA[ij]*MatB[ij]) PURE SUBROUTINE DotMatrix_lsr ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> Dot product. REAL ( NTREAL ), INTENT ( OUT ) :: product !! Local Variables TYPE ( Matrix_lsr ) :: matC CALL PairwiseMultiplyMatrix ( matA , matB , matC ) CALL MatrixGrandSum ( matC , product ) CALL DestructMatrix ( matC ) END SUBROUTINE DotMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PURE SUBROUTINE DotMatrix_lsc ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> Dot product. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: product !! Local Variables TYPE ( Matrix_lsc ) :: matC TYPE ( Matrix_lsc ) :: matAH CALL CopyMatrix ( matA , matAH ) CALL ConjugateMatrix ( matAH ) CALL PairwiseMultiplyMatrix ( matAH , matB , matC ) CALL MatrixGrandSum ( matC , product ) CALL DestructMatrix ( matC ) CALL DestructMatrix ( matAH ) END SUBROUTINE DotMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*op( matB ) + beta*matC !! @param[inout] blocked_memory_pool_in SUBROUTINE GemmMatrix_lsr ( matA , matB , matC , IsATransposed_in , IsBTransposed_in , & & alpha_in , beta_in , threshold_in , blocked_memory_pool_in ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !> Scales the multiplication. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> An optional memory pool for doing the calculation. TYPE ( MatrixMemoryPool_lr ), OPTIONAL , & & INTENT ( INOUT ), TARGET :: blocked_memory_pool_in !! Intermediate Data TYPE ( Matrix_lsr ) :: matAB LOGICAL :: IsATransposed , IsBTransposed REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_lr ) :: blocked_memory_pool INCLUDE \"sparse_includes/GemmMatrix.f90\" END SUBROUTINE GemmMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*op( matB ) + beta*matC SUBROUTINE GemmMatrix_lsc ( matA , matB , matC , IsATransposed_in , & & IsBTransposed_in , alpha_in , beta_in , threshold_in , & & blocked_memory_pool_in ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !> Scales the multiplication. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> An optional memory pool for doing the calculation. TYPE ( MatrixMemoryPool_lc ), OPTIONAL , & & INTENT ( INOUT ), TARGET :: blocked_memory_pool_in !! Intermediate Data TYPE ( Matrix_lsc ) :: matAB LOGICAL :: IsATransposed , IsBTransposed REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_lc ) :: blocked_memory_pool INCLUDE \"sparse_includes/GemmMatrix.f90\" END SUBROUTINE GemmMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a sparse matrix along the columns. PURE SUBROUTINE MatrixColumnNorm_lsr ( this , norm_per_column ) !> The matrix to compute the norm of. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The norm value for each column in this matrix. REAL ( NTREAL ), DIMENSION ( this % columns ), INTENT ( OUT ) :: norm_per_column !! Local Data REAL ( NTREAL ) :: temp_value INCLUDE \"sparse_includes/MatrixColumnNorm.f90\" END SUBROUTINE MatrixColumnNorm_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a sparse matrix along the columns. PURE SUBROUTINE MatrixColumnNorm_lsc ( this , norm_per_column ) !> The matrix to compute the norm of. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The norm value for each column in this matrix. REAL ( NTREAL ), DIMENSION ( this % columns ), INTENT ( OUT ) :: norm_per_column !! Local Data COMPLEX ( NTCOMPLEX ) :: temp_value INCLUDE \"sparse_includes/MatrixColumnNorm.f90\" END SUBROUTINE MatrixColumnNorm_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the 1 norm of a sparse matrix. PURE FUNCTION MatrixNorm_lsr ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables REAL ( NTREAL ), DIMENSION ( this % columns ) :: column INCLUDE \"sparse_includes/MatrixNorm.f90\" END FUNCTION MatrixNorm_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the 1 norm of a sparse matrix. PURE FUNCTION MatrixNorm_lsc ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables REAL ( NTREAL ), DIMENSION ( this % columns ) :: column INCLUDE \"sparse_includes/MatrixNorm.f90\" END FUNCTION MatrixNorm_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum the elements of a matrix PURE SUBROUTINE MatrixGrandSum_lsr ( this , sum_value ) !> The matrix to sum TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The sum of the matrix elements REAL ( NTREAL ), INTENT ( OUT ) :: sum_value INCLUDE \"sparse_includes/MatrixGrandSum.f90\" END SUBROUTINE MatrixGrandSum_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum the elements of a matrix PURE SUBROUTINE MatrixGrandSum_lsc ( this , sum_value ) !> The matrix to sum TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The sum of the matrix elements COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: sum_value INCLUDE \"sparse_includes/MatrixGrandSum.f90\" END SUBROUTINE MatrixGrandSum_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculates the matrix product if we've determined to do sparse-sparse. PURE SUBROUTINE SparseBranch_lsr ( matA , matB , matC , IsATransposed , & & IsBTransposed , alpha , threshold , blocked_memory_pool ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Memory pool. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: blocked_memory_pool !! Local Data TYPE ( Matrix_lsr ) :: matAT , matBT INCLUDE \"sparse_includes/SparseBranch.f90\" END SUBROUTINE SparseBranch_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculates the matrix product if we've determined to do sparse-sparse. PURE SUBROUTINE SparseBranch_lsc ( matA , matB , matC , IsATransposed , & & IsBTransposed , alpha , threshold , blocked_memory_pool ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Memory pool. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: blocked_memory_pool !! Local Data TYPE ( Matrix_lsc ) :: matAT , matBT INCLUDE \"sparse_includes/SparseBranch.f90\" END SUBROUTINE SparseBranch_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate the matrix product if we've determined to do dense-dense. SUBROUTINE DenseBranch_lsr ( matA , matB , matC , IsATransposed , IsBTransposed , & & alpha , threshold ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( Matrix_lsr ) :: untransposedMatA TYPE ( Matrix_lsr ) :: untransposedMatB TYPE ( Matrix_ldr ) :: DenseA TYPE ( Matrix_ldr ) :: DenseB TYPE ( Matrix_ldr ) :: DenseC INCLUDE \"sparse_includes/DenseBranch.f90\" END SUBROUTINE DenseBranch_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate the matrix product if we've determined to do dense-dense. SUBROUTINE DenseBranch_lsc ( matA , matB , matC , IsATransposed , IsBTransposed , & & alpha , threshold ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( Matrix_lsc ) :: untransposedMatA TYPE ( Matrix_lsc ) :: untransposedMatB TYPE ( Matrix_ldc ) :: DenseA TYPE ( Matrix_ldc ) :: DenseB TYPE ( Matrix_ldc ) :: DenseC INCLUDE \"sparse_includes/DenseBranch.f90\" END SUBROUTINE DenseBranch_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiplies a single block fo sparse-sparse. PURE SUBROUTINE MultiplyBlock_lsr ( matAT , matBT , memorypool ) !> Matrix A, already transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matAT !> Matrix B, already transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matBT !> Memory pool to multiply into. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: memorypool !! Temp Variables REAL ( NTREAL ) :: temp_value_a , temp_value_b , temp_value_c INCLUDE \"sparse_includes/MultiplyBlock.f90\" END SUBROUTINE MultiplyBlock_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiplies a single block fo sparse-sparse. PURE SUBROUTINE MultiplyBlock_lsc ( matAT , matBT , memorypool ) !> Matrix A, already transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matAT !> Matrix B, already transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matBT !> Memory pool to multiply into. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: memorypool !! Temp Variables COMPLEX ( NTCOMPLEX ) :: temp_value_a , temp_value_b , temp_value_c INCLUDE \"sparse_includes/MultiplyBlock.f90\" END SUBROUTINE MultiplyBlock_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prunes out the values of the hash table into the matrix. PURE SUBROUTINE PruneList_lsr ( memorypool , alpha , threshold , mat_c_columns , & & mat_c_rows , matAB ) !> Memory pool to prune from. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: memorypool !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values to zero. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Size of the matrix we computed (columns). INTEGER , INTENT ( IN ) :: mat_c_columns !> Size of the matrix we computed (rows). INTEGER , INTENT ( IN ) :: mat_c_rows !> Sparse matrix to prune out into. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matAB !! Local data REAL ( NTREAL ) :: working_value TYPE ( TripletList_r ) :: unsorted_pruned_list TYPE ( TripletList_r ) :: sorted_pruned_list INCLUDE \"sparse_includes/PruneList.f90\" END SUBROUTINE PruneList_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prunes out the values of the hash table into the matrix. PURE SUBROUTINE PruneList_lsc ( memorypool , alpha , threshold , & & mat_c_columns , mat_c_rows , matAB ) !> Memory pool to prune from. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: memorypool !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values to zero. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Size of the matrix we computed (columns). INTEGER , INTENT ( IN ) :: mat_c_columns !> Size of the matrix we computed (rows). INTEGER , INTENT ( IN ) :: mat_c_rows !> Sparse matrix to prune out into. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matAB !! Local data COMPLEX ( NTCOMPLEX ) :: working_value TYPE ( TripletList_c ) :: unsorted_pruned_list TYPE ( TripletList_c ) :: sorted_pruned_list INCLUDE \"sparse_includes/PruneList.f90\" END SUBROUTINE PruneList_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SMatrixAlgebraModule","tags":"","loc":"sourcefile/smatrixalgebramodule.f90.html"},{"title":"EigenBoundsModule.F90 – NTPoly","text":"Contents Modules EigenBoundsModule Source Code EigenBoundsModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing estimates of the bounds of a matrix's spectrum. MODULE EigenBoundsModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteListElement , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , DotMatrix , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , GetMatrixTripletList , FillMatrixFromTripletList USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & AppendToTripletList , DestructTripletList USE TripletModule , ONLY : Triplet_r USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: GershgorinBounds PUBLIC :: PowerBounds CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a bounds on the minimum and maximum eigenvalue of a matrix. !> Uses Gershgorin's theorem. SUBROUTINE GershgorinBounds ( this , min_value , max_value ) !> The matrix to compute the min/max of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> A lower bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: min_value !> An uppder bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: max_value !! Local Data TYPE ( TripletList_r ) :: triplet_list_r TYPE ( TripletList_c ) :: triplet_list_c !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: per_column_min REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: per_column_max !! Counters/Temporary INTEGER :: counter INTEGER :: local_column INTEGER :: ierr IF ( this % is_complex ) THEN #define triplet_list triplet_list_c #include \"solver_includes/GershgorinBounds.f90\" #undef triplet_list ELSE #define triplet_list triplet_list_r #include \"solver_includes/GershgorinBounds.f90\" #undef triplet_list END IF END SUBROUTINE GershgorinBounds !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a bounds on the maximum eigenvalue of a matrix. !> Uses The Power Method. SUBROUTINE PowerBounds ( this , max_value , solver_parameters_in ) !> The matrix to compute the min/max of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> An upper bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: max_value !> The parameters for this calculation. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Data TYPE ( Matrix_ps ) :: vector , vector2 , TempMat REAL ( NTREAL ) :: scale_value REAL ( NTREAL ) :: norm_value TYPE ( TripletList_r ) :: temp_list TYPE ( Triplet_r ) :: temp_triplet INTEGER :: outer_counter TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () solver_parameters % max_iterations = 10 END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Power Bounds Solver\" ) CALL EnterSubLog CALL PrintParameters ( solver_parameters ) END IF !! Diagonal matrices serve as vectors. CALL ConstructEmptyMatrix ( vector , this ) CALL ConstructEmptyMatrix ( vector2 , this ) !! Guess Vector temp_list = TripletList_r () IF ( this % process_grid % global_rank . EQ . 0 ) THEN temp_triplet % index_row = 1 temp_triplet % index_column = 1 temp_triplet % point_value = 1.0_NTREAL CALL AppendToTripletList ( temp_list , temp_triplet ) END IF CALL FillMatrixFromTripletList ( vector , temp_list ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF !! x = Ax CALL MatrixMultiply ( this , vector , vector2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! x = x/||x|| scale_value = 1.0 / MatrixNorm ( vector2 ) CALL ScaleMatrix ( vector2 , scale_value ) !! Check if Converged CALL IncrementMatrix ( vector2 , vector , - 1.0_NTREAL ) norm_value = MatrixNorm ( vector ) CALL CopyMatrix ( vector2 , vector ) IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) END IF !! Compute The Largest Eigenvalue CALL DotMatrix ( vector , vector , scale_value ) CALL MatrixMultiply ( this , vector , vector2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL DotMatrix ( vector , vector2 , max_value ) max_value = max_value / scale_value IF ( solver_parameters % be_verbose ) THEN CALL WriteElement ( key = \"Max_Eigen_Value\" , value = max_value ) CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( vector ) CALL DestructMatrix ( vector2 ) CALL DestructMatrix ( TempMat ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE PowerBounds !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE EigenBoundsModule","tags":"","loc":"sourcefile/eigenboundsmodule.f90.html"},{"title":"PolynomialSolversModule.F90 – NTPoly","text":"Contents Modules PolynomialSolversModule Source Code PolynomialSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing General Matrix Polynomials. MODULE PolynomialSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteCitation , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , DestructMatrix , FillMatrixIdentity , & & ConstructEmptyMatrix , CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a polynomial. TYPE , PUBLIC :: Polynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE Polynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute PUBLIC :: FactorizedCompute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_stand END INTERFACE INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_stand END INTERFACE INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_stand END INTERFACE INTERFACE Compute MODULE PROCEDURE Compute_stand END INTERFACE INTERFACE FactorizedCompute MODULE PROCEDURE FactorizedCompute_stand END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a polynomial. PURE SUBROUTINE ConstructPolynomial_stand ( this , degree ) !> The polynomial to construct. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this !> The degree of the polynomial. INTEGER , INTENT ( IN ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0 END SUBROUTINE ConstructPolynomial_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a polynomial object. PURE SUBROUTINE DestructPolynomial_stand ( this ) !> The polynomial to destruct. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set coefficient of a polynomial. SUBROUTINE SetCoefficient_stand ( this , degree , coefficient ) !> The polynomial to set. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this !> Degree for which to set the coefficient. INTEGER , INTENT ( IN ) :: degree !> Coefficient value. REAL ( NTREAL ), INTENT ( IN ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute A Matrix Polynomial Using Horner's Method. SUBROUTINE Compute_stand ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Polynomial to compute. TYPE ( Polynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Temporary INTEGER :: degree INTEGER :: counter TYPE ( MatrixMemoryPool_p ) :: pool !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF degree = SIZE ( poly % coefficients ) IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Polynomial Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Horner\" ) CALL PrintParameters ( solver_parameters ) CALL WriteElement ( key = \"Degree\" , value = degree - 1 ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL ConstructEmptyMatrix ( Temporary , InputMat ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF CALL CopyMatrix ( Identity , OutputMat ) IF ( SIZE ( poly % coefficients ) . EQ . 1 ) THEN CALL ScaleMatrix ( OutputMat , poly % coefficients ( degree )) ELSE CALL ScaleMatrix ( OutputMat , poly % coefficients ( degree - 1 )) CALL IncrementMatrix ( BalancedInput , OutputMat , & & poly % coefficients ( degree )) DO counter = degree - 2 , 1 , - 1 CALL MatrixMultiply ( BalancedInput , OutputMat , Temporary , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temporary , OutputMat ) CALL IncrementMatrix ( Identity , & & OutputMat , alpha_in = poly % coefficients ( counter )) END DO END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Temporary ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE Compute_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute A Matrix Polynomial Using Paterson and Stockmeyer's method. !> This method first factors the polynomial to reduce the number of !> matrix multiplies required. SUBROUTINE FactorizedCompute_stand ( InputMat , OutputMat , poly , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The polynomial to compute. TYPE ( Polynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ), DIMENSION (:), ALLOCATABLE :: x_powers TYPE ( Matrix_ps ) :: Bk TYPE ( Matrix_ps ) :: Xs TYPE ( Matrix_ps ) :: Temp INTEGER :: degree INTEGER :: m_value , s_value , r_value INTEGER :: k_value INTEGER :: counter INTEGER :: c_index TYPE ( MatrixMemoryPool_p ) :: pool !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF !! Parameters for splitting up polynomial. degree = SIZE ( poly % coefficients ) m_value = degree - 1 s_value = INT ( SQRT ( REAL ( m_value ))) r_value = m_value / s_value IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Polynomial Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Paterson Stockmeyer\" ) CALL WriteCitation ( \"paterson1973number\" ) CALL PrintParameters ( solver_parameters ) CALL WriteElement ( key = \"Degree\" , value = degree - 1 ) END IF ALLOCATE ( x_powers ( s_value + 1 )) !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) !! Create the X Powers CALL ConstructEmptyMatrix ( x_powers ( 1 ), InputMat ) CALL FillMatrixIdentity ( x_powers ( 1 )) DO counter = 1 , s_value + 1 - 1 CALL MatrixMultiply ( InputMat , x_powers ( counter - 1 + 1 ), x_powers ( counter + 1 ),& & memory_pool_in = pool ) END DO CALL CopyMatrix ( x_powers ( s_value + 1 ), Xs ) !! S_k = bmX CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , poly % coefficients ( s_value * r_value + 1 )) DO counter = 1 , m_value - s_value * r_value + 1 - 1 c_index = s_value * r_value + counter CALL IncrementMatrix ( x_powers ( counter + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL MatrixMultiply ( Bk , Xs , OutputMat , memory_pool_in = pool ) !! S_k += bmx + bm-1I k_value = r_value - 1 CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , poly % coefficients ( s_value * k_value + 1 )) DO counter = 1 , s_value - 1 + 1 - 1 c_index = s_value * k_value + counter CALL IncrementMatrix ( x_powers ( counter + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL IncrementMatrix ( Bk , OutputMat ) !! Loop over the rest. DO k_value = r_value - 2 , - 1 + 1 , - 1 CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , & & poly % coefficients ( s_value * k_value + 1 )) DO counter = 1 , s_value - 1 + 1 - 1 c_index = s_value * k_value + counter CALL IncrementMatrix ( x_powers ( counter + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL MatrixMultiply ( Xs , OutputMat , Temp ) CALL CopyMatrix ( Temp , OutputMat ) CALL IncrementMatrix ( Bk , OutputMat ) END DO !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF DO counter = 1 , s_value + 1 CALL DestructMatrix ( x_powers ( counter )) END DO DEALLOCATE ( x_powers ) CALL DestructMatrix ( Bk ) CALL DestructMatrix ( Xs ) CALL DestructMatrix ( Temp ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE FactorizedCompute_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PolynomialSolversModule","tags":"","loc":"sourcefile/polynomialsolversmodule.f90.html"},{"title":"DMatrixModule.F90 – NTPoly","text":"Contents Modules DMatrixModule Source Code DMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module allows one to convert a sparse matrix to a dense matrix. It also !! supports dense the dense versions of core matrix routines. This module is !! used in situations where matrices become too dense for good sparse matrix !! performance. MODULE DMatrixModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & AppendToTripletList , ConstructTripletList USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a dense matrix. TYPE , PUBLIC :: Matrix_ldr REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: DATA !< values of the matrix. INTEGER :: rows !< Matrix dimension: rows. INTEGER :: columns !< Matrix dimension: columns. END TYPE Matrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a dense matrix. TYPE , PUBLIC :: Matrix_ldc !> values of the matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: DATA INTEGER :: rows !< Matrix dimension: rows. INTEGER :: columns !< Matrix dimension: columns. END TYPE Matrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructEmptyMatrix PUBLIC :: ConstructMatrixDFromS PUBLIC :: ConstructMatrixSFromD PUBLIC :: CopyMatrix PUBLIC :: DestructMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SplitMatrix PUBLIC :: ComposeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MatrixNorm PUBLIC :: IncrementMatrix PUBLIC :: MultiplyMatrix PUBLIC :: TransposeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE Matrix_ldr MODULE PROCEDURE ConstructEmptyMatrix_ldr END INTERFACE INTERFACE Matrix_ldc MODULE PROCEDURE ConstructEmptyMatrix_ldc END INTERFACE INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrixSup_ldr MODULE PROCEDURE ConstructEmptyMatrixSup_ldc END INTERFACE INTERFACE ConstructMatrixDFromS MODULE PROCEDURE ConstructMatrixDFromS_ldr MODULE PROCEDURE ConstructMatrixDFromS_ldc END INTERFACE INTERFACE ConstructMatrixSFromD MODULE PROCEDURE ConstructMatrixSFromD_ldr MODULE PROCEDURE ConstructMatrixSFromD_ldc END INTERFACE INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_ldr MODULE PROCEDURE CopyMatrix_ldc END INTERFACE INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_ldr MODULE PROCEDURE DestructMatrix_ldc END INTERFACE INTERFACE SplitMatrix MODULE PROCEDURE SplitMatrix_ldr MODULE PROCEDURE SplitMatrix_ldc END INTERFACE INTERFACE ComposeMatrix MODULE PROCEDURE ComposeMatrix_ldr MODULE PROCEDURE ComposeMatrix_ldc END INTERFACE INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_ldr MODULE PROCEDURE MatrixNorm_ldc END INTERFACE INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_ldr MODULE PROCEDURE IncrementMatrix_ldc END INTERFACE INTERFACE MultiplyMatrix MODULE PROCEDURE MultiplyMatrix_ldr MODULE PROCEDURE MultiplyMatrix_ldc END INTERFACE INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_ldr MODULE PROCEDURE TransposeMatrix_ldc END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the empty constructor. PURE SUBROUTINE ConstructEmptyMatrixSup_ldr ( this , rows , columns ) !> The matrix to construct TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: this !> Rows of the matrix INTEGER , INTENT ( IN ) :: rows !> Columns of the matrix INTEGER , INTENT ( IN ) :: columns this = ConstructEmptyMatrix_ldr ( rows , columns ) END SUBROUTINE ConstructEmptyMatrixSup_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty dense matrix with a set number of rows and columns PURE FUNCTION ConstructEmptyMatrix_ldr ( rows , columns ) RESULT ( this ) !> The matrix to construct. TYPE ( Matrix_ldr ) :: this !> Rows of the matrix INTEGER , INTENT ( IN ) :: rows !> Columns of the matrix. INTEGER , INTENT ( IN ) :: columns INCLUDE \"dense_includes/ConstructEmptyMatrix.f90\" END FUNCTION ConstructEmptyMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a sparse matrix to a dense matrix. PURE SUBROUTINE ConstructMatrixDFromS_ldr ( sparse_matrix , dense_matrix ) !> The sparse matrix to convert. TYPE ( Matrix_lsr ), INTENT ( IN ) :: sparse_matrix !> Output. Must be preallocated. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: dense_matrix !! Helper Variables TYPE ( Triplet_r ) :: temporary #include \"dense_includes/ConstructMatrixDFromS.f90\" END SUBROUTINE ConstructMatrixDFromS_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a dense matrix to a sparse matrix. PURE SUBROUTINE ConstructMatrixSFromD_ldr ( dense_matrix , sparse_matrix , & & threshold_in ) !> Matrix to convert. TYPE ( Matrix_ldr ), INTENT ( IN ) :: dense_matrix !> Output matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: sparse_matrix !> Value for pruning values to zero. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Local Variables TYPE ( Triplet_r ) :: temporary TYPE ( TripletList_r ) :: temporary_list #define SMTYPE Matrix_lsr #include \"dense_includes/ConstructMatrixSFromD.f90\" #undef SMTYPE END SUBROUTINE ConstructMatrixSFromD_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy the matrix A into the B. PURE SUBROUTINE CopyMatrix_ldr ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ldr ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: matB #include \"dense_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocate the memory associated with this matrix. PURE SUBROUTINE DestructMatrix_ldr ( this ) !> The matrix to delete. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: this INCLUDE \"dense_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> AXPY for dense matrices. B = B + alpha*A PURE SUBROUTINE IncrementMatrix_ldr ( MatA , MatB , alpha_in ) !> MatA is added TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatA !> MatB is incremented. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: MatB !> A scaling parameter. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !! Temporary REAL ( NTREAL ) :: alpha INCLUDE \"dense_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a dense matrix. !> Computes the Frobenius norm. FUNCTION MatrixNorm_ldr ( this ) RESULT ( norm ) !! Parameters !> The matrix to compute the norm of. TYPE ( Matrix_ldr ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm INTEGER :: II , JJ norm = 0 DO II = 1 , this % rows DO JJ = 1 , this % columns norm = norm + this % data ( II , JJ ) ** 2 END DO END DO END FUNCTION MatrixNorm_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a dense matrix. PURE SUBROUTINE TransposeMatrix_ldr ( matA , matAT ) !> matA the matrix to transpose. TYPE ( Matrix_ldr ), INTENT ( IN ) :: matA !> matAT = matA&#94;T. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: matAT #include \"dense_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_ldr ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_ldr ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: out_matrix #include \"dense_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_ldr ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !! Parameters !> The matrix to split. TYPE ( Matrix_ldr ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A block_columns x block_rows array for the output to go into. TYPE ( Matrix_ldr ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in #include \"dense_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A wrapper for multiplying two dense matrices. SUBROUTINE MultiplyMatrix_ldr ( MatA , MatB , MatC ) !> The first matrix. TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatA !> The second matrix. TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatB !> MatC = MatA*MatB. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: MatC !! Local variables CHARACTER , PARAMETER :: TRANSA = 'N' CHARACTER , PARAMETER :: TRANSB = 'N' INTEGER :: M INTEGER :: N INTEGER :: K DOUBLE PRECISION , PARAMETER :: ALPHA = 1.0 INTEGER :: LDA INTEGER :: LDB DOUBLE PRECISION , PARAMETER :: BETA = 0.0 INTEGER :: LDC MatC = Matrix_ldr ( MatA % rows , MatB % columns ) !! Setup Lapack M = MatA % rows N = MatB % columns K = MatA % columns LDA = M LDB = K LDC = M CALL DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , MatA % data , LDA , MatB % data , & & LDB , BETA , MatC % data , LDC ) END SUBROUTINE MultiplyMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine style wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSup_ldc ( this , rows , columns ) !> The matrix to construct. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: this !> The number of rows of the matrix. INTEGER , INTENT ( IN ) :: rows !> The number of columns o the matrix. INTEGER , INTENT ( IN ) :: columns this = ConstructEmptyMatrix_ldc ( rows , columns ) END SUBROUTINE ConstructEmptyMatrixSup_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty dense matrix with a set number of rows and columns PURE FUNCTION ConstructEmptyMatrix_ldc ( rows , columns ) RESULT ( this ) !> The matrix to construct. TYPE ( Matrix_ldc ) :: this !> Rows of the matrix INTEGER , INTENT ( IN ) :: rows !> Columns of the matrix. INTEGER , INTENT ( IN ) :: columns INCLUDE \"dense_includes/ConstructEmptyMatrix.f90\" END FUNCTION ConstructEmptyMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a sparse matrix to a dense matrix. PURE SUBROUTINE ConstructMatrixDFromS_ldc ( sparse_matrix , dense_matrix ) !> The sparse matrix to convert. TYPE ( Matrix_lsc ), INTENT ( IN ) :: sparse_matrix !> Dense matrix output. Must be preallocated. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: dense_matrix !! Helper Variables TYPE ( Triplet_c ) :: temporary #include \"dense_includes/ConstructMatrixDFromS.f90\" END SUBROUTINE ConstructMatrixDFromS_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a dense matrix to a sparse matrix. PURE SUBROUTINE ConstructMatrixSFromD_ldc ( dense_matrix , sparse_matrix , & & threshold_in ) !! Parameters !> The matrix to convert. TYPE ( Matrix_ldc ), INTENT ( IN ) :: dense_matrix !> The sparse output matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: sparse_matrix !> Value for pruning values to zero. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Local Variables TYPE ( Triplet_c ) :: temporary TYPE ( TripletList_c ) :: temporary_list #define SMTYPE Matrix_lsc #include \"dense_includes/ConstructMatrixSFromD.f90\" #undef SMTYPE END SUBROUTINE ConstructMatrixSFromD_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy the matrix A into the B. PURE SUBROUTINE CopyMatrix_ldc ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ldc ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: matB #include \"dense_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocate the memory associated with this matrix. PURE SUBROUTINE DestructMatrix_ldc ( this ) !> This the matrix to delete. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: this INCLUDE \"dense_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> AXPY for dense matrices. B = B + alpha*A PURE SUBROUTINE IncrementMatrix_ldc ( MatA , MatB , alpha_in ) !> MatA is added TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatA !> MatB is incremented. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: MatB !> A scaling parameter. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !! Temporary REAL ( NTREAL ) :: alpha INCLUDE \"dense_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a dense matrix. !> Computes the Frobenius norm. FUNCTION MatrixNorm_ldc ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_ldc ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables INTEGER :: II , JJ norm = 0 DO II = 1 , this % rows DO JJ = 1 , this % columns norm = norm + & & REAL ( this % data ( II , JJ ) * CONJG ( this % data ( II , JJ )), KIND = NTREAL ) END DO END DO END FUNCTION MatrixNorm_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a dense matrix. PURE SUBROUTINE TransposeMatrix_ldc ( matA , matAT ) !> The matrix to transpose. TYPE ( Matrix_ldc ), INTENT ( IN ) :: matA !> matAT = matA&#94;T. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: matAT #include \"dense_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_ldc ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_ldc ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: out_matrix #include \"dense_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_ldc ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_ldc ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_ldc ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in #include \"dense_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A wrapper for multiplying two dense matrices. SUBROUTINE MultiplyMatrix_ldc ( MatA , MatB , MatC ) !> The first matrix. TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatA !> The second matrix. TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatB !> MatC = MatA*MatB. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: MatC !! Local variables CHARACTER , PARAMETER :: TRANSA = 'N' CHARACTER , PARAMETER :: TRANSB = 'N' INTEGER :: M INTEGER :: N INTEGER :: K COMPLEX * 16 , PARAMETER :: ALPHA = 1.0 INTEGER :: LDA INTEGER :: LDB COMPLEX * 16 , PARAMETER :: BETA = 0.0 INTEGER :: LDC MatC = Matrix_ldc ( MatA % rows , MatB % columns ) !! Setup Lapack M = MatA % rows N = MatB % columns K = MatA % columns LDA = M LDB = K LDC = M CALL ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , MatA % data , LDA , MatB % data , & & LDB , BETA , MatC % data , LDC ) END SUBROUTINE MultiplyMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DMatrixModule","tags":"","loc":"sourcefile/dmatrixmodule.f90.html"},{"title":"MatrixMarketModule.F90 – NTPoly","text":"Contents Modules MatrixMarketModule Source Code MatrixMarketModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module contains helpers for processing matrix market files. MODULE MatrixMarketModule IMPLICIT NONE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Sparse coordinate file. ENUMERATOR :: MM_COORDINATE = 1 !> Dense array file. ENUMERATOR :: MM_ARRAY = 2 !> Real data being read in. ENUMERATOR :: MM_REAL = 1 !> Integer data being read in. ENUMERATOR :: MM_INTEGER = 2 !>Complex numbers being read in. ENUMERATOR :: MM_COMPLEX = 3 !> Just a pattern of non zeros. ENUMERATOR :: MM_PATTERN = 4 !> File lacks symmetry. ENUMERATOR :: MM_GENERAL = 1 !> File is symmetric ENUMERATOR :: MM_SYMMETRIC = 2 !> File is skew symmetric. ENUMERATOR :: MM_SKEW_SYMMETRIC = 3 !> File is hermitian. ENUMERATOR :: MM_HERMITIAN = 4 END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ParseMMHeader CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Parse a matrix market header. FUNCTION ParseMMHeader ( line , sparsity_type , data_type , pattern_type ) & & RESULT ( no_error ) !> String to parse. CHARACTER ( len =* ), INTENT ( IN ) :: line !> If coordinate or array type. INTEGER , INTENT ( OUT ) :: sparsity_type !> If real, integer, complex, pattern. INTEGER , INTENT ( OUT ) :: data_type !> If general, symmetric, skew_symmetric, hermitian. INTEGER , INTENT ( OUT ) :: pattern_type !> True if no errors. LOGICAL :: no_error !! Local Data INTEGER :: pos1 , pos2 no_error = . TRUE . !! This part is just \"MatrixMarket\". pos1 = 1 pos2 = INDEX ( line ( pos1 :), ' ' ) !! This part is just \"matrix\". pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) !! This part is coordinate or array. pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) SELECT CASE ( TRIM ( line ( pos1 : pos1 + pos2 - 1 ))) CASE ( 'coordinate' ) sparsity_type = MM_COORDINATE CASE ( 'array' ) sparsity_type = MM_ARRAY CASE DEFAULT no_error = . FALSE . END SELECT !! This part is real, integer, complex, pattern. pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) SELECT CASE ( TRIM ( line ( pos1 : pos1 + pos2 - 1 ))) CASE ( 'real' ) data_type = MM_REAL CASE ( 'array' ) data_type = MM_INTEGER CASE ( 'complex' ) data_type = MM_COMPLEX CASE ( 'pattern' ) data_type = MM_PATTERN CASE DEFAULT no_error = . FALSE . END SELECT !! This part is general, symmetric, skew-symmetric, hermitian. pos1 = pos2 + pos1 SELECT CASE ( TRIM ( line ( pos1 :))) CASE ( 'general' ) pattern_type = MM_GENERAL CASE ( 'symmetric' ) pattern_type = MM_SYMMETRIC CASE ( 'skew-symmetric' ) pattern_type = MM_SKEW_SYMMETRIC CASE ( 'hermitian' ) pattern_type = MM_HERMITIAN CASE DEFAULT no_error = . FALSE . END SELECT END FUNCTION ParseMMHeader !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMarketModule","tags":"","loc":"sourcefile/matrixmarketmodule.f90.html"},{"title":"PSMatrixModule.F90 – NTPoly","text":"Contents Modules PSMatrixModule Source Code PSMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Performing Distributed Sparse Matrix Operations. MODULE PSMatrixModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER USE ErrorModule , ONLY : Error_t , ConstructError , SetGenericError , & & CheckMPIError USE LoggingModule , ONLY : & & EnterSubLog , ExitSubLog , WriteElement , WriteListElement , WriteHeader USE MatrixMarketModule , ONLY : ParseMMHeader , MM_COMPLEX USE PermutationModule , ONLY : Permutation_t , ConstructDefaultPermutation USE ProcessGridModule , ONLY : ProcessGrid_t , global_grid , IsRoot , & & SplitProcessGrid USE MatrixReduceModule , ONLY : ReduceHelper_t , ReduceAndComposeMatrixSizes , & & ReduceAndComposeMatrixData , ReduceAndComposeMatrixCleanup , & & ReduceANdSumMatrixSizes , ReduceAndSumMatrixData , & & ReduceAndSumMatrixCleanup , TestReduceSizeRequest , & & TestReduceInnerRequest , TestReduceDataRequest USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , & & PrintMatrix , TransposeMatrix , ConjugateMatrix , SplitMatrix , & & ComposeMatrix , ConvertMatrixType , MatrixToTripletList , & & ConstructMatrixFromTripletList USE TimerModule , ONLY : StartTimer , StopTimer USE TripletModule , ONLY : Triplet_r , Triplet_c , GetMPITripletType_r , & & GetMPITripletType_c USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & ConstructTripletList , & & DestructTripletList , SortTripletList , AppendToTripletList , & & SymmetrizeTripletList , GetTripletAt , RedistributeTripletLists , & & ShiftTripletList USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for a distributed blocked CSR matrix. TYPE , PUBLIC :: Matrix_ps !> Number of matrix rows/columns for full matrix, scaled for process grid. INTEGER :: logical_matrix_dimension !> Number of matrix rows/columns for the full matrix, unscaled. INTEGER :: actual_matrix_dimension !! Local Storage !> A 2D array of local CSR matrices. TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: local_data_r !> A 2D array of local CSC matrices. TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: local_data_c INTEGER :: start_column !< first column stored locally. INTEGER :: end_column !< last column stored locally  is less than this. INTEGER :: start_row !< first row stored locally. INTEGER :: end_row !< last row stored locally is less than this. INTEGER :: local_columns !< number of local columns. INTEGER :: local_rows !< number of local rows. TYPE ( ProcessGrid_t ), POINTER :: process_grid !< process grid to operate on LOGICAL :: is_complex !< true if the matrix data is true. END TYPE Matrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Constructors/Destructors PUBLIC :: ConstructEmptyMatrix PUBLIC :: DestructMatrix PUBLIC :: CopyMatrix PUBLIC :: SetMatrixProcessGrid !! File I/O PUBLIC :: ConstructMatrixFromMatrixMarket PUBLIC :: ConstructMatrixFromBinary PUBLIC :: WriteMatrixToMatrixMarket PUBLIC :: WriteMatrixToBinary !! Fill In Special Matrices PUBLIC :: FillMatrixFromTripletList PUBLIC :: FillMatrixIdentity PUBLIC :: FillMatrixPermutation !! Basic Accessors PUBLIC :: GetMatrixActualDimension PUBLIC :: GetMatrixLogicalDimension PUBLIC :: GetMatrixTripletList PUBLIC :: GetMatrixBlock PUBLIC :: GetMatrixSlice !! Printing To The Console PUBLIC :: PrintMatrix PUBLIC :: PrintMatrixInformation !! Utilities PUBLIC :: ConvertMatrixToReal PUBLIC :: ConvertMatrixToComplex PUBLIC :: GetMatrixLoadBalance PUBLIC :: GetMatrixSize PUBLIC :: FilterMatrix PUBLIC :: MergeMatrixLocalBlocks PUBLIC :: SplitMatrixToLocalBlocks PUBLIC :: TransposeMatrix PUBLIC :: ConjugateMatrix PUBLIC :: CommSplitMatrix PUBLIC :: ResizeMatrix PUBLIC :: GatherMatrixToProcess !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrix_ps MODULE PROCEDURE ConstructEmptyMatrix_ps_cp END INTERFACE INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_ps END INTERFACE INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_ps END INTERFACE INTERFACE ConstructMatrixFromMatrixMarket MODULE PROCEDURE ConstructMatrixFromMatrixMarket_ps END INTERFACE INTERFACE ConstructMatrixFromBinary MODULE PROCEDURE ConstructMatrixFromBinary_ps END INTERFACE INTERFACE WriteMatrixToMatrixMarket MODULE PROCEDURE WriteMatrixToMatrixMarket_ps END INTERFACE INTERFACE WriteMatrixToBinary MODULE PROCEDURE WriteMatrixToBinary_ps END INTERFACE INTERFACE FillMatrixFromTripletList MODULE PROCEDURE FillMatrixFromTripletList_psr MODULE PROCEDURE FillMatrixFromTripletList_psc END INTERFACE INTERFACE FillMatrixIdentity MODULE PROCEDURE FillMatrixIdentity_ps END INTERFACE INTERFACE FillMatrixPermutation MODULE PROCEDURE FillMatrixPermutation_ps END INTERFACE INTERFACE GetMatrixActualDimension MODULE PROCEDURE GetMatrixActualDimension_ps END INTERFACE INTERFACE GetMatrixLogicalDimension MODULE PROCEDURE GetMatrixLogicalDimension_ps END INTERFACE INTERFACE GetMatrixTripletList MODULE PROCEDURE GetMatrixTripletList_psr MODULE PROCEDURE GetMatrixTripletList_psc END INTERFACE INTERFACE GetMatrixBlock MODULE PROCEDURE GetMatrixBlock_psr MODULE PROCEDURE GetMatrixBlock_psc END INTERFACE INTERFACE PrintMatrix MODULE PROCEDURE PrintMatrix_ps END INTERFACE INTERFACE PrintMatrixInformation MODULE PROCEDURE PrintMatrixInformation_ps END INTERFACE INTERFACE GetMatrixLoadBalance MODULE PROCEDURE GetMatrixLoadBalance_ps END INTERFACE INTERFACE GetMatrixSize MODULE PROCEDURE GetMatrixSize_ps END INTERFACE INTERFACE FilterMatrix MODULE PROCEDURE FilterMatrix_ps END INTERFACE INTERFACE RedistributeData MODULE PROCEDURE RedistributeData_psr MODULE PROCEDURE RedistributeData_psc END INTERFACE INTERFACE MergeMatrixLocalBlocks MODULE PROCEDURE MergeMatrixLocalBlocks_psr MODULE PROCEDURE MergeMatrixLocalBlocks_psc END INTERFACE INTERFACE SplitMatrixToLocalBlocks MODULE PROCEDURE SplitMatrixToLocalBlocks_psr MODULE PROCEDURE SplitMatrixToLocalBlocks_psc END INTERFACE INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_ps END INTERFACE INTERFACE ConjugateMatrix MODULE PROCEDURE ConjugateMatrix_ps END INTERFACE INTERFACE CommSplitMatrix MODULE PROCEDURE CommSplitMatrix_ps END INTERFACE INTERFACE GatherMatrixToProcess MODULE PROCEDURE GatherMatrixToProcess_psr MODULE PROCEDURE GatherMatrixToProcess_psc END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty sparse, distributed, matrix. SUBROUTINE ConstructEmptyMatrix_ps ( this , matrix_dim_ , process_grid_in , & & is_complex_in ) !> The matrix to be constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The dimension of the full matrix. INTEGER , INTENT ( IN ) :: matrix_dim_ !> True if you want to use complex numbers. LOGICAL , INTENT ( IN ), OPTIONAL :: is_complex_in !> A process grid to host the matrix. TYPE ( ProcessGrid_t ), INTENT ( IN ), TARGET , OPTIONAL :: process_grid_in !! Local Variables TYPE ( Matrix_lsr ) :: zeromatrix_r TYPE ( Matrix_lsc ) :: zeromatrix_c CALL DestructMatrix ( this ) !! Process Grid IF ( PRESENT ( process_grid_in )) THEN this % process_grid => process_grid_in ELSE this % process_grid => global_grid END IF !! Complex determination IF ( PRESENT ( is_complex_in )) THEN this % is_complex = is_complex_in ELSE this % is_complex = . FALSE . END IF !! Matrix Dimensions this % actual_matrix_dimension = matrix_dim_ this % logical_matrix_dimension = CalculateScaledDimension ( this , matrix_dim_ ) !! Full Local Data Size Description this % local_rows = & & this % logical_matrix_dimension / this % process_grid % num_process_rows this % local_columns = & & this % logical_matrix_dimension / this % process_grid % num_process_columns !! Which Block Does This Process Hold? this % start_row = this % local_rows * this % process_grid % my_row + 1 this % end_row = this % start_row + this % local_rows this % start_column = this % local_columns * this % process_grid % my_column + 1 this % end_column = this % start_column + this % local_columns !! Build local storage IF ( this % is_complex ) THEN ALLOCATE ( this % local_data_c ( this % process_grid % number_of_blocks_rows , & & this % process_grid % number_of_blocks_columns )) zeromatrix_c = Matrix_lsc ( this % local_rows , this % local_columns ) CALL SplitMatrixToLocalBlocks ( this , zeromatrix_c ) CALL DestructMatrix ( zeromatrix_c ) ELSE ALLOCATE ( this % local_data_r ( this % process_grid % number_of_blocks_rows , & & this % process_grid % number_of_blocks_columns )) zeromatrix_r = Matrix_lsr ( this % local_rows , this % local_columns ) CALL SplitMatrixToLocalBlocks ( this , zeromatrix_r ) CALL DestructMatrix ( zeromatrix_r ) END IF END SUBROUTINE ConstructEmptyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty sparse, distributed, matrix using another matrix !> to determine the parameters. Note that no data is copied, the matrix !> will be empty. SUBROUTINE ConstructEmptyMatrix_ps_cp ( this , reference_matrix ) !! Parameters !> The matrix to be constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The reference matrix to take parameters from. TYPE ( Matrix_ps ), INTENT ( IN ) :: reference_matrix CALL ConstructEmptyMatrix ( this , reference_matrix % actual_matrix_dimension , & & reference_matrix % process_grid , reference_matrix % is_complex ) END SUBROUTINE ConstructEmptyMatrix_ps_cp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a distributed sparse matrix. PURE SUBROUTINE DestructMatrix_ps ( this ) !> The matrix to destruct. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data INTEGER :: II , JJ IF ( ALLOCATED ( this % local_data_r )) THEN DO II = 1 , SIZE ( this % local_data_r , DIM = 1 ) DO JJ = 1 , SIZE ( this % local_data_r , DIM = 2 ) CALL DestructMatrix ( this % local_data_r ( II , JJ )) END DO END DO DEALLOCATE ( this % local_data_r ) END IF IF ( ALLOCATED ( this % local_data_c )) THEN DO II = 1 , SIZE ( this % local_data_c , DIM = 1 ) DO JJ = 1 , SIZE ( this % local_data_c , DIM = 2 ) CALL DestructMatrix ( this % local_data_c ( II , JJ )) END DO END DO DEALLOCATE ( this % local_data_c ) END IF END SUBROUTINE DestructMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a distributed sparse matrix in a safe way. SUBROUTINE CopyMatrix_ps ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> matB = matA. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matB CALL DestructMatrix ( matB ) matB = matA END SUBROUTINE CopyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> When you want to change the process grid of a matrix, you can call !> this routine with the new process grid value. Data will be automatically !> redistributed. SUBROUTINE SetMatrixProcessGrid ( this , grid ) !> The matrix to set the grid of. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The grid to set it to. TYPE ( ProcessGrid_t ), INTENT ( IN ) :: grid !! Local variables TYPE ( TripletList_r ) :: triplet_list_r TYPE ( TripletList_c ) :: triplet_list_c TYPE ( Matrix_ps ) :: new_mat !! Get the data in a triplet list CALL ConstructTripletList ( triplet_list_c ) CALL ConstructTripletList ( triplet_list_r ) IF ( this % process_grid % my_slice . EQ . 0 ) THEN IF ( this % is_complex ) THEN CALL GetMatrixTripletList ( this , triplet_list_c ) ELSE CALL GetMatrixTripletList ( this , triplet_list_r ) END IF END IF !! Fill The New Matrix CALL ConstructEmptyMatrix ( new_mat , this % actual_matrix_dimension , grid , & & this % is_complex ) IF ( this % is_complex ) THEN CALL FillMatrixFromTripletList ( new_mat , triplet_list_c ) ELSE CALL FillMatrixFromTripletList ( new_mat , triplet_list_r ) END IF !! Copy back to finish CALL CopyMatrix ( new_mat , this ) !! Cleanup CALL DestructMatrix ( new_mat ) CALL DestructTripletList ( triplet_list_c ) CALL DestructTripletList ( triplet_list_r ) END SUBROUTINE SetMatrixProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct distributed sparse matrix from a matrix market file in parallel. !> Read \\cite boisvert1996matrix for the details. RECURSIVE SUBROUTINE ConstructMatrixFromMatrixMarket_ps ( this , file_name , & & process_grid_in ) !> The file being constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Grid to distribute the matrix on. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: process_grid_in !> The name of the file to read. CHARACTER ( len =* ), INTENT ( IN ) :: file_name INTEGER , PARAMETER :: MAX_LINE_LENGTH = 100 !! File Handles INTEGER :: local_file_handler INTEGER :: mpi_file_handler !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Reading The File TYPE ( TripletList_r ) :: triplet_list_r TYPE ( Triplet_r ) :: temp_triplet_r TYPE ( TripletList_c ) :: triplet_list_c TYPE ( Triplet_c ) :: temp_triplet_c INTEGER :: matrix_rows , matrix_columns , total_values !! Length Variables INTEGER :: header_length INTEGER ( KIND = MPI_OFFSET_KIND ) :: total_file_size INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_offset INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_data_size INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_data_size_plus_buffer INTEGER :: current_line_length !! Input Buffers CHARACTER ( len = MAX_LINE_LENGTH ) :: input_buffer CHARACTER ( len = :), ALLOCATABLE :: mpi_input_buffer CHARACTER ( len = MAX_LINE_LENGTH ) :: temp_substring !! Temporary Variables REAL ( NTREAL ) :: realval , cval INTEGER :: bytes_per_character LOGICAL :: found_comment_line INTEGER :: mpi_status ( MPI_STATUS_SIZE ) INTEGER :: full_buffer_counter LOGICAL :: end_of_buffer LOGICAL :: header_success INTEGER :: ierr TYPE ( Error_t ) :: err IF (. NOT . PRESENT ( process_grid_in )) THEN CALL ConstructMatrixFromMatrixMarket ( this , file_name , global_grid ) ELSE CALL ConstructError ( err ) !! Setup Involves Just The Root Opening And Reading Parameter Data CALL StartTimer ( \"MPI Read Text\" ) CALL MPI_Type_size ( MPI_CHARACTER , bytes_per_character , ierr ) IF ( IsRoot ( process_grid_in )) THEN header_length = 0 local_file_handler = 16 OPEN ( local_file_handler , file = file_name , iostat = ierr , status = \"old\" ) IF ( ierr . NE . 0 ) THEN CALL SetGenericError ( err , TRIM ( file_name ) // \" doesn't exist\" , . TRUE .) END IF !! Parse the header. READ ( local_file_handler , fmt = '(A)' ) input_buffer header_success = ParseMMHeader ( input_buffer , sparsity_type , & & data_type , pattern_type ) IF (. NOT . header_success ) THEN CALL SetGenericError ( err , \"Invalid File Header\" , . TRUE .) END IF header_length = header_length + LEN_TRIM ( input_buffer ) + 1 !! First Read In The Comment Lines found_comment_line = . TRUE . DO WHILE ( found_comment_line ) READ ( local_file_handler , fmt = '(A)' ) input_buffer !! +1 for newline header_length = header_length + LEN_TRIM ( input_buffer ) + 1 IF (. NOT . input_buffer ( 1 : 1 ) . EQ . '%' ) THEN found_comment_line = . FALSE . END IF END DO !! Get The Matrix Parameters READ ( input_buffer , * ) matrix_rows , matrix_columns , total_values CLOSE ( local_file_handler ) END IF !! Broadcast Parameters CALL MPI_Bcast ( matrix_rows , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( matrix_columns , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( total_values , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( header_length , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( sparsity_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( data_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( pattern_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) !! Build Local Storage CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = ( data_type . EQ . MM_COMPLEX )) !! Global read CALL MPI_File_open ( this % process_grid % global_comm , file_name , & & MPI_MODE_RDONLY , MPI_INFO_NULL , mpi_file_handler , ierr ) CALL MPI_File_get_size ( mpi_file_handler , total_file_size , ierr ) !! Compute Offsets And Data Size local_data_size = ( total_file_size - bytes_per_character * header_length ) / & & this % process_grid % total_processors IF ( local_data_size . LT . 2 * MAX_LINE_LENGTH ) THEN local_data_size = 2 * MAX_LINE_LENGTH END IF local_offset = bytes_per_character * header_length + & local_data_size * this % process_grid % global_rank !! Check if this processor has any work to do, and set the appropriate !! buffer size. We also add some buffer space, so you can read beyond !! your local data size in case the local data read ends in the middle !! of a line. IF ( local_offset . LT . total_file_size ) THEN local_data_size_plus_buffer = local_data_size + & & MAX_LINE_LENGTH * bytes_per_character IF ( local_offset + local_data_size_plus_buffer . GT . & & total_file_size ) THEN local_data_size_plus_buffer = total_file_size - local_offset END IF IF ( this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN local_data_size_plus_buffer = total_file_size - local_offset END IF ELSE local_data_size_plus_buffer = 0 END IF !! A buffer to read the data into. ALLOCATE ( CHARACTER ( LEN = local_data_size_plus_buffer ) :: mpi_input_buffer ) !! Do Actual Reading CALL MPI_File_read_at_all ( mpi_file_handler , local_offset , & & mpi_input_buffer , INT ( local_data_size_plus_buffer ), & & MPI_CHARACTER , mpi_status , ierr ) !! Trim Off The Half Read Line At The Start IF (. NOT . this % process_grid % global_rank . EQ . & & this % process_grid % RootID ) THEN full_buffer_counter = INDEX ( mpi_input_buffer , new_line ( 'A' )) + 1 ELSE full_buffer_counter = 1 END IF !! Read By Line end_of_buffer = . FALSE . IF ( local_data_size_plus_buffer . EQ . 0 ) THEN end_of_buffer = . TRUE . END IF IF ( this % is_complex ) THEN CALL ConstructTripletList ( triplet_list_c ) ELSE CALL ConstructTripletList ( triplet_list_r ) END IF DO WHILE (. NOT . end_of_buffer ) current_line_length = INDEX ( mpi_input_buffer ( full_buffer_counter :),& new_line ( 'A' )) IF ( current_line_length . EQ . 0 ) THEN !! Hit The End Of The Buffer end_of_buffer = . TRUE . ELSE temp_substring = mpi_input_buffer ( full_buffer_counter : & & full_buffer_counter + current_line_length - 1 ) IF ( current_line_length . GT . 1 ) THEN IF ( data_type . EQ . MM_COMPLEX ) THEN READ ( temp_substring (: current_line_length - 1 ), * ) & & temp_triplet_c % index_row , & & temp_triplet_c % index_column , & & realval , cval temp_triplet_c % point_value = & & CMPLX ( realval , cval , KIND = NTCOMPLEX ) CALL AppendToTripletList ( triplet_list_c , temp_triplet_c ) ELSE READ ( temp_substring (: current_line_length - 1 ), * ) & & temp_triplet_r % index_row , & & temp_triplet_r % index_column , & & temp_triplet_r % point_value CALL AppendToTripletList ( triplet_list_r , temp_triplet_r ) END IF END IF IF ( full_buffer_counter + current_line_length . GE . & & local_data_size + 2 ) THEN IF (. NOT . this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN end_of_buffer = . TRUE . END IF END IF full_buffer_counter = full_buffer_counter + current_line_length END IF END DO !! Cleanup CALL MPI_File_close ( mpi_file_handler , ierr ) CALL StopTimer ( \"MPI Read Text\" ) CALL MPI_Barrier ( this % process_grid % global_comm , ierr ) !! Redistribute The Matrix IF ( this % is_complex ) THEN CALL SymmetrizeTripletList ( triplet_list_c , pattern_type ) CALL FillMatrixFromTripletList ( this , triplet_list_c ) CALL DestructTripletList ( triplet_list_c ) ELSE CALL SymmetrizeTripletList ( triplet_list_r , pattern_type ) CALL FillMatrixFromTripletList ( this , triplet_list_r ) CALL DestructTripletList ( triplet_list_r ) END IF DEALLOCATE ( mpi_input_buffer ) END IF END SUBROUTINE ConstructMatrixFromMatrixMarket_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a distributed sparse matrix from a binary file in parallel. !> Faster than text, so this is good for check pointing. RECURSIVE SUBROUTINE ConstructMatrixFromBinary_ps ( this , file_name , & & process_grid_in ) !! Parameters !> The file being constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Grid to distribute the matrix on. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: process_grid_in !> The name of the file to read. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data INTEGER :: triplet_mpi_type TYPE ( TripletList_r ) :: triplet_list_r TYPE ( TripletList_c ) :: triplet_list_c !! File Handles INTEGER :: mpi_file_handler !! Reading The File INTEGER :: matrix_rows , matrix_columns , total_values , complex_flag INTEGER , DIMENSION ( 4 ) :: matrix_information INTEGER :: local_triplets INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_offset INTEGER ( KIND = MPI_OFFSET_KIND ) :: header_size INTEGER :: bytes_per_int , bytes_per_data !! Temporary variables INTEGER :: mpi_status ( MPI_STATUS_SIZE ) INTEGER :: ierr TYPE ( Error_t ) :: err LOGICAL :: error_occured IF (. NOT . PRESENT ( process_grid_in )) THEN CALL ConstructMatrixFromBinary ( this , file_name , global_grid ) ELSE CALL ConstructError ( err ) CALL StartTimer ( \"MPI Read Binary\" ) CALL MPI_File_open ( process_grid_in % global_comm , file_name , & & MPI_MODE_RDONLY , MPI_INFO_NULL , mpi_file_handler , ierr ) error_occured = CheckMPIError ( err , TRIM ( file_name ) // \" doesn't exist\" , & & ierr , . TRUE .) !! Get The Matrix Parameters IF ( IsRoot ( process_grid_in )) THEN local_offset = 0 CALL MPI_File_read_at ( mpi_file_handler , local_offset , & & matrix_information , 4 , MPINTINTEGER , mpi_status , ierr ) matrix_rows = matrix_information ( 1 ) matrix_columns = matrix_information ( 2 ) total_values = matrix_information ( 3 ) complex_flag = matrix_information ( 4 ) END IF !! Broadcast Parameters CALL MPI_Bcast ( matrix_rows , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( matrix_columns , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( total_values , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( complex_flag , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) !! Build Local Storage IF ( complex_flag . EQ . 1 ) THEN CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = . TRUE .) ELSE CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = . FALSE .) END IF CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) IF ( this % is_complex ) THEN CALL MPI_Type_extent ( MPINTCOMPLEX , bytes_per_data , ierr ) triplet_mpi_type = GetMPITripletType_c () ELSE CALL MPI_Type_extent ( MPINTREAL , bytes_per_data , ierr ) triplet_mpi_type = GetMPITripletType_r () END IF !! Compute Offset local_triplets = total_values / this % process_grid % total_processors local_offset = local_triplets * ( this % process_grid % global_rank ) header_size = 4 * bytes_per_int IF ( this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN local_triplets = INT ( total_values ) - INT ( local_offset ) END IF local_offset = local_offset * ( bytes_per_int * 2 + bytes_per_data ) + & & header_size !! Do The Actual Reading CALL MPI_File_set_view ( mpi_file_handler , local_offset , triplet_mpi_type ,& & triplet_mpi_type , \"native\" , MPI_INFO_NULL , ierr ) IF ( this % is_complex ) THEN CALL ConstructTripletList ( triplet_list_c , local_triplets ) CALL MPI_File_read_all ( mpi_file_handler , triplet_list_c % data , & & local_triplets , triplet_mpi_type , mpi_status , ierr ) ELSE CALL ConstructTripletList ( triplet_list_r , local_triplets ) CALL MPI_File_read_all ( mpi_file_handler , triplet_list_r % data , & & local_triplets , triplet_mpi_type , mpi_status , ierr ) END IF CALL MPI_File_close ( mpi_file_handler , ierr ) CALL StopTimer ( \"MPI Read Binary\" ) IF ( this % is_complex ) THEN CALL FillMatrixFromTripletList ( this , triplet_list_c ) CALL DestructTripletList ( triplet_list_c ) ELSE CALL FillMatrixFromTripletList ( this , triplet_list_r ) CALL DestructTripletList ( triplet_list_r ) END IF END IF END SUBROUTINE ConstructMatrixFromBinary_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Save a distributed sparse matrix to a binary file. !> Faster than text, so this is good for check pointing. SUBROUTINE WriteMatrixToBinary_ps ( this , file_name ) !! Parameters !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data INTEGER :: triplet_mpi_type IF ( this % is_complex ) THEN triplet_mpi_type = GetMPITripletType_c () CALL WriteMatrixToBinary_psc ( this , file_name , triplet_mpi_type ) ELSE triplet_mpi_type = GetMPITripletType_r () CALL WriteMatrixToBinary_psr ( this , file_name , triplet_mpi_type ) END IF END SUBROUTINE WriteMatrixToBinary_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implementation of write to binary. SUBROUTINE WriteMatrixToBinary_psr ( this , file_name , triplet_mpi_type ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !> The triplet type, which distinguishes real and complex triplets. INTEGER , INTENT ( IN ) :: triplet_mpi_type !! Local Data TYPE ( TripletList_r ) :: triplet_list TYPE ( Matrix_lsr ) :: merged_local_data INCLUDE \"distributed_includes/WriteMatrixToBinary.f90\" END SUBROUTINE WriteMatrixToBinary_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implementation of write to binary. SUBROUTINE WriteMatrixToBinary_psc ( this , file_name , triplet_mpi_type ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !> The triplet type, which distinguishes real and complex triplets. INTEGER , INTENT ( IN ) :: triplet_mpi_type !! Local Data TYPE ( TripletList_c ) :: triplet_list TYPE ( Matrix_lsc ) :: merged_local_data INCLUDE \"distributed_includes/WriteMatrixToBinary.f90\" END SUBROUTINE WriteMatrixToBinary_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a distributed sparse matrix to a matrix market file. !> Read \\cite boisvert1996matrix for the details. SUBROUTINE WriteMatrixToMatrixMarket_ps ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name IF ( this % is_complex ) THEN CALL WriteMatrixToMatrixMarket_psc ( this , file_name ) ELSE CALL WriteMatrixToMatrixMarket_psr ( this , file_name ) END IF END SUBROUTINE WriteMatrixToMatrixMarket_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write to matrix market implementation for real data. SUBROUTINE WriteMatrixToMatrixMarket_psr ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data TYPE ( TripletList_r ) :: triplet_list TYPE ( Matrix_lsr ) :: merged_local_data #include \"distributed_includes/WriteToMatrixMarket.f90\" END SUBROUTINE WriteMatrixToMatrixMarket_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write to matrix market implementation for complex data. SUBROUTINE WriteMatrixToMatrixMarket_psc ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data TYPE ( TripletList_c ) :: triplet_list TYPE ( Matrix_lsc ) :: merged_local_data #define ISCOMPLEX #include \"distributed_includes/WriteToMatrixMarket.f90\" #undef ISCOMPLEX END SUBROUTINE WriteMatrixToMatrixMarket_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine fills in a matrix based on local triplet lists. Each process !> should pass in triplet lists with global coordinates. It doesn't matter !> where each triplet is stored, as long as global coordinates are given. SUBROUTINE FillMatrixFromTripletList_psr ( this , triplet_list , preduplicated_in ) !> The matrix to fill. TYPE ( Matrix_ps ) :: this !> The triplet list of values. TYPE ( TripletList_r ) :: triplet_list !> If lists are preduplicated across slices set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: preduplicated_in !! Local Data TYPE ( Matrix_ps ) :: temp_matrix TYPE ( TripletList_r ) :: sorted_triplet_list TYPE ( Matrix_lsr ) :: local_matrix TYPE ( Matrix_lsr ) :: gathered_matrix !! Local Data TYPE ( Permutation_t ) :: basic_permutation TYPE ( ReduceHelper_t ) :: gather_helper REAL ( NTREAL ), PARAMETER :: threshold = 0.0 LOGICAL :: preduplicated IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , temp_matrix ) CALL CopyMatrix ( temp_matrix , this ) CALL DestructMatrix ( temp_matrix ) END IF INCLUDE \"distributed_includes/FillMatrixFromTripletList.f90\" END SUBROUTINE FillMatrixFromTripletList_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine fills in a matrix based on local triplet lists. Each process !> should pass in triplet lists with global coordinates. It doesn't matter !> where each triplet is stored, as long as global coordinates are given. SUBROUTINE FillMatrixFromTripletList_psc ( this , triplet_list , preduplicated_in ) !> The matrix to fill. TYPE ( Matrix_ps ) :: this !> The triplet list of values. TYPE ( TripletList_c ) :: triplet_list !> If lists are preduplicated across slices set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: preduplicated_in !! Local Data TYPE ( TripletList_c ) :: sorted_triplet_list TYPE ( Matrix_lsc ) :: local_matrix TYPE ( Matrix_lsc ) :: gathered_matrix !! Local Data TYPE ( Matrix_ps ) :: temp_matrix TYPE ( Permutation_t ) :: basic_permutation TYPE ( ReduceHelper_t ) :: gather_helper REAL ( NTREAL ), PARAMETER :: threshold = 0.0 LOGICAL :: preduplicated IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , temp_matrix ) CALL CopyMatrix ( temp_matrix , this ) CALL DestructMatrix ( temp_matrix ) END IF INCLUDE \"distributed_includes/FillMatrixFromTripletList.f90\" END SUBROUTINE FillMatrixFromTripletList_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_ps ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this IF ( this % is_complex ) THEN CALL FillMatrixIdentity_psc ( this ) ELSE CALL FillMatrixIdentity_psr ( this ) END IF END SUBROUTINE FillMatrixIdentity_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_psr ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_r ) :: triplet_list TYPE ( TripletList_r ) :: unsorted_triplet_list TYPE ( TripletList_r ) :: sorted_triplet_list TYPE ( Matrix_lsr ) :: local_matrix INCLUDE \"distributed_includes/FillMatrixIdentity.f90\" END SUBROUTINE FillMatrixIdentity_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_psc ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_c ) :: triplet_list TYPE ( TripletList_c ) :: unsorted_triplet_list TYPE ( TripletList_c ) :: sorted_triplet_list TYPE ( Matrix_lsc ) :: local_matrix INCLUDE \"distributed_includes/FillMatrixIdentity.f90\" END SUBROUTINE FillMatrixIdentity_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with a permutation. !> If you don't specify permuterows, will default to permuting rows. SUBROUTINE FillMatrixPermutation_ps ( this , permutation_vector , permute_rows_in ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , OPTIONAL , INTENT ( IN ) :: permute_rows_in !! Local Data LOGICAL :: permute_rows !! Figure out what type of permutation IF ( PRESENT ( permute_rows_in ) . AND . permute_rows_in . EQV . . FALSE .) THEN permute_rows = . FALSE . ELSE permute_rows = . TRUE . END IF IF ( this % is_complex ) THEN CALL FillMatrixPermutation_psc ( this , permutation_vector , permute_rows ) ELSE CALL FillMatrixPermutation_psr ( this , permutation_vector , permute_rows ) END IF END SUBROUTINE FillMatrixPermutation_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill permutation implementation. SUBROUTINE FillMatrixPermutation_psr ( this , permutation_vector , rows ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , INTENT ( IN ) :: rows !! Local Data TYPE ( TripletList_r ) :: triplet_list TYPE ( TripletList_r ) :: unsorted_triplet_list TYPE ( TripletList_r ) :: sorted_triplet_list TYPE ( Matrix_lsr ) :: local_matrix INCLUDE \"distributed_includes/FillMatrixPermutation.f90\" END SUBROUTINE FillMatrixPermutation_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill permutation implementation. SUBROUTINE FillMatrixPermutation_psc ( this , permutation_vector , rows ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , INTENT ( IN ) :: rows !! Local Data TYPE ( TripletList_c ) :: triplet_list TYPE ( TripletList_c ) :: unsorted_triplet_list TYPE ( TripletList_c ) :: sorted_triplet_list TYPE ( Matrix_lsc ) :: local_matrix INCLUDE \"distributed_includes/FillMatrixPermutation.f90\" END SUBROUTINE FillMatrixPermutation_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extracts a triplet list of the data that is stored on this process. !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixTripletList_psr ( this , triplet_list ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsr ) :: merged_local_data IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF INCLUDE \"distributed_includes/GetMatrixTripletList.f90\" END SUBROUTINE GetMatrixTripletList_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extracts a triplet list of the data that is stored on this process. !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixTripletList_psc ( this , triplet_list ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsc ) :: merged_local_data IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF INCLUDE \"distributed_includes/GetMatrixTripletList.f90\" END SUBROUTINE GetMatrixTripletList_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract an arbitrary block of a matrix into a triplet list. Block is !> defined by the row/column start/end values. !> This is slower than GetMatrixTripletList, because communication is required !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixBlock_psr ( this , triplet_list , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> The starting row for data to store on this process. INTEGER :: start_row !> The ending row for data to store on this process. INTEGER :: end_row !> The starting col for data to store on this process INTEGER :: start_column !> The ending col for data to store on this process INTEGER :: end_column !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsr ) :: merged_local_data TYPE ( TripletList_r ) :: local_triplet_list !! Send Buffer REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: send_buffer_val !! Receive Buffer REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val !! Temp Values TYPE ( Triplet_r ) :: temp_triplet !! Local Data INTEGER , DIMENSION (:), ALLOCATABLE :: row_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: row_end_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_end_list !! Send Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: send_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_col !! Receive Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: recv_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_col !! Temporary INTEGER :: II , PP INTEGER :: ierr IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #define MPIDATATYPE MPINTREAL #include \"distributed_includes/GetMatrixBlock.f90\" #undef MPIDATATYPE END SUBROUTINE GetMatrixBlock_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract an arbitrary block of a matrix into a triplet list. Block is !> defined by the row/column start/end values. !> This is slower than GetMatrixTripletList, because communication is required !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixBlock_psc ( this , triplet_list , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> The starting row for data to store on this process. INTEGER :: start_row !> The ending row for data to store on this process. INTEGER :: end_row !> The starting col for data to store on this process INTEGER :: start_column !> The ending col for data to store on this process INTEGER :: end_column !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsc ) :: merged_local_data TYPE ( TripletList_c ) :: local_triplet_list !! Send Buffer COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: send_buffer_val !! Receive Buffer COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val !! Temp Values TYPE ( Triplet_c ) :: temp_triplet !! Local Data INTEGER , DIMENSION (:), ALLOCATABLE :: row_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: row_end_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_end_list !! Send Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: send_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_col !! Receive Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: recv_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_col !! Temporary INTEGER :: II , PP INTEGER :: ierr IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #define MPIDATATYPE MPINTCOMPLEX #include \"distributed_includes/GetMatrixBlock.f90\" #undef MPIDATATYPE END SUBROUTINE GetMatrixBlock_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy an arbitrary slice from a matrix into a new smaller matrix. !> NTPoly only works with square matrices, so if the number of rows and !> columns is different the matrix is resized to the maximum size. SUBROUTINE GetMatrixSlice ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER :: start_row !> The ending row to include in this matrix. INTEGER :: end_row !> The starting column to include in this matrix. INTEGER :: start_column !> The last column to include in this matrix. INTEGER :: end_column !! Get a triplet list with the values IF ( this % is_complex ) THEN CALL GetMatrixSlice_psc ( this , submatrix , start_row , end_row , & & start_column , end_column ) ELSE CALL GetMatrixSlice_psr ( this , submatrix , start_row , end_row , & & start_column , end_column ) END IF END SUBROUTINE GetMatrixSlice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implements slice matrix for real types. SUBROUTINE GetMatrixSlice_psr ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER :: start_row !> The ending row to include in this matrix. INTEGER :: end_row !> The starting column to include in this matrix. INTEGER :: start_column !> The last column to include in this matrix. INTEGER :: end_column #define TLISTTYPE TripletList_r #define TTYPE Triplet_r #include \"distributed_includes/SliceMatrix.f90\" #undef TLISTTYPE #undef TTYPE END SUBROUTINE GetMatrixSlice_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implements slice matrix for complex types. SUBROUTINE GetMatrixSlice_psc ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER :: start_row !> The ending row to include in this matrix. INTEGER :: end_row !> The starting column to include in this matrix. INTEGER :: start_column !> The last column to include in this matrix. INTEGER :: end_column #define TLISTTYPE TripletList_c #define TTYPE Triplet_c #include \"distributed_includes/SliceMatrix.f90\" #undef TLISTTYPE #undef TTYPE END SUBROUTINE GetMatrixSlice_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the actual dimension of the matrix. PURE FUNCTION GetMatrixActualDimension_ps ( this ) RESULT ( DIMENSION ) !! Parameters !> The matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Dimension of the matrix INTEGER :: DIMENSION DIMENSION = this % actual_matrix_dimension END FUNCTION GetMatrixActualDimension_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the logical dimension of the matrix. !> Includes padding. PURE FUNCTION GetMatrixLogicalDimension_ps ( this ) RESULT ( DIMENSION ) !> The matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Dimension of the matrix INTEGER :: DIMENSION DIMENSION = this % logical_matrix_dimension END FUNCTION GetMatrixLogicalDimension_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out information about a distributed sparse matrix. !> Sparsity, and load balancing information. SUBROUTINE PrintMatrixInformation_ps ( this ) !> This the matrix to print information about. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !! Local Data INTEGER :: min_size , max_size REAL ( NTREAL ) :: sparsity CALL GetMatrixLoadBalance ( this , min_size , max_size ) sparsity = REAL ( GetMatrixSize ( this ), KIND = NTREAL ) / & & ( REAL ( this % actual_matrix_dimension , KIND = NTREAL ) ** 2 ) CALL WriteHeader ( \"Load_Balance\" ) CALL EnterSubLog CALL WriteListElement ( key = \"min_size\" , value = min_size ) CALL WriteListElement ( key = \"max_size\" , value = max_size ) CALL ExitSubLog CALL WriteElement ( key = \"Dimension\" , value = this % actual_matrix_dimension ) CALL WriteElement ( key = \"Sparsity\" , value = sparsity ) END SUBROUTINE PrintMatrixInformation_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a distributed sparse matrix. !> This is a serial print routine, and should probably only be used for debug !> purposes. SUBROUTINE PrintMatrix_ps ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in IF ( this % is_complex ) THEN IF ( PRESENT ( file_name_in )) THEN CALL PrintMatrix_psc ( this , file_name_in ) ELSE CALL PrintMatrix_psc ( this ) END IF ELSE IF ( PRESENT ( file_name_in )) THEN CALL PrintMatrix_psr ( this , file_name_in ) ELSE CALL PrintMatrix_psr ( this ) END IF END IF END SUBROUTINE PrintMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print matrix implementation (real). SUBROUTINE PrintMatrix_psr ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Temporary Variables TYPE ( Matrix_lsr ) :: local_mat INCLUDE \"distributed_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print matrix implementation (complex). SUBROUTINE PrintMatrix_psc ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Temporary Variables TYPE ( Matrix_lsc ) :: local_mat INCLUDE \"distributed_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A utility routine that filters a sparse matrix. !> All (absolute) values below the threshold are set to zero. SUBROUTINE FilterMatrix_ps ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold IF ( this % is_complex ) THEN CALL FilterMatrix_psc ( this , threshold ) ELSE CALL FilterMatrix_psr ( this , threshold ) END IF END SUBROUTINE FilterMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Filter matrix implementation (real). SUBROUTINE FilterMatrix_psr ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Variables TYPE ( TripletList_r ) :: triplet_list TYPE ( TripletList_r ) :: new_list TYPE ( Triplet_r ) :: temporary INCLUDE \"distributed_includes/FilterMatrix.f90\" END SUBROUTINE FilterMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Filter matrix implementation (real). SUBROUTINE FilterMatrix_psc ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Variables TYPE ( TripletList_c ) :: triplet_list TYPE ( TripletList_c ) :: new_list TYPE ( Triplet_c ) :: temporary INCLUDE \"distributed_includes/FilterMatrix.f90\" END SUBROUTINE FilterMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the total number of non-zero entries in the distributed sparse matrix. FUNCTION GetMatrixSize_ps ( this ) RESULT ( total_size ) !> The matrix to calculate the number of non-zero entries of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The number of non-zero entries in the matrix. INTEGER ( c_long ) :: total_size !! Local Data !integer :: local_size REAL ( NTREAL ) :: local_size REAL ( NTREAL ) :: temp_size TYPE ( Matrix_lsc ) :: merged_local_data_c TYPE ( Matrix_lsr ) :: merged_local_data_r INTEGER :: ierr !! Merge all the local data IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , merged_local_data_c ) local_size = SIZE ( merged_local_data_c % values ) CALL DestructMatrix ( merged_local_data_c ) ELSE CALL MergeMatrixLocalBlocks ( this , merged_local_data_r ) local_size = SIZE ( merged_local_data_r % values ) CALL DestructMatrix ( merged_local_data_r ) END IF !! Global Sum CALL MPI_Allreduce ( local_size , temp_size , 1 , MPINTREAL , MPI_SUM ,& & this % process_grid % within_slice_comm , ierr ) total_size = INT ( temp_size , kind = c_long ) END FUNCTION GetMatrixSize_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get a measure of how load balanced this matrix is. For each process, the !> number of non-zero entries is calculated. Then, this function returns !> the max and min of those values. SUBROUTINE GetMatrixLoadBalance_ps ( this , min_size , max_size ) !> The matrix to compute the measure on. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The minimum entries contained on a single process. INTEGER , INTENT ( OUT ) :: min_size !> The maximum entries contained on a single process. INTEGER , INTENT ( OUT ) :: max_size !! Local Data INTEGER :: local_size TYPE ( Matrix_lsc ) :: merged_local_data_c TYPE ( Matrix_lsr ) :: merged_local_data_r INTEGER :: ierr !! Merge all the local data IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , merged_local_data_c ) local_size = SIZE ( merged_local_data_c % values ) CALL DestructMatrix ( merged_local_data_c ) ELSE CALL MergeMatrixLocalBlocks ( this , merged_local_data_r ) local_size = SIZE ( merged_local_data_r % values ) CALL DestructMatrix ( merged_local_data_r ) END IF !! Global Reduce CALL MPI_Allreduce ( local_size , max_size , 1 , MPINTINTEGER , MPI_MAX ,& & this % process_grid % within_slice_comm , ierr ) CALL MPI_Allreduce ( local_size , min_size , 1 , MPINTINTEGER , MPI_MIN ,& & this % process_grid % within_slice_comm , ierr ) END SUBROUTINE GetMatrixLoadBalance_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix. Note that this is a pure transpose, there is !> no complex conjugate performed. SUBROUTINE TransposeMatrix_ps ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( OUT ) :: TransMat IF ( AMat % is_complex ) THEN CALL TransposeMatrix_psc ( AMat , TransMat ) ELSE CALL TransposeMatrix_psr ( AMat , TransMat ) END IF END SUBROUTINE TransposeMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose implementation (real). SUBROUTINE TransposeMatrix_psr ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( OUT ) :: TransMat !! Local Variables TYPE ( TripletList_r ) :: triplet_list TYPE ( TripletList_r ) :: new_list TYPE ( Triplet_r ) :: temporary , temporary_t INCLUDE \"distributed_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose implementation (complex). SUBROUTINE TransposeMatrix_psc ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( OUT ) :: TransMat !! Local Variables TYPE ( TripletList_c ) :: triplet_list TYPE ( TripletList_c ) :: new_list TYPE ( Triplet_c ) :: temporary , temporary_t INCLUDE \"distributed_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Every value in the matrix is changed into its complex conjugate. PURE SUBROUTINE ConjugateMatrix_ps ( this ) !> The matrix to compute the complex conjugate of. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Variables TYPE ( Matrix_lsc ) :: local_matrix IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , local_matrix ) CALL ConjugateMatrix ( local_matrix ) CALL SplitMatrixToLocalBlocks ( this , local_matrix ) CALL DestructMatrix ( local_matrix ) END IF END SUBROUTINE ConjugateMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split the current communicator, and give each group a complete copy of this SUBROUTINE CommSplitMatrix_ps ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True LOGICAL , INTENT ( OUT ) :: split_slice IF ( this % is_complex ) THEN CALL CommSplitMatrix_psc ( this , split_mat , my_color , split_slice ) ELSE CALL CommSplitMatrix_psr ( this , split_mat , my_color , split_slice ) END IF END SUBROUTINE CommSplitMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split implementation for real data. SUBROUTINE CommSplitMatrix_psr ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True. LOGICAL , INTENT ( OUT ) :: split_slice !! For Data Redistribution TYPE ( TripletList_r ) :: full_list , new_list TYPE ( TripletList_r ), DIMENSION (:), ALLOCATABLE :: send_list INCLUDE \"distributed_includes/CommSplitMatrix.f90\" END SUBROUTINE CommSplitMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split implementation for complex data. SUBROUTINE CommSplitMatrix_psc ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True. LOGICAL , INTENT ( OUT ) :: split_slice !! For Data Redistribution TYPE ( TripletList_c ) :: full_list , new_list TYPE ( TripletList_c ), DIMENSION (:), ALLOCATABLE :: send_list INCLUDE \"distributed_includes/CommSplitMatrix.f90\" END SUBROUTINE CommSplitMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute the data in a matrix based on row, column list !> This will redistribute the data so that the local data are entries in !> the rows and columns list. The order of the row list and column list matter !> because local data is filled in the same order. SUBROUTINE RedistributeData_psr ( this , index_lookup , reverse_index_lookup ,& & initial_triplet_list , sorted_triplet_list ) !> The matrix to redistribute TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: index_lookup !> Reverse Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: reverse_index_lookup !> The current triplet list of global coordinates. TYPE ( TripletList_r ), INTENT ( IN ) :: initial_triplet_list !> returns an allocated triplet list with local coordinates in sorted order. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_triplet_list !! Local Data TYPE ( TripletList_r ) :: gathered_list TYPE ( TripletList_r ), DIMENSION ( this % process_grid % slice_size ) :: & & send_triplet_lists TYPE ( Triplet_r ) :: temp_triplet INCLUDE \"distributed_includes/RedistributeData.f90\" END SUBROUTINE RedistributeData_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute the data in a matrix based on row, column list !> This will redistribute the data so that the local data are entries in !> the rows and columns list. The order of the row list and column list matter !> because local data is filled in the same order. SUBROUTINE RedistributeData_psc ( this , index_lookup , reverse_index_lookup ,& & initial_triplet_list , sorted_triplet_list ) !> The matrix to redistribute TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: index_lookup !> Reverse Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: reverse_index_lookup !> The current triplet list of global coordinates. TYPE ( TripletList_c ), INTENT ( IN ) :: initial_triplet_list !> returns an allocated triplet list with local coordinates in sorted order. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_triplet_list !! Local Data TYPE ( TripletList_c ) :: gathered_list TYPE ( TripletList_c ), DIMENSION ( this % process_grid % slice_size ) :: & & send_triplet_lists TYPE ( Triplet_c ) :: temp_triplet INCLUDE \"distributed_includes/RedistributeData.f90\" END SUBROUTINE RedistributeData_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate a matrix size that can be divided by the number of processors. PURE FUNCTION CalculateScaledDimension ( this , matrix_dim ) RESULT ( scaled_dim ) !> The matrix we are calculating for. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The dimension of the actual matrix. INTEGER , INTENT ( IN ) :: matrix_dim !> A new dimension which includes padding. INTEGER :: scaled_dim !! Local Data INTEGER :: size_ratio INTEGER :: lcm lcm = this % process_grid % block_multiplier * & & this % process_grid % num_process_slices * & & this % process_grid % num_process_columns * & & this % process_grid % num_process_rows size_ratio = matrix_dim / lcm IF ( size_ratio * lcm . EQ . matrix_dim ) THEN scaled_dim = matrix_dim ELSE scaled_dim = ( size_ratio + 1 ) * ( lcm ) END IF END FUNCTION CalculateScaledDimension !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take a local matrix, and use it to fill the local block matrix structure. PURE SUBROUTINE SplitMatrixToLocalBlocks_psr ( this , matrix_to_split ) !> The distributed sparse matrix to split into. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The matrix to split up. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix_to_split #define LOCALMATRIX this%local_data_r #include \"distributed_includes/SplitMatrixToLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE SplitMatrixToLocalBlocks_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take a local matrix, and use it to fill the local block matrix structure. PURE SUBROUTINE SplitMatrixToLocalBlocks_psc ( this , matrix_to_split ) !> The distributed sparse matrix to split into. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The matrix to split up. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix_to_split #define LOCALMATRIX this%local_data_c #include \"distributed_includes/SplitMatrixToLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE SplitMatrixToLocalBlocks_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Merge together the local matrix blocks into one big matrix. PURE SUBROUTINE MergeMatrixLocalBlocks_psr ( this , merged_matrix ) !> The distributed sparse matrix to merge from. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The merged matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: merged_matrix #define LOCALMATRIX this%local_data_r #include \"distributed_includes/MergeMatrixLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE MergeMatrixLocalBlocks_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Merge together the local matrix blocks into one big matrix. !! @param[inout] this the distributed sparse matrix. !! @param[inout] merged_matrix the merged matrix. PURE SUBROUTINE MergeMatrixLocalBlocks_psc ( this , merged_matrix ) !> The distributed sparse matrix to merge from. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The merged matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: merged_matrix #define LOCALMATRIX this%local_data_c #include \"distributed_includes/MergeMatrixLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE MergeMatrixLocalBlocks_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the current matrix to a real type matrix. SUBROUTINE ConvertMatrixToReal ( in , out ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: in !> Real version of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: out LOGICAL , PARAMETER :: convert_to_complex = . FALSE . !! Local Variables TYPE ( Matrix_lsc ) :: local_matrix TYPE ( Matrix_lsr ) :: converted_matrix INCLUDE \"distributed_includes/ConvertMatrixType.f90\" END SUBROUTINE ConvertMatrixToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the current matrix to a complex type matrix. SUBROUTINE ConvertMatrixToComplex ( in , out ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: in !> Complex version of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: out LOGICAL , PARAMETER :: convert_to_complex = . TRUE . !! Local Variables TYPE ( Matrix_lsr ) :: local_matrix TYPE ( Matrix_lsc ) :: converted_matrix INCLUDE \"distributed_includes/ConvertMatrixType.f90\" END SUBROUTINE ConvertMatrixToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix. !! If the new size is smaller, then values outside that range are deleted. !! IF the new size is bigger, zero padding is applied. !! Warning: this requires a full data redistribution. SUBROUTINE ResizeMatrix ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size IF ( this % is_complex ) THEN CALL ResizeMatrix_psc ( this , new_size ) ELSE CALL ResizeMatrix_psr ( this , new_size ) END IF END SUBROUTINE ResizeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix implementation (real). SUBROUTINE ResizeMatrix_psr ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size !! Local Variables TYPE ( TripletList_r ) :: tlist , pruned TYPE ( Triplet_r ) :: temp INCLUDE \"distributed_includes/ResizeMatrix.f90\" END SUBROUTINE ResizeMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix implementation (real). SUBROUTINE ResizeMatrix_psc ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size !! Local Variables TYPE ( TripletList_c ) :: tlist , pruned TYPE ( Triplet_c ) :: temp INCLUDE \"distributed_includes/ResizeMatrix.f90\" END SUBROUTINE ResizeMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on the !! given process. This routine is used when printing, but also is useful for !! debugging. SUBROUTINE GatherMatrixToProcess_psr ( this , local_mat , proc_id ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: local_mat !> Which process to gather on. INTEGER , INTENT ( IN ) :: proc_id !! Local Variables TYPE ( TripletList_r ) :: tlist , sorted TYPE ( TripletList_r ), DIMENSION (:), ALLOCATABLE :: slist INCLUDE \"distributed_includes/GatherMatrixToProcess.f90\" END SUBROUTINE GatherMatrixToProcess_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on the !! given process. This routine is used when printing, but also is useful for !! debugging. SUBROUTINE GatherMatrixToProcess_psc ( this , local_mat , proc_id ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: local_mat !> Which process to gather on. INTEGER , INTENT ( IN ) :: proc_id !! Local Variables TYPE ( TripletList_c ) :: tlist , sorted TYPE ( TripletList_c ), DIMENSION (:), ALLOCATABLE :: slist INCLUDE \"distributed_includes/GatherMatrixToProcess.f90\" END SUBROUTINE GatherMatrixToProcess_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PSMatrixModule","tags":"","loc":"sourcefile/psmatrixmodule.f90.html"},{"title":"SignSolversModule.F90 – NTPoly","text":"Contents Modules SignSolversModule Source Code SignSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Matrix Sign Function. MODULE SignSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteListElement , WriteElement , WriteCitation USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & MatrixNorm , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , CopyMatrix , DestructMatrix , & & FillMatrixIdentity , PrintMatrixInformation , TransposeMatrix , & & ConjugateMatrix , ConstructEmptyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SignFunction PUBLIC :: PolarDecomposition CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the matrix sign function. SUBROUTINE SignFunction ( Mat , SignMat , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The sign of Mat. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: SignMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Sign Function Solver\" ) CALL EnterSubLog CALL WriteCitation ( \"nicholas2008functions\" ) CALL PrintParameters ( solver_parameters ) END IF CALL CoreComputation ( Mat , SignMat , solver_parameters , . FALSE .) !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE SignFunction !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the polar decomposition of a matrix Mat = U*H. SUBROUTINE PolarDecomposition ( Mat , Umat , Hmat , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The unitary polar factor. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Umat !> The hermitian matrix factor. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: Hmat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters TYPE ( Matrix_ps ) :: UmatT !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Polar Decomposition Solver\" ) CALL EnterSubLog CALL WriteCitation ( \"nicholas2008functions\" ) CALL PrintParameters ( solver_parameters ) END IF CALL CoreComputation ( Mat , Umat , solver_parameters , . TRUE .) IF ( PRESENT ( Hmat )) THEN CALL TransposeMatrix ( Umat , UmatT ) IF ( UmatT % is_complex ) THEN CALL ConjugateMatrix ( UmatT ) END IF CALL MatrixMultiply ( UmatT , Mat , Hmat , & & threshold_in = solver_parameters % threshold ) CALL DestructMatrix ( UmatT ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE PolarDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This is the implementation routine for both the sign function and !> polar decomposition. SUBROUTINE CoreComputation ( Mat , OutMat , solver_parameters , needs_transpose ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> Output of the routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !> Whether we need to perform transposes in this routine (for polar). LOGICAL , INTENT ( IN ) :: needs_transpose !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: Temp1 TYPE ( Matrix_ps ) :: Temp2 TYPE ( Matrix_ps ) :: OutMatT TYPE ( MatrixMemoryPool_p ) :: pool !! Local Data REAL ( NTREAL ), PARAMETER :: alpha = 1.69770248526_NTREAL REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: alpha_k REAL ( NTREAL ) :: xk REAL ( NTREAL ) :: norm_value INTEGER :: outer_counter !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Identity , Mat ) CALL ConstructEmptyMatrix ( Temp1 , Mat ) CALL ConstructEmptyMatrix ( Temp2 , Mat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN !! Permute Matrices CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Mat , OutMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( Mat , OutMat ) END IF !! Initialize CALL GershgorinBounds ( Mat , e_min , e_max ) xk = ABS ( e_min / e_max ) CALL ScaleMatrix ( OutMat , 1.0_NTREAL / ABS ( e_max )) !! Iterate. IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL iterate : DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF !! Update Scaling Factors alpha_k = MIN ( SQRT ( 3.0_NTREAL / ( 1.0_NTREAL + xk + xk ** 2 )), alpha ) xk = 0.5_NTREAL * alpha_k * xk * ( 3.0_NTREAL - ( alpha_k ** 2 ) * xk ** 2 ) IF ( needs_transpose ) THEN CALL TransposeMatrix ( OutMat , OutMatT ) IF ( OutMatT % is_complex ) THEN CALL ConjugateMatrix ( OutMatT ) END IF CALL MatrixMultiply ( OutMatT , OutMat , Temp1 , & & alpha_in =- 1.0_NTREAL * alpha_k ** 2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) ELSE CALL MatrixMultiply ( OutMat , OutMat , Temp1 , & & alpha_in =- 1.0_NTREAL * alpha_k ** 2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) END IF CALL IncrementMatrix ( Identity , Temp1 , alpha_in = 3.0_NTREAL ) CALL MatrixMultiply ( OutMat , Temp1 , Temp2 , alpha_in = 0.5_NTREAL * alpha_k , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( Temp2 , OutMat , alpha_in =- 1.0_NTREAL ) norm_value = MatrixNorm ( OutMat ) CALL CopyMatrix ( Temp2 , OutMat ) IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO iterate IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) CALL PrintMatrixInformation ( OutMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( OutMatT ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE CoreComputation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SignSolversModule","tags":"","loc":"sourcefile/signsolversmodule.f90.html"},{"title":"GeometryOptimizationModule.F90 – NTPoly","text":"Contents Modules GeometryOptimizationModule Source Code GeometryOptimizationModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Geometry Optimization MODULE GeometryOptimizationModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement , WriteListElement , WriteCitation USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , MatrixTrace , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , DestructMatrix , ConstructEmptyMatrix , & & FillMatrixIdentity , PrintMatrixInformation , CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters USE SquareRootSolversModule , ONLY : SquareRoot , InverseSquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: PurificationExtrapolate PUBLIC :: LowdinExtrapolate CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a new guess at the Density Matrix after updating the geometry. !> Based on the purification algorithm in \\cite niklasson2010trace . SUBROUTINE PurificationExtrapolate ( PreviousDensity , Overlap , nel , NewDensity ,& & solver_parameters_in ) !> Previous density to extrapolate from. TYPE ( Matrix_ps ), INTENT ( IN ) :: PreviousDensity !> The overlap matrix of the new geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: Overlap !> The number of electrons. INTEGER , INTENT ( IN ) :: nel !> The extrapolated density. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: NewDensity !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: WorkingDensity TYPE ( Matrix_ps ) :: WorkingOverlap TYPE ( Matrix_ps ) :: AddBranch , SubtractBranch TYPE ( Matrix_ps ) :: TempMat1 , TempMat2 TYPE ( Matrix_ps ) :: Identity !! Local Variables REAL ( NTREAL ) :: subtract_trace REAL ( NTREAL ) :: add_trace REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool1 INTEGER :: outer_counter INTEGER :: total_iterations !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Extrapolator\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Purification\" ) CALL WriteCitation ( \"niklasson2010trace\" ) CALL PrintParameters ( solver_parameters ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( NewDensity , PreviousDensity ) CALL ConstructEmptyMatrix ( WorkingDensity , PreviousDensity ) CALL ConstructEmptyMatrix ( WorkingOverlap , PreviousDensity ) CALL ConstructEmptyMatrix ( Identity , PreviousDensity ) CALL FillMatrixIdentity ( Identity ) !! Compute the working hamiltonian. CALL CopyMatrix ( PreviousDensity , WorkingDensity ) CALL CopyMatrix ( Overlap , WorkingOverlap ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingDensity , WorkingDensity , & & solver_parameters % BalancePermutation , memorypool_in = pool1 ) CALL PermuteMatrix ( WorkingOverlap , WorkingOverlap , & & solver_parameters % BalancePermutation , memorypool_in = pool1 ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool1 ) END IF !! Finish Setup CALL CopyMatrix ( WorkingDensity , NewDensity ) CALL CopyMatrix ( WorkingDensity , AddBranch ) CALL CopyMatrix ( WorkingDensity , SubtractBranch ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Figure Out Sigma Value. After which, XnS is stored in TempMat IF ( outer_counter . GT . 1 ) THEN CALL MatrixMultiply ( AddBranch , WorkingOverlap , TempMat1 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) CALL MatrixTrace ( TempMat1 , add_trace ) CALL MatrixMultiply ( SubtractBranch , WorkingOverlap , TempMat2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) CALL MatrixTrace ( TempMat2 , subtract_trace ) IF ( ABS ( nel - add_trace ) . GT . ABS ( nel - subtract_trace )) THEN !! Subtract Branch trace_value = subtract_trace CALL IncrementMatrix ( AddBranch , NewDensity , - 1.0_NTREAL ) norm_value = MatrixNorm ( NewDensity ) CALL CopyMatrix ( AddBranch , NewDensity ) CALL CopyMatrix ( TempMat2 , TempMat1 ) ELSE !! Add Branch trace_value = add_trace CALL IncrementMatrix ( SubtractBranch , NewDensity , - 1.0_NTREAL ) norm_value = MatrixNorm ( NewDensity ) CALL CopyMatrix ( SubtractBranch , NewDensity ) END IF ELSE CALL MatrixMultiply ( NewDensity , WorkingOverlap , TempMat1 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) END IF IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL WriteElement ( key = \"Trace\" , value = trace_value ) CALL WriteElement ( key = \"AddTrace\" , value = add_trace ) CALL WriteElement ( key = \"SubtractTrace\" , value = subtract_trace ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF !! Compute (I - XnS)Xn CALL IncrementMatrix ( Identity , TempMat1 , - 1.0_NTREAL ) CALL ScaleMatrix ( TempMat1 , - 1.0_NTREAL ) CALL MatrixMultiply ( TempMat1 , NewDensity , TempMat2 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) !! Subtracted Version Xn - (I - XnS)Xn CALL CopyMatrix ( NewDensity , SubtractBranch ) CALL IncrementMatrix ( TempMat2 , SubtractBranch , - 1.0_NTREAL ) !! Added Version Xn + (I - XnS)Xn CALL CopyMatrix ( NewDensity , AddBranch ) CALL IncrementMatrix ( TempMat2 , AddBranch ) END DO total_iterations = outer_counter - 1 IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = total_iterations ) CALL PrintMatrixInformation ( NewDensity ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( NewDensity , NewDensity , & & solver_parameters % BalancePermutation , memorypool_in = pool1 ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( WorkingDensity ) CALL DestructMatrix ( WorkingOverlap ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( TempMat1 ) CALL DestructMatrix ( TempMat2 ) CALL DestructMatrix ( AddBranch ) CALL DestructMatrix ( SubtractBranch ) CALL DestructMatrixMemoryPool ( pool1 ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE PurificationExtrapolate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a new guess at the Density Matrix after updating the geometry. !> Based on the lowdin algorithm in \\cite exner2002comparison . SUBROUTINE LowdinExtrapolate ( PreviousDensity , OldOverlap , NewOverlap , & & NewDensity , solver_parameters_in ) !> THe previous density to extrapolate from. TYPE ( Matrix_ps ), INTENT ( IN ) :: PreviousDensity !> The old overlap matrix from the previous geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: OldOverlap !> The new overlap matrix from the current geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: NewOverlap !> The extrapolated density. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: NewDensity !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Matrices TYPE ( Matrix_ps ) :: SQRMat TYPE ( Matrix_ps ) :: ISQMat TYPE ( Matrix_ps ) :: TempMat !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool1 !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Extrapolator\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , value = \"Lowdin\" ) CALL WriteCitation ( \"exner2002comparison\" ) CALL PrintParameters ( solver_parameters ) END IF CALL SquareRoot ( OldOverlap , SQRMat , solver_parameters ) CALL InverseSquareRoot ( NewOverlap , ISQMat , solver_parameters ) CALL MatrixMultiply ( SQRMat , PreviousDensity , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) CALL MatrixMultiply ( TempMat , SQRMat , NewDensity , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) CALL MatrixMultiply ( ISQMat , NewDensity , TempMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) CALL MatrixMultiply ( TempMat , ISQMat , NewDensity , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool1 ) IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( SQRMat ) CALL DestructMatrix ( ISQMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE LowdinExtrapolate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE GeometryOptimizationModule","tags":"","loc":"sourcefile/geometryoptimizationmodule.f90.html"},{"title":"ProcessGridModule.F90 – NTPoly","text":"Contents Modules ProcessGridModule Source Code ProcessGridModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to manage the process grid. MODULE ProcessGridModule USE ErrorModule , ONLY : Error_t , ConstructError , SetGenericError USE LoggingModule , ONLY : ActivateLogger , EnterSubLog , ExitSubLog , & & WriteHeader , WriteListElement USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING , ONLY : c_int , c_bool #ifdef _OPENMP USE omp_lib , ONLY : omp_get_num_threads #endif IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype which stores a process grid and all its communicators. TYPE , PUBLIC :: ProcessGrid_t !! Describe the grid INTEGER , PUBLIC :: total_processors !< total processors in the grid. INTEGER , PUBLIC :: num_process_rows !< number of rows in the grid. INTEGER , PUBLIC :: num_process_columns !< number of columns in the grid. INTEGER , PUBLIC :: num_process_slices !< number of 2D slices in the grid. INTEGER , PUBLIC :: slice_size !< the size of a 2D slice. !! Identiy current process INTEGER , PUBLIC :: my_slice !< which slice is the current process in. INTEGER , PUBLIC :: my_row !< which row is the current process in. INTEGER , PUBLIC :: my_column !< which column is the current process in. !! Ranks for communication INTEGER , PUBLIC :: global_rank !< current process's rank amongst processes. !> rank for within slice communication. INTEGER , PUBLIC :: within_slice_rank !> rank for between slice communication. INTEGER , PUBLIC :: between_slice_rank INTEGER , PUBLIC :: column_rank !< rank for within column communication. INTEGER , PUBLIC :: row_rank !< rank for within row communication. !! Communicators for communication INTEGER , PUBLIC :: global_comm !< communicator with every other process. INTEGER , PUBLIC :: row_comm !< communicator within a row. INTEGER , PUBLIC :: column_comm !< communicator within a column. INTEGER , PUBLIC :: within_slice_comm !< communicator within a slice. INTEGER , PUBLIC :: between_slice_comm !< communicator between slices. INTEGER , PUBLIC :: grid_error !< stores errors from MPI calls. INTEGER , PUBLIC :: RootID = 0 !< Which rank is root? !! Blocked communication INTEGER , PUBLIC :: block_multiplier !< Block scaling factor. INTEGER , PUBLIC :: number_of_blocks_columns !< number of column blocks. INTEGER , PUBLIC :: number_of_blocks_rows !< number of row blocks. !> blocked communicator within a row. INTEGER , DIMENSION (:), ALLOCATABLE , PUBLIC :: blocked_row_comm !> blocked communicator within a column. INTEGER , DIMENSION (:), ALLOCATABLE , PUBLIC :: blocked_column_comm !> blocked communicator within a slice. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: blocked_within_slice_comm !> blocked communicator between slices. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: blocked_between_slice_comm END TYPE ProcessGrid_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The default process grid. TYPE ( ProcessGrid_t ), TARGET , PUBLIC :: global_grid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructProcessGrid PUBLIC :: ConstructNewProcessGrid PUBLIC :: IsRoot PUBLIC :: SplitProcessGrid PUBLIC :: CopyProcessGrid PUBLIC :: DestructProcessGrid !! Accessors for grid information PUBLIC :: GetMySlice PUBLIC :: GetMyRow PUBLIC :: GetMyColumn !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructProcessGrid MODULE PROCEDURE ConstructProcessGrid_full MODULE PROCEDURE ConstructProcessGrid_onlyslice END INTERFACE INTERFACE ConstructNewProcessGrid MODULE PROCEDURE ConstructNewProcessGrid_full MODULE PROCEDURE ConstructNewProcessGrid_onlyslice END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup the default process grid. SUBROUTINE ConstructProcessGrid_full ( world_comm_ , process_rows_ , & & process_columns_ , process_slices_ , be_verbose_in ) !> A communicator that every process in the grid is a part of. INTEGER ( kind = c_int ), INTENT ( IN ) :: world_comm_ !> The number of grid rows. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_rows_ !> The number of grid columns. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_columns_ !> The number of grid slices. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_slices_ !> Set true to print process grid info. LOGICAL ( kind = c_bool ), INTENT ( IN ), OPTIONAL :: be_verbose_in !! Local Data LOGICAL :: be_verbose !! Process Optional Parameters IF ( PRESENT ( be_verbose_in )) THEN be_verbose = be_verbose_in ELSE be_verbose = . FALSE . END IF CALL ConstructNewProcessGrid ( global_grid , world_comm_ , process_rows_ , & & process_columns_ , process_slices_ ) !! Report IF ( IsRoot ( global_grid )) THEN CALL ActivateLogger END IF IF ( be_verbose ) THEN CALL WriteHeader ( \"Process Grid\" ) CALL EnterSubLog CALL WriteListElement ( \"Process Rows\" , & & value = global_grid % num_process_rows ) CALL WriteListElement ( key = \"Process Columns\" , & & value = global_grid % num_process_columns ) CALL WriteListElement ( key = \"Process Slices\" , & & value = global_grid % num_process_slices ) CALL WriteListElement ( key = \"Column Blocks\" , & & value = global_grid % number_of_blocks_columns ) CALL WriteListElement ( key = \"Row Blocks\" , & & value = global_grid % number_of_blocks_rows ) CALL ExitSubLog END IF END SUBROUTINE ConstructProcessGrid_full !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup a process grid specifying only the slices SUBROUTINE ConstructProcessGrid_onlyslice ( world_comm_ , process_slices_in , & & be_verbose_in ) !> A communicator that every process in the grid is a part of. INTEGER ( kind = c_int ), INTENT ( IN ) :: world_comm_ !> The number of grid slices. INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: process_slices_in !> Set true to print process grid info. LOGICAL ( kind = c_bool ), INTENT ( IN ), OPTIONAL :: be_verbose_in !! Local Data LOGICAL ( kind = c_bool ) :: be_verbose INTEGER :: process_rows , process_columns , process_slices INTEGER :: total_processors INTEGER :: ierr !! Total processors CALL MPI_COMM_SIZE ( world_comm_ , total_processors , ierr ) !! Process Optional Parameters IF ( PRESENT ( be_verbose_in )) THEN be_verbose = be_verbose_in ELSE be_verbose = . FALSE . END IF IF ( PRESENT ( process_slices_in )) THEN process_slices = process_slices_in ELSE CALL ComputeNumSlices ( total_processors , process_slices ) END IF !! Create a 3D grid CALL ComputeGridSize ( total_processors , process_slices , process_rows , & & process_columns ) !! Now call the full setup CALL ConstructProcessGrid ( world_comm_ , process_rows , process_columns , & & process_slices , be_verbose ) END SUBROUTINE ConstructProcessGrid_onlyslice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a process grid. SUBROUTINE ConstructNewProcessGrid_full ( grid , world_comm_ , process_rows_ , & & process_columns_ , process_slices_ ) !> The grid to construct TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: grid !> A communicator that every process in the grid is a part of. INTEGER ( kind = c_int ), INTENT ( IN ) :: world_comm_ !> The number of grid rows. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_rows_ !> The number of grid columns. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_columns_ !> The number of grid slices. INTEGER ( kind = c_int ), INTENT ( IN ) :: process_slices_ !! Local Data INTEGER :: column_block_multiplier INTEGER :: row_block_multiplier INTEGER :: II , JJ #ifdef _OPENMP INTEGER :: num_threads #endif INTEGER :: ierr TYPE ( Error_t ) :: err CALL ConstructError ( err ) CALL MPI_COMM_DUP ( world_comm_ , grid % global_comm , ierr ) !! Grid Dimensions grid % num_process_rows = process_rows_ grid % num_process_columns = process_columns_ grid % num_process_slices = process_slices_ CALL MPI_COMM_SIZE ( grid % global_comm , grid % total_processors , ierr ) grid % slice_size = grid % total_processors / grid % num_process_slices !! Do a sanity check IF ( grid % num_process_rows * grid % num_process_columns * grid % num_process_slices & & . NE . grid % total_processors ) THEN CALL SetGenericError ( err , \"you didn't specify a consistent process& & grid size\" , . TRUE .) END IF IF ( grid % num_process_slices . GT . 1 ) THEN IF ( MOD ( MAX ( grid % num_process_rows , grid % num_process_columns ), & & MIN ( grid % num_process_rows , grid % num_process_columns )) & & . NE . 0 ) THEN CALL SetGenericError ( err , \"when using slices >1, either rows& & or columns must be a multiple of the other.\" , . TRUE .) END IF END IF !! Grid ID CALL MPI_COMM_RANK ( grid % global_comm , grid % global_rank , ierr ) grid % my_slice = grid % global_rank / grid % slice_size grid % my_row = MOD ( grid % global_rank , grid % slice_size ) / grid % num_process_columns grid % my_column = MOD ( grid % global_rank , grid % num_process_columns ) !! Grid Communicators CALL MPI_COMM_SPLIT ( grid % global_comm , grid % my_slice , grid % global_rank , & grid % within_slice_comm , ierr ) CALL MPI_COMM_RANK ( grid % within_slice_comm , grid % within_slice_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % global_comm , grid % within_slice_rank , & & grid % global_rank , grid % between_slice_comm , ierr ) CALL MPI_COMM_RANK ( grid % between_slice_comm , grid % between_slice_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_row , grid % global_rank , & & grid % row_comm , ierr ) CALL MPI_COMM_RANK ( grid % row_comm , grid % row_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_column , & & grid % global_rank , grid % column_comm , ierr ) CALL MPI_COMM_RANK ( grid % column_comm , grid % column_rank , ierr ) !! Blocking Information column_block_multiplier = ( grid % num_process_rows / grid % num_process_columns ) * & & grid % num_process_slices IF ( column_block_multiplier . EQ . 0 ) THEN column_block_multiplier = 1 * grid % num_process_slices END IF row_block_multiplier = ( grid % num_process_columns / grid % num_process_rows ) * & & grid % num_process_slices IF ( row_block_multiplier . EQ . 0 ) THEN row_block_multiplier = 1 * grid % num_process_slices END IF !! The rule right now seems to be to have at least half as many blocks as !! threads. #if defined NOBLOCK grid % block_multiplier = 1 #elif defined _OPENMP !$omp PARALLEL num_threads = omp_get_num_threads () !$omp end PARALLEL grid % block_multiplier = num_threads / & & ( column_block_multiplier + row_block_multiplier ) IF ( grid % block_multiplier . EQ . 0 ) THEN grid % block_multiplier = 1 END IF #else grid % block_multiplier = 1 #endif grid % number_of_blocks_columns = & & column_block_multiplier * grid % block_multiplier grid % number_of_blocks_rows = & & row_block_multiplier * grid % block_multiplier !! Create Blocked Communicators ALLOCATE ( grid % blocked_row_comm ( grid % number_of_blocks_rows )) ALLOCATE ( grid % blocked_column_comm ( grid % number_of_blocks_columns )) ALLOCATE ( grid % blocked_within_slice_comm ( grid % number_of_blocks_rows , & & grid % number_of_blocks_columns )) ALLOCATE ( grid % blocked_between_slice_comm ( grid % number_of_blocks_rows , & & grid % number_of_blocks_columns )) DO JJ = 1 , grid % number_of_blocks_columns DO II = 1 , grid % number_of_blocks_rows CALL MPI_COMM_SPLIT ( grid % global_comm , grid % my_slice , & & grid % global_rank , grid % blocked_within_slice_comm ( II , JJ ), & & ierr ) CALL MPI_COMM_SPLIT ( grid % global_comm , grid % within_slice_rank , & & grid % global_rank , grid % blocked_between_slice_comm ( II , JJ ), & & ierr ) END DO END DO DO JJ = 1 , grid % number_of_blocks_columns CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_column , & & grid % global_rank , grid % blocked_column_comm ( JJ ), ierr ) END DO DO II = 1 , grid % number_of_blocks_rows CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_row , & & grid % global_rank , grid % blocked_row_comm ( II ), ierr ) END DO END SUBROUTINE ConstructNewProcessGrid_full !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup a process grid specifying only the slices SUBROUTINE ConstructNewProcessGrid_onlyslice ( grid , world_comm_ , & & process_slices_in ) !> The grid to construct TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: grid !> A communicator that every process in the grid is a part of. INTEGER ( kind = c_int ), INTENT ( IN ) :: world_comm_ !> The number of grid slices. INTEGER ( kind = c_int ), INTENT ( IN ), OPTIONAL :: process_slices_in !! Local Data LOGICAL :: be_verbose INTEGER :: process_rows , process_columns , process_slices INTEGER :: total_processors INTEGER :: ierr !! Total processors CALL MPI_COMM_SIZE ( world_comm_ , total_processors , ierr ) !! Process Optional Parameters IF ( PRESENT ( process_slices_in )) THEN process_slices = process_slices_in ELSE CALL ComputeNumSlices ( total_processors , process_slices ) END IF WRITE ( * , * ) \"COMPUTED NUMBER OF SLICES\" , process_slices !! Create a 3D grid CALL ComputeGridSize ( total_processors , process_slices , process_rows , & & process_columns ) !! Now call the full setup CALL ConstructNewProcessGrid ( grid , world_comm_ , process_rows , & & process_columns , process_slices ) END SUBROUTINE ConstructNewProcessGrid_onlyslice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a process grid. !! Note that this makes a complete and independent copy of the process grid. !! Which of course means that whatever is currently stored in new_grid will !! be destroyed, so don't leave any matrices pointing to it. SUBROUTINE CopyProcessGrid ( old_grid , new_grid ) !> The grid to copy. TYPE ( ProcessGrid_t ), INTENT ( IN ) :: old_grid !> New_grid = old_grid TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: new_grid INTEGER :: II , JJ , ierr !! Safe Copy CALL DestructProcessGrid ( new_grid ) !! Copy all the basic data about a process new_grid % total_processors = old_grid % total_processors new_grid % num_process_rows = old_grid % num_process_rows new_grid % num_process_columns = old_grid % num_process_columns new_grid % num_process_slices = old_grid % num_process_slices new_grid % slice_size = old_grid % slice_size new_grid % my_slice = old_grid % my_slice new_grid % my_row = old_grid % my_row new_grid % my_column = old_grid % my_column new_grid % global_rank = old_grid % global_rank new_grid % within_slice_rank = old_grid % within_slice_rank new_grid % between_slice_rank = old_grid % between_slice_rank new_grid % column_rank = old_grid % column_rank new_grid % row_rank = old_grid % row_rank new_grid % block_multiplier = old_grid % block_multiplier new_grid % number_of_blocks_columns = old_grid % number_of_blocks_columns new_grid % number_of_blocks_rows = old_grid % number_of_blocks_rows !! Allocate Blocks ALLOCATE ( new_grid % blocked_row_comm ( old_grid % number_of_blocks_rows )) ALLOCATE ( new_grid % blocked_column_comm ( old_grid % number_of_blocks_columns )) ALLOCATE ( new_grid % blocked_within_slice_comm (& & old_grid % number_of_blocks_rows , old_grid % number_of_blocks_columns )) ALLOCATE ( new_grid % blocked_between_slice_comm ( & & old_grid % number_of_blocks_rows , old_grid % number_of_blocks_columns )) !! Copy the communicators DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_row_comm ( II ), & & new_grid % blocked_row_comm ( II ), ierr ) END DO DO JJ = 1 , new_grid % number_of_blocks_columns CALL MPI_COMM_DUP ( old_grid % blocked_column_comm ( JJ ), & & new_grid % blocked_column_comm ( JJ ), ierr ) END DO DO JJ = 1 , new_grid % number_of_blocks_columns DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_within_slice_comm ( II , JJ ), & & new_grid % blocked_within_slice_comm ( II , JJ ), ierr ) END DO END DO DO JJ = 1 , new_grid % number_of_blocks_columns DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_between_slice_comm ( II , JJ ), & & new_grid % blocked_between_slice_comm ( II , JJ ), ierr ) END DO END DO CALL MPI_COMM_DUP ( old_grid % global_comm , new_grid % global_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % row_comm , new_grid % row_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % column_comm , new_grid % column_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % within_slice_comm , new_grid % within_slice_comm , & & ierr ) CALL MPI_COMM_DUP ( old_grid % between_slice_comm , & & new_grid % between_slice_comm , ierr ) END SUBROUTINE CopyProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a process grid. !! Be careful about doing this. Matrices have pointers to process grids. If !! you destruct a process grid without destructing the matrices pointing to !! it, they will become unusable. RECURSIVE SUBROUTINE DestructProcessGrid ( grid_in ) !> The grid to destruct. If none specified this destroys the global grid. TYPE ( ProcessGrid_t ), OPTIONAL , INTENT ( INOUT ) :: grid_in !! Counters INTEGER :: II , JJ INTEGER :: Ierr !! Handle optional parameters IF (. NOT . PRESENT ( grid_in )) THEN CALL DestructProcessGrid ( global_grid ) ELSE !! Destruct IF ( ALLOCATED ( grid_in % blocked_row_comm )) THEN CALL MPI_COMM_FREE ( grid_in % global_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % row_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % column_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % within_slice_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % between_slice_comm , ierr ) DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_row_comm ( II ), ierr ) END DO DEALLOCATE ( grid_in % blocked_row_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_column_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns CALL MPI_COMM_FREE ( grid_in % blocked_column_comm ( JJ ), ierr ) END DO DEALLOCATE ( grid_in % blocked_column_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_within_slice_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_within_slice_comm ( II , JJ ), & & ierr ) END DO END DO DEALLOCATE ( grid_in % blocked_within_slice_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_between_slice_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_between_slice_comm ( II , JJ ), & & ierr ) END DO END DO DEALLOCATE ( grid_in % blocked_between_slice_comm ) END IF END IF END SUBROUTINE DestructProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a process grid, this splits it into two grids of even size SUBROUTINE SplitProcessGrid ( old_grid , new_grid , my_color , split_slice , & & between_grid_comm ) !> The old grid to split TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: old_grid !> The new grid that we are creating TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: new_grid !> A color value indicating which set this process was split into INTEGER , INTENT ( OUT ) :: my_color !> True if we were able to split along slices. LOGICAL , INTENT ( OUT ) :: split_slice !> A communicator for sending messages between groups. INTEGER , INTENT ( OUT ) :: between_grid_comm !! Local Variables - new grid INTEGER :: new_comm INTEGER :: rows , cols , slices INTEGER :: midpoint !! For Between Comm INTEGER :: between_color , between_rank INTEGER :: left_grid_size !! Temporary INTEGER :: ierr split_slice = . FALSE . !! Handle base case IF ( old_grid % total_processors . EQ . 1 ) THEN rows = 1 cols = 1 slices = 1 my_color = 0 between_rank = 0 !! First preferentially try to split along slices ELSE IF ( old_grid % num_process_slices . GT . 1 ) THEN midpoint = old_grid % num_process_slices / 2 cols = old_grid % num_process_columns rows = old_grid % num_process_rows IF ( old_grid % my_slice . LT . midpoint ) THEN my_color = 0 slices = midpoint ELSE my_color = 1 slices = old_grid % num_process_slices - midpoint END IF between_rank = old_grid % my_slice split_slice = . TRUE . left_grid_size = midpoint * cols * rows !! Next try to split the bigger direction ELSE IF ( old_grid % num_process_rows . GT . old_grid % num_process_columns ) THEN midpoint = old_grid % num_process_rows / 2 cols = old_grid % num_process_columns slices = 1 IF ( old_grid % my_row . LT . midpoint ) THEN my_color = 0 rows = midpoint ELSE my_color = 1 rows = old_grid % num_process_rows - midpoint END IF between_rank = old_grid % my_row left_grid_size = midpoint * cols * slices !! Default Case ELSE midpoint = old_grid % num_process_columns / 2 slices = 1 rows = old_grid % num_process_rows IF ( old_grid % my_column . LT . midpoint ) THEN my_color = 0 cols = midpoint ELSE my_color = 1 cols = old_grid % num_process_columns - midpoint END IF between_rank = old_grid % my_column left_grid_size = midpoint * slices * rows END IF !! Construct CALL MPI_COMM_SPLIT ( old_grid % global_comm , my_color , old_grid % global_rank , & & new_comm , ierr ) CALL ConstructNewProcessGrid ( new_grid , new_comm , rows , cols , slices ) !! For sending data between grids between_color = MOD ( new_grid % global_rank , left_grid_size ) CALL MPI_COMM_SPLIT ( old_grid % global_comm , between_color , between_rank , & & between_grid_comm , ierr ) END SUBROUTINE SplitProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Check if the current process is the root process. FUNCTION IsRoot ( grid ) RESULT ( is_root ) !! Parameters !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ) :: grid !> True if the current process is root. LOGICAL :: is_root IF ( grid % global_rank == 0 ) THEN is_root = . TRUE . ELSE is_root = . FALSE . END IF END FUNCTION IsRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the slice of the current process. FUNCTION GetMySlice ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> Slice number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_slice ELSE return_val = global_grid % my_slice END IF END FUNCTION GetMySlice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the column of the current process. FUNCTION GetMyColumn ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> The column number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_column ELSE return_val = global_grid % my_column END IF END FUNCTION GetMyColumn !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the row of the current process. FUNCTION GetMyRow ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> The row number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_row ELSE return_val = global_grid % my_row END IF END FUNCTION GetMyRow !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sometimes we only want to specify a process grid's number of slices !! and then automatically compute the right number of rows and columns. SUBROUTINE ComputeGridSize ( total_processors , set_slices , rows , columns ) !> Total processors in the grid INTEGER , INTENT ( IN ) :: total_processors !> Desired number of slices INTEGER , INTENT ( IN ) :: set_slices !> Computed number of rows INTEGER , INTENT ( OUT ) :: rows !> Computed number of columns INTEGER , INTENT ( OUT ) :: columns !! Local variables INTEGER :: slice_size , size_search INTEGER :: II rows = 1 columns = 1 slice_size = total_processors / set_slices size_search = FLOOR ( SQRT ( REAL ( slice_size ))) DO II = size_search , 1 , - 1 IF ( MOD ( slice_size , II ) . EQ . 0 ) THEN rows = II columns = slice_size / II EXIT END IF END DO END SUBROUTINE ComputeGridSize !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pick an appropriate number of process slices for this calculation. !> This routine will focus on whether we can make a square slice grid, !> which gives pretty ideal performance. SUBROUTINE ComputeNumSlices ( total_processors , slices ) !> Total processors in the grid. INTEGER , INTENT ( IN ) :: total_processors !> Number of slices to use. INTEGER , INTENT ( OUT ) :: slices !! Local Variables INTEGER :: slice_size INTEGER :: slice_dim LOGICAL :: found !! Try manually values [4, 3, 2]. If they don't work, give up and use 1. found = . FALSE . DO slices = MIN ( 4 , total_processors ), 2 , - 1 slice_size = total_processors / slices IF ( slice_size * slices . NE . total_processors ) CYCLE slice_dim = FLOOR ( SQRT ( REAL ( slice_size ))) IF ( slice_dim * slice_dim . EQ . slice_size ) THEN FOUND = . TRUE . EXIT END IF END DO IF (. NOT . FOUND ) slices = 1 END SUBROUTINE ComputeNumSlices !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ProcessGridModule","tags":"","loc":"sourcefile/processgridmodule.f90.html"},{"title":"TripletModule.F90 – NTPoly","text":"Contents Modules TripletModule Source Code TripletModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Storing Triplets of Integer, Integer, Value. MODULE TripletModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING , ONLY : c_int IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a triplet of integer, integer, double. !> As this is related to matrix multiplication, the referencing indices are !> rows and columns. TYPE , PUBLIC :: Triplet_r INTEGER ( kind = c_int ) :: index_column !< column value. INTEGER ( kind = c_int ) :: index_row !< row value. REAL ( NTREAL ) :: point_value !< actual value at those indices. END TYPE Triplet_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a triplet of integer, integer, complex. !> As this is related to matrix multiplication, the referencing indices are !> rows and columns. TYPE , PUBLIC :: Triplet_c INTEGER ( kind = c_int ) :: index_column !< column value. INTEGER ( kind = c_int ) :: index_row !< row value. COMPLEX ( NTCOMPLEX ) :: point_value !< actual value at those indices. END TYPE Triplet_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SetTriplet PUBLIC :: GetTripletValues PUBLIC :: CompareTriplets PUBLIC :: GetMPITripletType_r PUBLIC :: GetMPITripletType_c PUBLIC :: ConvertTripletType !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE SetTriplet MODULE PROCEDURE SetTriplet_r MODULE PROCEDURE SetTriplet_c END INTERFACE INTERFACE GetTripletValues MODULE PROCEDURE GetTripletValues_r MODULE PROCEDURE GetTripletValues_c END INTERFACE INTERFACE CompareTriplets MODULE PROCEDURE CompareTriplets_r MODULE PROCEDURE CompareTriplets_c END INTERFACE INTERFACE ConvertTripletType MODULE PROCEDURE ConvertTripletToReal MODULE PROCEDURE ConvertTripletToComplex END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the values of a triplet. PURE SUBROUTINE SetTriplet_r ( this , index_column , index_row , point_value ) !> The triplet to set the values of. TYPE ( Triplet_r ), INTENT ( INOUT ) :: this !> The column value. INTEGER , INTENT ( IN ) :: index_column !> The row value. INTEGER , INTENT ( IN ) :: index_row !> The value at that point. REAL ( NTREAL ), INTENT ( IN ) :: point_value INCLUDE \"triplet_includes/SetTriplet.f90\" END SUBROUTINE SetTriplet_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the values of a triplet. PURE SUBROUTINE SetTriplet_c ( this , index_column , index_row , point_value ) !> The triplet to set the values of. TYPE ( Triplet_c ), INTENT ( INOUT ) :: this !> The column value. INTEGER , INTENT ( IN ) :: index_column !> The row value. INTEGER , INTENT ( IN ) :: index_row !> The value at that point. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: point_value INCLUDE \"triplet_includes/SetTriplet.f90\" END SUBROUTINE SetTriplet_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the values of a triplet. PURE SUBROUTINE GetTripletValues_r ( this , index_column , index_row , point_value ) !> The triplet to extract the values of. TYPE ( Triplet_r ), INTENT ( IN ) :: this !> Column value. INTEGER , INTENT ( OUT ) :: index_column !> Row value. INTEGER , INTENT ( OUT ) :: index_row !> Actual stored value. REAL ( NTREAL ), INTENT ( OUT ) :: point_value INCLUDE \"triplet_includes/GetTriplet.f90\" END SUBROUTINE GetTripletValues_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the values of a triplet. PURE SUBROUTINE GetTripletValues_c ( this , index_column , index_row , point_value ) !> The triplet to extract the values of. TYPE ( Triplet_c ), INTENT ( IN ) :: this !> Column value. INTEGER , INTENT ( OUT ) :: index_column !> Row value. INTEGER , INTENT ( OUT ) :: index_row !> Actual stored value. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: point_value INCLUDE \"triplet_includes/GetTriplet.f90\" END SUBROUTINE GetTripletValues_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compare two triplets based on their index values, first by column and !> second by row. Returns A < B. PURE FUNCTION CompareTriplets_r ( tripA , tripB ) RESULT ( islessthan ) !> First triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: tripA !> Second triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: tripB !> A < B. LOGICAL :: islessthan INCLUDE \"triplet_includes/CompareTriplets.f90\" END FUNCTION CompareTriplets_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compare two triplets based on their index values, first by column and !> second by row. Returns A < B. PURE FUNCTION CompareTriplets_c ( tripA , tripB ) RESULT ( islessthan ) !> First triplet. TYPE ( Triplet_c ), INTENT ( IN ) :: tripA !> Second triplet. TYPE ( Triplet_c ), INTENT ( IN ) :: tripB !> A < B. LOGICAL :: islessthan INCLUDE \"triplet_includes/CompareTriplets.f90\" END FUNCTION CompareTriplets_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Returns an MPI Derived Data Type For A Triplet. !> We statically store this derived type so that we don't have to recreate !> it every time this function is called. Thus this functional call should !> add very little overhead. FUNCTION GetMPITripletType_r () RESULT ( mpi_triplet_type ) !> MPI Derived Type INTEGER :: mpi_triplet_type !! Local Data INTEGER , DIMENSION ( 3 ) :: triplet_sub_types INTEGER , DIMENSION ( 3 ) :: triplet_displacement INTEGER , DIMENSION ( 3 ) :: triplet_block_length INTEGER :: bytes_per_int INTEGER :: bytes_per_double INTEGER :: ierr CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) CALL MPI_Type_extent ( MPINTREAL , bytes_per_double , ierr ) triplet_block_length ( 1 ) = 1 triplet_block_length ( 2 ) = 1 triplet_block_length ( 3 ) = 1 triplet_displacement ( 1 ) = 0 triplet_displacement ( 2 ) = bytes_per_int + triplet_displacement ( 1 ) triplet_displacement ( 3 ) = bytes_per_int + triplet_displacement ( 2 ) triplet_sub_types ( 1 ) = MPINTINTEGER triplet_sub_types ( 2 ) = MPINTINTEGER triplet_sub_types ( 3 ) = MPINTREAL CALL MPI_Type_struct ( 3 , triplet_block_length , triplet_displacement ,& & triplet_sub_types , mpi_triplet_type , ierr ) CALL MPI_Type_commit ( mpi_triplet_type , ierr ) END FUNCTION GetMPITripletType_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Returns an MPI Derived Data Type For A Triplet. !> We statically store this derived type so that we don't have to recreate !> it every time this function is called. Thus this functional call should !> add very little overhead. FUNCTION GetMPITripletType_c () RESULT ( mpi_triplet_type ) !> MPI Derived Type INTEGER :: mpi_triplet_type !! Local Data INTEGER , DIMENSION ( 3 ) :: triplet_sub_types INTEGER , DIMENSION ( 3 ) :: triplet_displacement INTEGER , DIMENSION ( 3 ) :: triplet_block_length INTEGER :: bytes_per_int INTEGER :: bytes_per_double INTEGER :: ierr CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) CALL MPI_Type_extent ( MPINTCOMPLEX , bytes_per_double , ierr ) triplet_block_length ( 1 ) = 1 triplet_block_length ( 2 ) = 1 triplet_block_length ( 3 ) = 1 triplet_displacement ( 1 ) = 0 triplet_displacement ( 2 ) = bytes_per_int + triplet_displacement ( 1 ) triplet_displacement ( 3 ) = bytes_per_int + triplet_displacement ( 2 ) triplet_sub_types ( 1 ) = MPINTINTEGER triplet_sub_types ( 2 ) = MPINTINTEGER triplet_sub_types ( 3 ) = MPINTCOMPLEX CALL MPI_Type_struct ( 3 , triplet_block_length , triplet_displacement ,& & triplet_sub_types , mpi_triplet_type , ierr ) CALL MPI_Type_commit ( mpi_triplet_type , ierr ) END FUNCTION GetMPITripletType_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex triplet to a real triplet. SUBROUTINE ConvertTripletToReal ( cin_triplet , rout_triplet ) !> The starting triplet TYPE ( Triplet_c ), INTENT ( IN ) :: cin_triplet !> Real valued triplet. TYPE ( Triplet_r ), INTENT ( INOUT ) :: rout_triplet rout_triplet % index_row = cin_triplet % index_row rout_triplet % index_column = cin_triplet % index_column rout_triplet % point_value = REAL ( cin_triplet % point_value ) END SUBROUTINE ConvertTripletToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real triplet to a complex triplet. SUBROUTINE ConvertTripletToComplex ( rin_triplet , cout_triplet ) !> The starting triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: rin_triplet !> Complex valued triplet. TYPE ( Triplet_c ), INTENT ( INOUT ) :: cout_triplet cout_triplet % index_row = rin_triplet % index_row cout_triplet % index_column = rin_triplet % index_column cout_triplet % point_value = CMPLX ( rin_triplet % point_value , 0 , KIND = NTCOMPLEX ) END SUBROUTINE ConvertTripletToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TripletModule","tags":"","loc":"sourcefile/tripletmodule.f90.html"},{"title":"LoggingModule.F90 – NTPoly","text":"Contents Modules LoggingModule Source Code LoggingModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for writing data to the log file. MODULE LoggingModule USE DataTypesModule , ONLY : NTReal IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTEGER :: CurrentLevel = 0 LOGICAL :: IsActive = . FALSE . !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ActivateLogger PUBLIC :: DeactivateLogger PUBLIC :: EnterSubLog PUBLIC :: WriteHeader PUBLIC :: WriteListElement PUBLIC :: WriteElement PUBLIC :: WriteCitation PUBLIC :: ExitSubLog !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE WriteListElement MODULE PROCEDURE WriteListElement_bool MODULE PROCEDURE WriteListElement_float MODULE PROCEDURE WriteListElement_int MODULE PROCEDURE WriteListElement_string END INTERFACE INTERFACE WriteElement MODULE PROCEDURE WriteElement_bool MODULE PROCEDURE WriteElement_float MODULE PROCEDURE WriteElement_int MODULE PROCEDURE WriteElement_string END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Activate the logger. SUBROUTINE ActivateLogger IsActive = . TRUE . END SUBROUTINE ActivateLogger !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deactivate the logger. SUBROUTINE DeactivateLogger IsActive = . FALSE . END SUBROUTINE DeactivateLogger !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Call this subroutine when you enter into a section with verbose output SUBROUTINE EnterSubLog CurrentLevel = CurrentLevel + 1 END SUBROUTINE EnterSubLog !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Call this subroutine when you exit a section with verbose output SUBROUTINE ExitSubLog CurrentLevel = CurrentLevel - 1 END SUBROUTINE ExitSubLog !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a header to the log. SUBROUTINE WriteHeader ( header_value ) !> The text of the header. CHARACTER ( LEN =* ), INTENT ( IN ) :: header_value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) header_value WRITE ( * , '(A1)' ) \":\" END IF END SUBROUTINE WriteHeader !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_bool ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. LOGICAL , INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) key IF ( value ) THEN WRITE ( * , '(A)' , ADVANCE = 'no' ) \": True\" ELSE WRITE ( * , '(A)' , ADVANCE = 'no' ) \": False\" END IF WRITE ( * , * ) END IF END SUBROUTINE WriteElement_bool !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_float ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A float value to write. REAL ( NTReal ), INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(ES22.14)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteElement_float !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_int ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. INTEGER , INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(I10)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteElement_int !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_string ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A text value to write. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(A)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteElement_string !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_bool ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A bool value to write. LOGICAL , INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( * , '(A)' , ADVANCE = 'no' ) key IF ( value ) THEN WRITE ( * , '(A)' , ADVANCE = 'no' ) \": True\" ELSE WRITE ( * , '(A)' , ADVANCE = 'no' ) \": False\" END IF WRITE ( * , * ) END IF END SUBROUTINE WriteListElement_bool !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_float ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A float value to write. REAL ( NTReal ), INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(ES22.14)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteListElement_float !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_int ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. INTEGER , INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(I10)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteListElement_int !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_string ( key , value ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A text value to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: value IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( * , '(A)' , ADVANCE = 'no' ) key WRITE ( * , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( * , '(A)' , ADVANCE = 'no' ) value WRITE ( * , * ) END IF END SUBROUTINE WriteListElement_string !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a citation element. SUBROUTINE WriteCitation ( citation_list ) !> A list of citations, separated by a space. CHARACTER ( LEN =* ), INTENT ( IN ) :: citation_list INTEGER :: pos1 , pos2 IF ( IsActive ) THEN CALL WriteIndent WRITE ( * , '(A)' ) \"Citations:\" CALL EnterSubLog pos1 = 1 pos2 = INDEX ( citation_list ( pos1 :), ' ' ) DO WHILE ( pos2 . NE . 0 ) CALL WriteIndent WRITE ( * , '(A)' ) citation_list ( pos1 : pos1 + pos2 - 1 ) pos1 = pos1 + pos2 pos2 = INDEX ( citation_list ( pos1 :), ' ' ) END DO CALL WriteIndent WRITE ( * , '(A)' ) citation_list ( pos1 :) CALL ExitSubLog END IF END SUBROUTINE WriteCitation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Writes out the indentation needed for this level SUBROUTINE WriteIndent INTEGER :: counter DO counter = 1 , CurrentLevel * 2 WRITE ( * , '(A1)' , ADVANCE = 'NO' ) \" \" END DO END SUBROUTINE WriteIndent !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LoggingModule","tags":"","loc":"sourcefile/loggingmodule.f90.html"},{"title":"PSMatrixAlgebraModule.F90 – NTPoly","text":"Contents Modules PSMatrixAlgebraModule Source Code PSMatrixAlgebraModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Performing Distributed Sparse Matrix Algebra Operations. MODULE PSMatrixAlgebraModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX USE GemmTasksModule USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & CheckMemoryPoolValidity , DestructMatrixMemoryPool USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , ConvertMatrixToComplex , ConjugateMatrix , & & MergeMatrixLocalBlocks USE MatrixReduceModule , ONLY : ReduceHelper_t , ReduceAndComposeMatrixSizes , & & ReduceAndComposeMatrixData , ReduceAndComposeMatrixCleanup , & & ReduceANdSumMatrixSizes , ReduceAndSumMatrixData , & & ReduceAndSumMatrixCleanup , TestReduceSizeRequest , & & TestReduceInnerRequest , TestReduceDataRequest USE SMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixGrandSum , & & PairwiseMultiplyMatrix , IncrementMatrix , ScaleMatrix , & & MatrixColumnNorm USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , CopyMatrix ,& & TransposeMatrix , ComposeMatrixColumns , MatrixToTripletList USE TimerModule , ONLY : StartTimer , StopTimer USE TripletListModule , ONLY : TripletList_r , TripletList_c USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MatrixSigma PUBLIC :: MatrixMultiply PUBLIC :: MatrixGrandSum PUBLIC :: PairwiseMultiplyMatrix PUBLIC :: MatrixNorm PUBLIC :: DotMatrix PUBLIC :: IncrementMatrix PUBLIC :: ScaleMatrix PUBLIC :: MatrixTrace !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MatrixSigma MODULE PROCEDURE MatrixSigma_ps END INTERFACE INTERFACE MatrixMultiply MODULE PROCEDURE MatrixMultiply_ps END INTERFACE INTERFACE MatrixGrandSum MODULE PROCEDURE MatrixGrandSum_psr MODULE PROCEDURE MatrixGrandSum_psc END INTERFACE INTERFACE PairwiseMultiplyMatrix MODULE PROCEDURE PairwiseMultiplyMatrix_ps END INTERFACE INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_ps END INTERFACE INTERFACE DotMatrix MODULE PROCEDURE DotMatrix_psr MODULE PROCEDURE DotMatrix_psc END INTERFACE INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_ps END INTERFACE INTERFACE ScaleMatrix MODULE PROCEDURE ScaleMatrix_psr MODULE PROCEDURE ScaleMatrix_psc END INTERFACE INTERFACE MatrixTrace MODULE PROCEDURE MatrixTrace_psr END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute sigma for the inversion method. !> See \\cite ozaki2001efficient for details. SUBROUTINE MatrixSigma_ps ( this , sigma_value ) !> The matrix to compute the sigma value of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Sigma REAL ( NTREAL ), INTENT ( OUT ) :: sigma_value !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: column_sigma_contribution !! Counters/Temporary INTEGER :: inner_counter , outer_counter TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define LMAT merged_local_data_c #include \"distributed_algebra_includes/MatrixSigma.f90\" #undef LMAT ELSE #define LMAT merged_local_data_r #include \"distributed_algebra_includes/MatrixSigma.f90\" #undef LMAT ENDIF END SUBROUTINE MatrixSigma_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*matB+ beta*matC SUBROUTINE MatrixMultiply_ps ( matA , matB , matC , alpha_in , beta_in , & & threshold_in , memory_pool_in ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> matC = alpha*matA*matB + beta*matC TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC !> Scales the multiplication REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> A memory pool for the calculation. TYPE ( MatrixMemoryPool_p ), OPTIONAL , INTENT ( INOUT ) :: memory_pool_in !! Local Versions of Optional Parameter TYPE ( Matrix_ps ) :: matAConverted TYPE ( Matrix_ps ) :: matBConverted REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_p ) :: memory_pool !! Handle the optional parameters IF (. NOT . PRESENT ( alpha_in )) THEN alpha = 1.0d+0 ELSE alpha = alpha_in END IF IF (. NOT . PRESENT ( beta_in )) THEN beta = 0.0 ELSE beta = beta_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN threshold = 0.0 ELSE threshold = threshold_in END IF !! Setup Memory Pool IF ( PRESENT ( memory_pool_in )) THEN IF ( matA % is_complex ) THEN IF (. NOT . CheckMemoryPoolValidity ( memory_pool_in , matA )) THEN CALL DestructMatrixMemoryPool ( memory_pool_in ) memory_pool_in = MatrixMemoryPool_p ( matA ) END IF ELSE IF (. NOT . CheckMemoryPoolValidity ( memory_pool_in , matB )) THEN CALL DestructMatrixMemoryPool ( memory_pool_in ) memory_pool_in = MatrixMemoryPool_p ( matB ) END IF END IF ELSE IF ( matA % is_complex ) THEN memory_pool = MatrixMemoryPool_p ( matA ) ELSE memory_pool = MatrixMemoryPool_p ( matB ) END IF END IF !! Perform Upcasting IF ( matB % is_complex . AND . . NOT . matA % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , matAConverted ) IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_ps_imp ( matAConverted , matB , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_ps_imp ( matAConverted , matB , matC , alpha , beta , & & threshold , memory_pool ) END IF ELSE IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , matBConverted ) IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_ps_imp ( matA , matBConverted , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_ps_imp ( matA , matBConverted , matC , alpha , beta , & & threshold , memory_pool ) END IF ELSE IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_ps_imp ( matA , matB , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_ps_imp ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) END IF END IF CALL DestructMatrixMemoryPool ( memory_pool ) CALL DestructMatrix ( matAConverted ) CALL DestructMatrix ( matBConverted ) END SUBROUTINE MatrixMultiply_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The actual implementation of matrix multiply is here. Takes the !> same parameters as the standard multiply, but nothing is optional. SUBROUTINE MatrixMultiply_ps_imp ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) !! Parameters TYPE ( Matrix_ps ), INTENT ( IN ) :: matA TYPE ( Matrix_ps ), INTENT ( IN ) :: matB TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC REAL ( NTREAL ), INTENT ( IN ) :: alpha REAL ( NTREAL ), INTENT ( IN ) :: beta REAL ( NTREAL ), INTENT ( IN ) :: threshold TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: memory_pool TYPE ( Matrix_ps ) :: matAB !! Temporary Matrices TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: AdjacentABlocks_r TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: LocalRowContribution_r TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredRowContribution_r TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredRowContributionT_r TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: TransposedBBlocks_r TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: LocalColumnContribution_r TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredColumnContribution_r TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: SliceContribution_r TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: AdjacentABlocks_c TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: LocalRowContribution_c TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredRowContribution_c TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredRowContributionT_c TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: TransposedBBlocks_c TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: LocalColumnContribution_c TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredColumnContribution_c TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: SliceContribution_c !! Communication Helpers TYPE ( ReduceHelper_t ), DIMENSION (:), ALLOCATABLE :: row_helper TYPE ( ReduceHelper_t ), DIMENSION (:), ALLOCATABLE :: column_helper TYPE ( ReduceHelper_t ), DIMENSION (:,:), ALLOCATABLE :: slice_helper !! For Iterating Over Local Blocks INTEGER :: II , II2 INTEGER :: JJ , JJ2 INTEGER :: duplicate_start_column , duplicate_offset_column INTEGER :: duplicate_start_row , duplicate_offset_row REAL ( NTREAL ) :: working_threshold !! Scheduling the A work INTEGER , DIMENSION (:), ALLOCATABLE :: ATasks INTEGER :: ATasks_completed !! Scheduling the B work INTEGER , DIMENSION (:), ALLOCATABLE :: BTasks INTEGER :: BTasks_completed !! Scheduling the AB work INTEGER , DIMENSION (:,:), ALLOCATABLE :: ABTasks INTEGER :: ABTasks_completed IF ( matA % is_complex ) THEN #define AdjacentABlocks AdjacentABlocks_c #define LocalRowContribution LocalRowContribution_c #define GatheredRowContribution GatheredRowContribution_c #define GatheredRowContributionT GatheredRowContributionT_c #define TransposedBBlocks TransposedBBlocks_c #define LocalColumnContribution LocalColumnContribution_c #define GatheredColumnContribution GatheredColumnContribution_c #define SliceContribution SliceContribution_c #define LMAT local_data_c #define MPGRID memory_pool%grid_c #include \"distributed_algebra_includes/MatrixMultiply.f90\" #undef AdjacentABlocks #undef LocalRowContribution #undef GatheredRowContribution #undef GatheredRowContributionT #undef TransposedBBlocks #undef LocalColumnContribution #undef GatheredColumnContribution #undef SliceContribution #undef LMAT #undef MPGRID ELSE #define AdjacentABlocks AdjacentABlocks_r #define LocalRowContribution LocalRowContribution_r #define GatheredRowContribution GatheredRowContribution_r #define GatheredRowContributionT GatheredRowContributionT_r #define TransposedBBlocks TransposedBBlocks_r #define LocalColumnContribution LocalColumnContribution_r #define GatheredColumnContribution GatheredColumnContribution_r #define SliceContribution SliceContribution_r #define LMAT local_data_r #define MPGRID memory_pool%grid_r #include \"distributed_algebra_includes/MatrixMultiply.f90\" #undef AdjacentABlocks #undef LocalRowContribution #undef GatheredRowContribution #undef GatheredRowContributionT #undef TransposedBBlocks #undef LocalColumnContribution #undef GatheredColumnContribution #undef SliceContribution #undef LMAT #undef MPGRID END IF END SUBROUTINE MatrixMultiply_ps_imp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum up the elements in a matrix into a single value. SUBROUTINE MatrixGrandSum_psr ( this , sum ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The sum of all elements. REAL ( NTREAL ), INTENT ( OUT ) :: sum !! Local Data INTEGER :: II , JJ REAL ( NTREAL ) :: temp_r COMPLEX ( NTCOMPLEX ) :: temp_c INTEGER :: ierr #define MPIDATATYPE MPINTREAL IF ( this % is_complex ) THEN #define TEMP temp_c #define LMAT local_data_c #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP ELSE #define TEMP temp_r #define LMAT local_data_r #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP END IF #undef MPIDATATYPE END SUBROUTINE MatrixGrandSum_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum up the elements in a matrix into a single value. SUBROUTINE MatrixGrandSum_psc ( this , sum ) !! Parameters !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The sum of all elements. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: sum !! Local Data INTEGER :: II , JJ REAL ( NTREAL ) :: temp_r COMPLEX ( NTCOMPLEX ) :: temp_c INTEGER :: ierr #define MPIDATATYPE MPINTCOMPLEX IF ( this % is_complex ) THEN #define TEMP temp_c #define LMAT local_data_c #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP ELSE #define TEMP temp_r #define LMAT local_data_r #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP END IF #undef MPIDATATYPE END SUBROUTINE MatrixGrandSum_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Elementwise multiplication. C_ij = A_ij * B_ij. !> Also known as a Hadamard product. RECURSIVE SUBROUTINE PairwiseMultiplyMatrix_ps ( matA , matB , matC ) !! Parameters !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC !! Local Data TYPE ( Matrix_ps ) :: converted_matrix INTEGER :: II , JJ IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , converted_matrix ) CALL PairwiseMultiplyMatrix ( matA , converted_matrix , matC ) CALL DestructMatrix ( converted_matrix ) ELSE IF (. NOT . matA % is_complex . AND . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , converted_matrix ) CALL PairwiseMultiplyMatrix ( converted_matrix , matB , matC ) CALL DestructMatrix ( converted_matrix ) ELSE IF ( matA % is_complex . AND . matB % is_complex ) THEN #define LMAT local_data_c #include \"distributed_algebra_includes/PairwiseMultiply.f90\" #undef LMAT ELSE #define LMAT local_data_r #include \"distributed_algebra_includes/PairwiseMultiply.f90\" #undef LMAT END IF END SUBROUTINE PairwiseMultiplyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a distributed sparse matrix along the rows. FUNCTION MatrixNorm_ps ( this ) RESULT ( norm_value ) !! Parameters !> The matrix to compute the norm of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The norm value of the full distributed sparse matrix. REAL ( NTREAL ) :: norm_value !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: local_norm TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define LMAT merged_local_data_c #include \"distributed_algebra_includes/MatrixNorm.f90\" #undef LMAT ELSE #define LMAT merged_local_data_r #include \"distributed_algebra_includes/MatrixNorm.f90\" #undef LMAT END IF END FUNCTION MatrixNorm_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(Matrix A,Matrix B) !> Note that a dot product is the sum of elementwise multiplication, not !> traditional matrix multiplication. SUBROUTINE DotMatrix_psr ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> The dot product. REAL ( NTREAL ), INTENT ( OUT ) :: product INCLUDE \"distributed_algebra_includes/DotMatrix.f90\" END SUBROUTINE DotMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(Matrix A,Matrix B) !> Note that a dot product is the sum of elementwise multiplication, not !> traditional matrix multiplication. SUBROUTINE DotMatrix_psc ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> The dot product. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: product INCLUDE \"distributed_algebra_includes/DotMatrix.f90\" END SUBROUTINE DotMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY) !> This will utilize the sparse vector increment routine. RECURSIVE SUBROUTINE IncrementMatrix_ps ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matB !> Multiplier (default= 1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default=0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Data TYPE ( Matrix_ps ) :: converted_matrix REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: threshold INTEGER :: II , JJ !! Optional Parameters IF (. NOT . PRESENT ( alpha_in )) THEN alpha = 1.0d+0 ELSE alpha = alpha_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN threshold = 0 ELSE threshold = threshold_in END IF IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , converted_matrix ) CALL IncrementMatrix ( matA , converted_matrix , alpha , threshold ) CALL CopyMatrix ( converted_matrix , matB ) ELSE IF (. NOT . matA % is_complex . AND . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , converted_matrix ) CALL IncrementMatrix ( converted_matrix , matB , alpha , threshold ) ELSE IF ( matA % is_complex . AND . matB % is_complex ) THEN #define LMAT local_data_c #include \"distributed_algebra_includes/IncrementMatrix.f90\" #undef LMAT ELSE #define LMAT local_data_r #include \"distributed_algebra_includes/IncrementMatrix.f90\" #undef LMAT END IF CALL DestructMatrix ( converted_matrix ) END SUBROUTINE IncrementMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a distributed sparse matrix by a constant. SUBROUTINE ScaleMatrix_psr ( this , constant ) !> Matrix to scale. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant !! Local Data INTEGER :: II , JJ IF ( this % is_complex ) THEN #define LOCALDATA local_data_c #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA ELSE #define LOCALDATA local_data_r #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA END IF END SUBROUTINE ScaleMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a distributed sparse matrix by a constant. RECURSIVE SUBROUTINE ScaleMatrix_psc ( this , constant ) !> Matrix to scale. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A constant scale factor. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: constant !! Local Data TYPE ( Matrix_ps ) :: this_c INTEGER :: II , JJ IF ( this % is_complex ) THEN #define LOCALDATA local_data_c #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA ELSE CALL ConvertMatrixToComplex ( this , this_c ) CALL ScaleMatrix_psc ( this_c , constant ) CALL CopyMatrix ( this_c , this ) CALL DestructMatrix ( this_c ) END IF END SUBROUTINE ScaleMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the trace of the matrix. SUBROUTINE MatrixTrace_psr ( this , trace_value ) !! Parameters !> The matrix to compute the trace of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The trace value of the full distributed sparse matrix. REAL ( NTREAL ), INTENT ( OUT ) :: trace_value !! Local data TYPE ( TripletList_r ) :: triplet_list_r TYPE ( TripletList_c ) :: triplet_list_c !! Counters/Temporary INTEGER :: counter TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define TLIST triplet_list_c #define LMAT merged_local_data_c #define MPIDATATYPE MPINTCOMPLEX #include \"distributed_algebra_includes/MatrixTrace.f90\" #undef MPIDATATYPE #undef LMAT #undef TLIST ELSE #define TLIST triplet_list_r #define LMAT merged_local_data_r #define MPIDATATYPE MPINTREAL #include \"distributed_algebra_includes/MatrixTrace.f90\" #undef MPIDATATYPE #undef LMAT #undef TLIST END IF END SUBROUTINE MatrixTrace_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PSMatrixAlgebraModule","tags":"","loc":"sourcefile/psmatrixalgebramodule.f90.html"},{"title":"ErrorModule.F90 – NTPoly","text":"Contents Modules ErrorModule Source Code ErrorModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A (under development) module to do handle error passing. MODULE ErrorModule USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructError PUBLIC :: SetGenericError PUBLIC :: CheckMPIError PUBLIC :: CheckAllocError PUBLIC :: ErrorOccurred PUBLIC :: PrintError PUBLIC :: Cleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A type that can be passed around to accumulate errors. TYPE , PUBLIC :: Error_t PRIVATE !> Flag for whether or not an error has occurred. LOGICAL :: error_set !> Detailed description of the error. CHARACTER ( len = 1000 ) :: error_description !> Store an error caused by a failed MPI call. INTEGER :: mpi_error LOGICAL :: mpi_error_set !< flag for whether mpi error occurred. !> Store an error caused by a bad allocation call. INTEGER :: alloc_error LOGICAL :: alloc_error_set !< flag for whether alloc error occurred. END TYPE Error_t CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Default constructor for an error type. SUBROUTINE ConstructError ( this ) !> The newly constructed error type TYPE ( Error_t ), INTENT ( INOUT ) :: this this % error_set = . FALSE . this % mpi_error_set = . FALSE . this % alloc_error_set = . FALSE . END SUBROUTINE ConstructError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call if a generic error has occurred. SUBROUTINE SetGenericError ( this , error_description , immediate_cleanup_in ) !> The error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( len =* ), INTENT ( in ) :: error_description !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments IF (. NOT . PRESENT ( immediate_cleanup_in )) THEN immediate_cleanup = . FALSE . ELSE immediate_cleanup = immediate_cleanup_in END IF !! Set Flags and Variables this % error_description = error_description this % error_set = . TRUE . IF ( immediate_cleanup ) THEN CALL Cleanup ( this ) END IF END SUBROUTINE SetGenericError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call to check if an MPI error has occurred. FUNCTION CheckMPIError ( this , error_description , mpi_error , & & immediate_cleanup_in ) RESULT ( error_occurred ) !! Parameters !> The error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( len =* ), INTENT ( in ) :: error_description !> The error variable produced by mpi. INTEGER , INTENT ( in ) :: mpi_error !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !> True if an error has occurred, false otherwise. LOGICAL :: error_occurred !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments IF (. NOT . PRESENT ( immediate_cleanup_in )) THEN immediate_cleanup = . FALSE . ELSE immediate_cleanup = immediate_cleanup_in END IF !! Check Error IF (. NOT . mpi_error . EQ . MPI_SUCCESS ) THEN this % mpi_error_set = . TRUE . this % mpi_error = mpi_error CALL SetGenericError ( this , error_description ) END IF error_occurred = ErrorOccurred ( this ) END FUNCTION CheckMPIError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call if an alloc error has occurred. FUNCTION CheckAllocError ( this , error_description , alloc_error , & & immediate_cleanup_in ) RESULT ( error_occurred ) !> This the error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( len =* ), INTENT ( in ) :: error_description !> The error variable produced by alloc. INTEGER , INTENT ( in ) :: alloc_error !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !> True if an error has occurred, false otherwise. LOGICAL :: error_occurred !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments IF (. NOT . PRESENT ( immediate_cleanup_in )) THEN immediate_cleanup = . FALSE . ELSE immediate_cleanup = immediate_cleanup_in END IF !! Check Error IF (. NOT . alloc_error . EQ . 0 ) THEN this % alloc_error_set = . TRUE . this % alloc_error = alloc_error CALL SetGenericError ( this , error_description ) END IF error_occurred = ErrorOccurred ( this ) END FUNCTION CheckAllocError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Check if an error has occurred or not. FUNCTION ErrorOccurred ( this ) RESULT ( occurred ) !> The error variable to check. TYPE ( Error_t ), INTENT ( in ) :: this !> True if an error has occurred, false otherwise. LOGICAL :: occurred occurred = this % error_set END FUNCTION ErrorOccurred !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out that an error has occurred. RECURSIVE SUBROUTINE PrintError ( this ) !> The error to print out. TYPE ( Error_t ), INTENT ( in ) :: this !! Local Data CHARACTER ( len = 80 ) :: error_string INTEGER :: error_string_len INTEGER :: error_string_error TYPE ( Error_t ) :: temp_error !! Print Out Information About The Error IF ( ErrorOccurred ( this )) THEN WRITE ( * , '(A)' ) \"#An error has occurred.\" IF ( this % alloc_error_set ) THEN WRITE ( * , '(A)' ) \"#Of type: alloc error.\" WRITE ( * , '(I3)' ) this % alloc_error ELSE IF ( this % mpi_error_set ) THEN WRITE ( * , '(A)' ) \"#Of type: mpi error.\" CALL MPI_Error_String ( this % mpi_error , error_string , error_string_len , & & error_string_error ) WRITE ( * , '(A)' ) TRIM ( error_string ) ELSE WRITE ( * , '(A)' ) \"#Of type: generic error.\" END IF WRITE ( * , '(A)' ) \"#Details:\" WRITE ( * , '(A)' , ADVANCE = 'no' ) \"#\" WRITE ( * , '(A)' ) TRIM ( this % error_description ) ELSE CALL SetGenericError ( temp_error , & & \"No Error Occurred, but PrintError Called\" ) CALL PrintError ( temp_error ) END IF END SUBROUTINE PrintError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> As a last case resort, this will print an error message and quit. SUBROUTINE Cleanup ( this ) !> The error which has caused the need to cleanup the program. TYPE ( Error_t ), INTENT ( in ) :: this !! Local Data INTEGER :: abort_error CALL PrintError ( this ) IF ( this % mpi_error_set ) THEN CALL MPI_Abort ( MPI_COMM_WORLD , this % mpi_error , abort_error ) ELSE CALL MPI_Abort ( MPI_COMM_WORLD , MPI_ERR_UNKNOWN , abort_error ) END IF END SUBROUTINE Cleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ErrorModule","tags":"","loc":"sourcefile/errormodule.f90.html"},{"title":"SquareRootSolversModule.F90 – NTPoly","text":"Contents Modules SquareRootSolversModule Source Code SquareRootSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Square Root of a Matrix. MODULE SquareRootSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteListElement , & & WriteHeader , WriteElement , WriteCitation USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: SquareRoot PUBLIC :: InverseSquareRoot CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root of a matrix. SUBROUTINE SquareRoot ( InputMat , OutputMat , solver_parameters_in , order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !> Order of polynomial for calculation (default 5). INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables TYPE ( SolverParameters_t ) :: solver_parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( PRESENT ( order_in )) THEN CALL SquareRootSelector ( InputMat , OutputMat , solver_parameters , . FALSE .,& & order_in ) ELSE CALL SquareRootSelector ( InputMat , OutputMat , solver_parameters , . FALSE .) END IF !! Cleanup CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE SquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the inverse square root of a matrix. SUBROUTINE InverseSquareRoot ( InputMat , OutputMat , solver_parameters_in , & & order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !> Order of polynomial for calculation (default 5). INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables TYPE ( SolverParameters_t ) :: solver_parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( PRESENT ( order_in )) THEN CALL SquareRootSelector ( InputMat , OutputMat , solver_parameters , . TRUE ., & & order_in ) ELSE CALL SquareRootSelector ( InputMat , OutputMat , solver_parameters , . TRUE .) END IF !! Cleanup CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE InverseSquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine picks the appropriate solver method SUBROUTINE SquareRootSelector ( InputMat , OutputMat , solver_parameters , & & compute_inverse , order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The Matrix computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters about how to solve. TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !> True if we are computing the inverse square root. LOGICAL , INTENT ( IN ) :: compute_inverse !> The polynomial degree to use (optional, default=5) INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables INTEGER :: order IF ( PRESENT ( order_in )) THEN order = order_in ELSE order = 5 END IF SELECT CASE ( order ) CASE ( 2 ) CALL NewtonSchultzISROrder2 ( InputMat , OutputMat , solver_parameters , & & compute_inverse ) CASE DEFAULT CALL NewtonSchultzISRTaylor ( InputMat , OutputMat , solver_parameters , & & order , compute_inverse ) END SELECT END SUBROUTINE SquareRootSelector !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root or inverse square root of a matrix. !! Based on the Newton-Schultz algorithm presented in: \\cite jansik2007linear SUBROUTINE NewtonSchultzISROrder2 ( Mat , OutMat , solver_parameters , & & compute_inverse ) !> The matrix to compute TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> Mat&#94;-1/2 or Mat&#94;1/2. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !> Whether to compute the inverse square root. LOGICAL , INTENT ( IN ) :: compute_inverse !! Local Variables REAL ( NTREAL ) :: lambda TYPE ( Matrix_ps ) :: X_k , T_k , Temp , Identity TYPE ( Matrix_ps ) :: SquareRootMat TYPE ( Matrix_ps ) :: InverseSquareRootMat !! Temporary Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: max_between INTEGER :: outer_counter REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: mpool IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Newton Schultz Inverse Square Root\" ) CALL EnterSubLog CALL WriteCitation ( \"jansik2007linear\" ) CALL PrintParameters ( solver_parameters ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( X_k , Mat ) CALL ConstructEmptyMatrix ( SquareRootMat , Mat ) CALL ConstructEmptyMatrix ( InverseSquareRootMat , Mat ) CALL ConstructEmptyMatrix ( T_k , Mat ) CALL ConstructEmptyMatrix ( Temp , Mat ) CALL ConstructEmptyMatrix ( Identity , Mat ) CALL FillMatrixIdentity ( Identity ) !! Compute the lambda scaling value. CALL GershgorinBounds ( Mat , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0 / max_between !! Initialize CALL FillMatrixIdentity ( InverseSquareRootMat ) CALL CopyMatrix ( Mat , SquareRootMat ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( SquareRootMat , SquareRootMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( InverseSquareRootMat , InverseSquareRootMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) END IF !! Iterate. IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0d+0 DO outer_counter = 1 , solver_parameters % max_iterations !! Compute X_k CALL MatrixMultiply ( SquareRootMat , InverseSquareRootMat , X_k , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL GershgorinBounds ( X_k , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0 / max_between CALL ScaleMatrix ( X_k , lambda ) !! Check if Converged CALL CopyMatrix ( Identity , Temp ) CALL IncrementMatrix ( X_k , Temp , REAL ( - 1.0 , NTREAL )) norm_value = MatrixNorm ( Temp ) !! Compute T_k CALL CopyMatrix ( Identity , T_k ) CALL ScaleMatrix ( T_k , REAL ( 3.0 , NTREAL )) CALL IncrementMatrix ( X_k , T_k , REAL ( - 1.0 , NTREAL )) CALL ScaleMatrix ( T_k , REAL ( 0.5 , NTREAL )) !! Compute Z_k+1 CALL CopyMatrix ( InverseSquareRootMat , Temp ) CALL MatrixMultiply ( Temp , T_k , InverseSquareRootMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL ScaleMatrix ( InverseSquareRootMat , SQRT ( lambda )) !! Compute Y_k+1 CALL CopyMatrix ( SquareRootMat , Temp ) CALL MatrixMultiply ( T_k , Temp , SquareRootMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL ScaleMatrix ( SquareRootMat , SQRT ( lambda )) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( InverseSquareRootMat ) END IF IF ( compute_inverse ) THEN CALL CopyMatrix ( InverseSquareRootMat , OutMat ) ELSE CALL CopyMatrix ( SquareRootMat , OutMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Temp ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( SquareRootMat ) CALL DestructMatrix ( InverseSquareRootMat ) CALL DestructMatrix ( T_k ) CALL DestructMatrixMemoryPool ( mpool ) END SUBROUTINE NewtonSchultzISROrder2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root or inverse square root of a matrix. !! Based on the Newton-Schultz algorithm with higher order polynomials. SUBROUTINE NewtonSchultzISRTaylor ( Mat , OutMat , solver_parameters , & & taylor_order , compute_inverse ) !> Matrix to Compute TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> Mat&#94;-1/2 or Mat&#94;1/2. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_parameters !> Order of polynomial to use. INTEGER , INTENT ( IN ) :: taylor_order !> Whether to compute the inverse square root or not. LOGICAL , INTENT ( IN ) :: compute_inverse !! Local Variables REAL ( NTREAL ) :: lambda REAL ( NTREAL ) :: aa , bb , cc , dd REAL ( NTREAL ) :: a , b , c , d TYPE ( Matrix_ps ) :: X_k , Temp , Temp2 , Identity TYPE ( Matrix_ps ) :: SquareRootMat TYPE ( Matrix_ps ) :: InverseSquareRootMat !! Temporary Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: max_between INTEGER :: outer_counter REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: mpool IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Newton Schultz Inverse Square Root\" ) CALL EnterSubLog CALL WriteCitation ( \"jansik2007linear\" ) CALL PrintParameters ( solver_parameters ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( X_k , Mat ) CALL ConstructEmptyMatrix ( SquareRootMat , Mat ) CALL ConstructEmptyMatrix ( InverseSquareRootMat , Mat ) CALL ConstructEmptyMatrix ( Temp , Mat ) IF ( taylor_order == 5 ) THEN CALL ConstructEmptyMatrix ( Temp2 , Mat ) END IF CALL ConstructEmptyMatrix ( Identity , Mat ) CALL FillMatrixIdentity ( Identity ) !! Compute the lambda scaling value. CALL GershgorinBounds ( Mat , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0_NTREAL / max_between !! Initialize CALL FillMatrixIdentity ( InverseSquareRootMat ) CALL CopyMatrix ( Mat , SquareRootMat ) CALL ScaleMatrix ( SquareRootMat , lambda ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( SquareRootMat , SquareRootMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( InverseSquareRootMat , InverseSquareRootMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) END IF !! Iterate. IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations !! Compute X_k = Z_k * Y_k - I CALL MatrixMultiply ( InverseSquareRootMat , SquareRootMat , X_k , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( Identity , X_k , - 1.0_NTREAL ) norm_value = MatrixNorm ( X_k ) SELECT CASE ( taylor_order ) CASE ( 3 ) !! Compute X_k&#94;2 CALL MatrixMultiply ( X_k , X_k , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) !! X_k = I - 1/2 X_k + 3/8 X_k&#94;2 + ... CALL ScaleMatrix ( X_k , - 0.5_NTREAL ) CALL IncrementMatrix ( Identity , X_k ) CALL IncrementMatrix ( Temp , X_k , 0.375_NTREAL ) CASE ( 5 ) !! Compute p(x) = x&#94;4 + A*x&#94;3 + B*x&#94;2 + C*x + D !! Scale to make coefficient of x&#94;4 equal to 1 aa = - 4 0.0_NTREAL / 3 5.0_NTREAL bb = 4 8.0_NTREAL / 3 5.0_NTREAL cc = - 6 4.0_NTREAL / 3 5.0_NTREAL dd = 12 8.0_NTREAL / 3 5.0_NTREAL !! Knuth's method !! p = (z+x+b) * (z+c) + d !! z = x * (x+a) !! a = (A-1)/2 !! b = B*(a+1) - C - a*(a+1)*(a+1) !! c = B - b - a*(a+1) !! d = D - b*c a = ( aa - 1.0_NTREAL ) / 2.0_NTREAL b = bb * ( a + 1.0_NTREAL ) - cc - a * ( a + 1.0_NTREAL ) ** 2 c = bb - b - a * ( a + 1.0_NTREAL ) d = dd - b * c !! Compute Temp = z = x * (x+a) CALL MatrixMultiply ( X_k , X_k , Temp , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( X_k , Temp , a ) !! Compute Temp2 = z + x + b CALL CopyMatrix ( Identity , Temp2 ) CALL ScaleMatrix ( Temp2 , b ) CALL IncrementMatrix ( X_k , Temp2 ) CALL IncrementMatrix ( Temp , Temp2 ) !! Compute Temp = z + c CALL IncrementMatrix ( Identity , Temp , c ) !! Compute X_k = (z+x+b) * (z+c) + d = Temp2 * Temp + d CALL MatrixMultiply ( Temp2 , Temp , X_k , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( Identity , X_k , d ) !! Scale back to the target coefficients CALL ScaleMatrix ( X_k , 3 5.0_NTREAL / 12 8.0_NTREAL ) END SELECT !! Compute Z_k+1 = Z_k * X_k CALL CopyMatrix ( InverseSquareRootMat , Temp ) CALL MatrixMultiply ( X_k , Temp , InverseSquareRootMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) !! Compute Y_k+1 = X_k * Y_k CALL CopyMatrix ( SquareRootMat , Temp ) CALL MatrixMultiply ( Temp , X_k , SquareRootMat , & & threshold_in = solver_parameters % threshold , memory_pool_in = mpool ) IF ( solver_parameters % be_verbose ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter ) CALL EnterSubLog CALL WriteElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter ) CALL PrintMatrixInformation ( InverseSquareRootMat ) END IF IF ( compute_inverse ) THEN CALL ScaleMatrix ( InverseSquareRootMat , SQRT ( lambda )) CALL CopyMatrix ( InverseSquareRootMat , OutMat ) ELSE CALL ScaleMatrix ( SquareRootMat , 1.0_NTREAL / SQRT ( lambda )) CALL CopyMatrix ( SquareRootMat , OutMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & solver_parameters % BalancePermutation , memorypool_in = mpool ) END IF !! Cleanup IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( X_k ) CALL DestructMatrix ( SquareRootMat ) CALL DestructMatrix ( InverseSquareRootMat ) CALL DestructMatrix ( Temp ) IF ( taylor_order == 5 ) THEN CALL DestructMatrix ( Temp2 ) END IF CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( mpool ) END SUBROUTINE NewtonSchultzISRTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SquareRootSolversModule","tags":"","loc":"sourcefile/squarerootsolversmodule.f90.html"},{"title":"SVectorModule.F90 – NTPoly","text":"Contents Modules SVectorModule Source Code SVectorModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling compressed vectors. !! Compressed vectors are stored in two lists. The first is a list of indices, !! the second a list of values. MODULE SVectorModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: AddSparseVectors PUBLIC :: DotSparseVectors PUBLIC :: PairwiseMultiplyVectors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE AddSparseVectors MODULE PROCEDURE AddSparseVectors_r MODULE PROCEDURE AddSparseVectors_c END INTERFACE INTERFACE DotSparseVectors MODULE PROCEDURE DotSparseVectors_r MODULE PROCEDURE DotSparseVectors_c END INTERFACE INTERFACE PairwiseMultiplyVectors MODULE PROCEDURE PairwiseMultiplyVectors_r MODULE PROCEDURE PairwiseMultiplyVectors_c END INTERFACE CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add together two sparse vectors. C = A + alpha*B !> The values that are returned for C are only valid in the range !> (1:total_values_c). We do not do an automatic shrinking of the array !> to keep this routine low in overhead. PURE SUBROUTINE AddSparseVectors_r ( inner_index_a , values_a , inner_index_b , & & values_b , inner_index_c , values_c , total_values_c , alpha_in , threshold_in ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: values_c !> Value to scale VecB by. Optional, default is 1.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> for flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> The total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Local Variables REAL ( NTREAL ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/AddSparseVectors.f90\" END SUBROUTINE AddSparseVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add together two sparse vectors. C = A + alpha*B !> The values that are returned for C are only valid in the range !> (1:total_values_c). We do not do an automatic shrinking of the array !> to keep this routine low in overhead. PURE SUBROUTINE AddSparseVectors_c ( inner_index_a , values_a , inner_index_b , & & values_b , inner_index_c , values_c , total_values_c , alpha_in , threshold_in ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( OUT ) :: values_c !> Value to scale VecB by. Optional, default is 1.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> for flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> The total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Local Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/AddSparseVectors.f90\" END SUBROUTINE AddSparseVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(A,B) PURE FUNCTION DotSparseVectors_r ( inner_index_a , values_a , inner_index_b , & & values_b ) RESULT ( product ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> Dot product. REAL ( NTREAL ) :: product !! Temporary Variables REAL ( NTREAL ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/DotSparseVectors.f90\" END FUNCTION DotSparseVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(A,B) PURE FUNCTION DotSparseVectors_c ( inner_index_a , values_a , inner_index_b , & & values_b ) RESULT ( product ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> Dot product. COMPLEX ( NTCOMPLEX ) :: product !! Temporary Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/DotSparseVectors.f90\" END FUNCTION DotSparseVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply Vectors C = A Mult B PURE SUBROUTINE PairwiseMultiplyVectors_r ( inner_index_a , values_a , & & inner_index_b , values_b , inner_index_c , values_c , total_values_c ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices computed for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: values_c !> This is the total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Temporary Variables REAL ( NTREAL ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/PairwiseMultiplyVectors.f90\" END SUBROUTINE PairwiseMultiplyVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply Vectors C = A Mult B PURE SUBROUTINE PairwiseMultiplyVectors_c ( inner_index_a , values_a , & & inner_index_b , values_b , inner_index_c , values_c , total_values_c ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices computed for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> This is the total number of values in C. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( OUT ) :: values_c !> This is the total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Temporary Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b INCLUDE \"sparse_includes/PairwiseMultiplyVectors.f90\" END SUBROUTINE PairwiseMultiplyVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SVectorModule","tags":"","loc":"sourcefile/svectormodule.f90.html"},{"title":"InverseSolversModule.F90 – NTPoly","text":"Contents Modules InverseSolversModule Source Code InverseSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Inverse of a Matrix. MODULE InverseSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement , WriteListElement , WriteCitation USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & MatrixNorm , MatrixSigma , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: Invert PUBLIC :: PseudoInverse CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the inverse of a matrix. !> An implementation of Hotelling's method \\cite palser1998canonical. SUBROUTINE Invert ( Mat , InverseMat , solver_parameters_in ) !> The matrix to invert. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The inverse of that matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: InverseMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables REAL ( NTREAL ) :: sigma TYPE ( Matrix_ps ) :: Temp1 , Temp2 , Identity TYPE ( Matrix_ps ) :: BalancedMat !! Temporary Variables INTEGER :: outer_counter REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Inverse Solver\" ) CALL EnterSubLog CALL WriteCitation ( \"palser1998canonical\" ) CALL PrintParameters ( solver_parameters ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( InverseMat , Mat ) CALL ConstructEmptyMatrix ( Temp1 , Mat ) CALL ConstructEmptyMatrix ( Temp2 , Mat ) CALL ConstructEmptyMatrix ( Identity , Mat ) CALL ConstructEmptyMatrix ( BalancedMat , Mat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Mat , BalancedMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( Mat , BalancedMat ) END IF !! Compute Sigma CALL MatrixSigma ( BalancedMat , sigma ) !! Create Inverse Guess CALL CopyMatrix ( BalancedMat , InverseMat ) CALL ScaleMatrix ( InverseMat , sigma ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteListElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF CALL MatrixMultiply ( InverseMat , BalancedMat , Temp1 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Check if Converged CALL CopyMatrix ( Identity , Temp2 ) CALL IncrementMatrix ( Temp1 , Temp2 , - 1.0_NTREAL ) norm_value = MatrixNorm ( Temp2 ) CALL DestructMatrix ( Temp2 ) CALL MatrixMultiply ( Temp1 , InverseMat , Temp2 , alpha_in =- 1.0_NTREAL , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Save a copy of the last inverse matrix CALL CopyMatrix ( InverseMat , Temp1 ) CALL ScaleMatrix ( InverseMat , 2.0_NTREAL ) CALL IncrementMatrix ( Temp2 , InverseMat , & & threshold_in = solver_parameters % threshold ) IF ( norm_value . LE . solver_parameters % converge_diff ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) CALL PrintMatrixInformation ( InverseMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( InverseMat , InverseMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( BalancedMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE Invert !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the pseudoinverse of a matrix. !> An implementation of Hotelling's method \\cite palser1998canonical. SUBROUTINE PseudoInverse ( Mat , InverseMat , solver_parameters_in ) !> The matrix to compute the pseudo inverse of. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The pseudoinverse of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: InverseMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: solver_parameters !! Local Variables REAL ( NTREAL ) :: sigma TYPE ( Matrix_ps ) :: Temp1 , Temp2 , Identity TYPE ( Matrix_ps ) :: BalancedMat !! Temporary Variables INTEGER :: outer_counter REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN solver_parameters = solver_parameters_in ELSE solver_parameters = SolverParameters_t () END IF IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Inverse Solver\" ) CALL EnterSubLog CALL WriteCitation ( \"palser1998canonical\" ) CALL PrintParameters ( solver_parameters ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( InverseMat , Mat ) CALL ConstructEmptyMatrix ( Temp1 , Mat ) CALL ConstructEmptyMatrix ( Temp2 , Mat ) CALL ConstructEmptyMatrix ( Identity , Mat ) CALL ConstructEmptyMatrix ( BalancedMat , Mat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & solver_parameters % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Mat , BalancedMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( Mat , BalancedMat ) END IF !! Compute Sigma CALL MatrixSigma ( BalancedMat , sigma ) !! Create Inverse Guess CALL CopyMatrix ( BalancedMat , InverseMat ) CALL ScaleMatrix ( InverseMat , sigma ) !! Iterate IF ( solver_parameters % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF outer_counter = 1 norm_value = solver_parameters % converge_diff + 1.0_NTREAL DO outer_counter = 1 , solver_parameters % max_iterations IF ( solver_parameters % be_verbose . AND . outer_counter . GT . 1 ) THEN CALL WriteListElement ( key = \"Round\" , value = outer_counter - 1 ) CALL EnterSubLog CALL WriteListElement ( key = \"Convergence\" , value = norm_value ) CALL ExitSubLog END IF CALL MatrixMultiply ( InverseMat , BalancedMat , Temp1 , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp1 , InverseMat , Temp2 , alpha_in =- 1.0_NTREAL , & & threshold_in = solver_parameters % threshold , memory_pool_in = pool ) !! Save a copy of the last inverse matrix CALL CopyMatrix ( InverseMat , Temp1 ) CALL ScaleMatrix ( InverseMat , 2.0_NTREAL ) CALL IncrementMatrix ( Temp2 , InverseMat , & & threshold_in = solver_parameters % threshold ) !! Check if Converged CALL IncrementMatrix ( InverseMat , Temp1 , - 1.0_NTREAL ) norm_value = MatrixNorm ( Temp1 ) !! Sometimes the first few values don't change so much, so that's why !! I added the outer counter check IF ( norm_value . LE . solver_parameters % converge_diff . AND . & & outer_counter . GT . 3 ) THEN EXIT END IF END DO IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , value = outer_counter - 1 ) CALL PrintMatrixInformation ( InverseMat ) END IF !! Undo Load Balancing Step IF ( solver_parameters % do_load_balancing ) THEN CALL UndoPermuteMatrix ( InverseMat , InverseMat , & & solver_parameters % BalancePermutation , memorypool_in = pool ) END IF IF ( solver_parameters % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( BalancedMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( solver_parameters ) END SUBROUTINE PseudoInverse !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE InverseSolversModule","tags":"","loc":"sourcefile/inversesolversmodule.f90.html"},{"title":"ChebyshevPolynomial_t – NTPoly ","text":"type, public :: ChebyshevPolynomial_t A datatype that represents a Chebyshev polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/chebyshevpolynomial_t.html"},{"title":"MatrixMemoryPool_p – NTPoly ","text":"type, public :: MatrixMemoryPool_p A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Contents Variables grid_r grid_c Constructor MatrixMemoryPool_p Components Type Visibility Attributes Name Initial type( MatrixMemoryPool_lr ), public, DIMENSION(:,:), ALLOCATABLE :: grid_r Grid of local pools. type( MatrixMemoryPool_lc ), public, DIMENSION(:,:), ALLOCATABLE :: grid_c Grid of local pools (complex). Constructor public interface MatrixMemoryPool_p private pure function ConstructMatrixMemoryPool_p(matrix) result(this) Construct Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matrix The associated distributed sparse matrix. Return Value type( MatrixMemoryPool_p ) A constructed Matrix Memory Pool object.","tags":"","loc":"type/matrixmemorypool_p.html"},{"title":"TripletList_r – NTPoly ","text":"type, public :: TripletList_r A data type for a list of triplets. Contents Variables DATA CurrentSize Constructor TripletList_r Components Type Visibility Attributes Name Initial type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list Constructor public interface TripletList_r public pure function ConstructTripletList_r (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_r ) The triplet list to construct.","tags":"","loc":"type/tripletlist_r.html"},{"title":"TripletList_c – NTPoly ","text":"type, public :: TripletList_c A data type for a list of triplets. Contents Variables DATA CurrentSize Constructor TripletList_c Components Type Visibility Attributes Name Initial type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list Constructor public interface TripletList_c public pure function ConstructTripletList_c (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_c ) The triplet list to construct.","tags":"","loc":"type/tripletlist_c.html"},{"title":"SolverParameters_t – NTPoly ","text":"type, public :: SolverParameters_t A class for passing parameters to an iterative solver. Contents Variables converge_diff max_iterations threshold be_verbose do_load_balancing BalancePermutation Constructor SolverParameters_t Components Type Visibility Attributes Name Initial real(kind=NTREAL), public :: converge_diff When do we consider a calculation converged. integer, public :: max_iterations Maximum number of iterations of a solver before termination. real(kind=NTREAL), public :: threshold Threshold for sparse multiplication and addition. logical, public :: be_verbose If true, the sparse solver prints out information each loop iteration. logical, public :: do_load_balancing If true, the sparse solver will try and load balance before calculation. type( Permutation_t ), public :: BalancePermutation The permutation used for load balancing. Constructor public interface SolverParameters_t private pure function SolverParameters_init(converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in) result(this) Construct a data type which stores iterative solver parameters. Arguments Type Intent Optional Attributes Name real(kind=NTREAL), intent(in), optional :: converge_diff_in Converge_diff_in the difference between iterations to consider\n a calculation converged. real(kind=NTREAL), intent(in), optional :: threshold_in The zero threshold integer, intent(in), optional :: max_iterations_in The maximum number of iterations to perform logical, intent(in), optional :: be_verbose_in Whether to print during the calculation (default = False) type( Permutation_t ), intent(in), optional :: BalancePermutation_in For load balancing Return Value type( SolverParameters_t )","tags":"","loc":"type/solverparameters_t.html"},{"title":"MatrixMemoryPool_lr – NTPoly ","text":"type, public :: MatrixMemoryPool_lr A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Contents Variables columns rows pruned_list value_array dirty_array hash_index inserted_per_bucket hash_size Constructor MatrixMemoryPool_lr Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets. Constructor public interface MatrixMemoryPool_lr private function ConstructMatrixMemoryPool_lr(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lr ),\n  TARGET The matrix to construct.","tags":"","loc":"type/matrixmemorypool_lr.html"},{"title":"MatrixMemoryPool_lc – NTPoly ","text":"type, public :: MatrixMemoryPool_lc A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Contents Variables columns rows pruned_list value_array dirty_array hash_index inserted_per_bucket hash_size Constructor MatrixMemoryPool_lc Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets. Constructor public interface MatrixMemoryPool_lc private function ConstructMatrixMemoryPool_lc(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lc ),\n  TARGET The matrix to construct.","tags":"","loc":"type/matrixmemorypool_lc.html"},{"title":"ReduceHelper_t – NTPoly ","text":"type, public :: ReduceHelper_t A data structure to stores internal information about a reduce call. Contents Variables comm_size outer_request inner_request data_request error_code values_per_process displacement Components Type Visibility Attributes Name Initial integer, public :: comm_size Number of processors involved in this gather. integer, public :: outer_request A request object for gathering outer indices. integer, public :: inner_request A request object for gathering inner indices. integer, public :: data_request A request object for gathering data. integer, public :: error_code The error code after an MPI call. integer, public, DIMENSION(:), ALLOCATABLE :: values_per_process Number of values to gather from each process. integer, public, DIMENSION(:), ALLOCATABLE :: displacement The displacements for where those gathered values should go.","tags":"","loc":"type/reducehelper_t.html"},{"title":"Matrix_lsr – NTPoly ","text":"type, public :: Matrix_lsr A datatype for storing a local, real CSR matrix. Contents Variables outer_index inner_index values rows columns Constructor Matrix_lsr Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns Constructor public interface Matrix_lsr private pure function ConstructEmptyMatrix_lsr(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsr ) The matrix to construct. private function ConstructMatrixFromFile_lsr(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsr ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsr(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsr ) The matrix being constructed","tags":"","loc":"type/matrix_lsr.html"},{"title":"Matrix_lsc – NTPoly ","text":"type, public :: Matrix_lsc A datatype for storing a local, complex CSR matrix. Contents Variables outer_index inner_index values rows columns Constructor Matrix_lsc Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices complex(kind=NTCOMPLEX), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns Constructor public interface Matrix_lsc private pure function ConstructEmptyMatrix_lsc(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsc ) The matrix to construct. private function ConstructMatrixFromFile_lsc(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsc ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsc(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsc ) The matrix being constructed","tags":"","loc":"type/matrix_lsc.html"},{"title":"Permutation_t – NTPoly ","text":"type, public :: Permutation_t A data structure for storing permutations. Contents Variables index_lookup reverse_index_lookup Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: index_lookup For each row/column, what index does it correspond to in the\n unperturbed matrix. integer, public, DIMENSION(:), ALLOCATABLE :: reverse_index_lookup For each row/column in the unperturbed, what index does it correspond to\n in this matrix.","tags":"","loc":"type/permutation_t.html"},{"title":"HermitePolynomial_t – NTPoly ","text":"type, public :: HermitePolynomial_t A datatype that represents a Hermite polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/hermitepolynomial_t.html"},{"title":"Polynomial_t – NTPoly ","text":"type, public :: Polynomial_t A datatype that represents a polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/polynomial_t.html"},{"title":"Matrix_ldr – NTPoly ","text":"type, public :: Matrix_ldr A datatype for storing a dense matrix. Contents Variables DATA rows columns Constructor Matrix_ldr Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns. Constructor public interface Matrix_ldr private pure function ConstructEmptyMatrix_ldr(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldr ) The matrix to construct.","tags":"","loc":"type/matrix_ldr.html"},{"title":"Matrix_ldc – NTPoly ","text":"type, public :: Matrix_ldc A datatype for storing a dense matrix. Contents Variables DATA rows columns Constructor Matrix_ldc Components Type Visibility Attributes Name Initial complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns. Constructor public interface Matrix_ldc private pure function ConstructEmptyMatrix_ldc(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldc ) The matrix to construct.","tags":"","loc":"type/matrix_ldc.html"},{"title":"Matrix_ps – NTPoly ","text":"type, public :: Matrix_ps A datatype for a distributed blocked CSR matrix. Contents Variables logical_matrix_dimension actual_matrix_dimension local_data_r local_data_c start_column end_column start_row end_row local_columns local_rows process_grid is_complex Components Type Visibility Attributes Name Initial integer, public :: logical_matrix_dimension Number of matrix rows/columns for full matrix, scaled for process grid. integer, public :: actual_matrix_dimension Number of matrix rows/columns for the full matrix, unscaled. type( Matrix_lsr ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_r A 2D array of local CSR matrices. type( Matrix_lsc ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_c A 2D array of local CSC matrices. integer, public :: start_column first column stored locally. integer, public :: end_column last column stored locally  is less than this. integer, public :: start_row first row stored locally. integer, public :: end_row last row stored locally is less than this. integer, public :: local_columns number of local columns. integer, public :: local_rows number of local rows. type( ProcessGrid_t ), public, POINTER :: process_grid process grid to operate on logical, public :: is_complex true if the matrix data is true.","tags":"","loc":"type/matrix_ps.html"},{"title":"ProcessGrid_t – NTPoly ","text":"type, public :: ProcessGrid_t A datatype which stores a process grid and all its communicators. Contents Variables total_processors num_process_rows num_process_columns num_process_slices slice_size my_slice my_row my_column global_rank within_slice_rank between_slice_rank column_rank row_rank global_comm row_comm column_comm within_slice_comm between_slice_comm grid_error RootID block_multiplier number_of_blocks_columns number_of_blocks_rows blocked_row_comm blocked_column_comm blocked_within_slice_comm blocked_between_slice_comm Components Type Visibility Attributes Name Initial integer, public :: total_processors total processors in the grid. integer, public :: num_process_rows number of rows in the grid. integer, public :: num_process_columns number of columns in the grid. integer, public :: num_process_slices number of 2D slices in the grid. integer, public :: slice_size the size of a 2D slice. integer, public :: my_slice which slice is the current process in. integer, public :: my_row which row is the current process in. integer, public :: my_column which column is the current process in. integer, public :: global_rank current process's rank amongst processes. integer, public :: within_slice_rank rank for within slice communication. integer, public :: between_slice_rank rank for between slice communication. integer, public :: column_rank rank for within column communication. integer, public :: row_rank rank for within row communication. integer, public :: global_comm communicator with every other process. integer, public :: row_comm communicator within a row. integer, public :: column_comm communicator within a column. integer, public :: within_slice_comm communicator within a slice. integer, public :: between_slice_comm communicator between slices. integer, public :: grid_error stores errors from MPI calls. integer, public :: RootID = 0 Which rank is root? integer, public :: block_multiplier Block scaling factor. integer, public :: number_of_blocks_columns number of column blocks. integer, public :: number_of_blocks_rows number of row blocks. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_row_comm blocked communicator within a row. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_column_comm blocked communicator within a column. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_within_slice_comm blocked communicator within a slice. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_between_slice_comm blocked communicator between slices.","tags":"","loc":"type/processgrid_t.html"},{"title":"Triplet_r – NTPoly ","text":"type, public :: Triplet_r A data type for a triplet of integer, integer, double.\n As this is related to matrix multiplication, the referencing indices are\n rows and columns. Contents Variables index_column index_row point_value Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index_column column value. integer(kind=c_int), public :: index_row row value. real(kind=NTREAL), public :: point_value actual value at those indices.","tags":"","loc":"type/triplet_r.html"},{"title":"Triplet_c – NTPoly ","text":"type, public :: Triplet_c A data type for a triplet of integer, integer, complex.\n As this is related to matrix multiplication, the referencing indices are\n rows and columns. Contents Variables index_column index_row point_value Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index_column column value. integer(kind=c_int), public :: index_row row value. complex(kind=NTCOMPLEX), public :: point_value actual value at those indices.","tags":"","loc":"type/triplet_c.html"},{"title":"Error_t – NTPoly ","text":"type, public :: Error_t A type that can be passed around to accumulate errors. Contents None","tags":"","loc":"type/error_t.html"},{"title":"ComputeRoot – NTPoly","text":"public subroutine ComputeRoot(InputMat, OutputMat, root, solver_parameters_in) Compute a general matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computeroot.html"},{"title":"ComputeInverseRoot – NTPoly","text":"public subroutine ComputeInverseRoot(InputMat, OutputMat, root, solver_parameters_in) Compute a general inverse matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;-1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/computeinverseroot.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_cheby Module Procedures private subroutine ConstructPolynomial_cheby(this, degree) Construct a Chebyshev polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree Degree of the polynomial.","tags":"","loc":"interface/constructpolynomial.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_cheby Module Procedures private subroutine DestructPolynomial_cheby(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_cheby Module Procedures private subroutine SetCoefficient_cheby(this, degree, coefficient) Set a coefficient of a Chebyshev polynomial. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value.","tags":"","loc":"interface/setcoefficient.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_cheby Module Procedures private subroutine Compute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\n This method uses the standard Chebyshev Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/compute.html"},{"title":"FactorizedCompute – NTPoly","text":"public interface FactorizedCompute Contents Module Procedures FactorizedCompute_cheby Module Procedures private subroutine FactorizedCompute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\n This version first factors the Chebyshev Polynomial and computes the\n function using a divide and conquer algorithm. Based on a simplified\n version of the first method in \\cite liang2003improved . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/factorizedcompute.html"},{"title":"Sine – NTPoly","text":"public subroutine Sine(InputMat, OutputMat, solver_parameters_in) Compute the sine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/sine.html"},{"title":"Cosine – NTPoly","text":"public subroutine Cosine(InputMat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/cosine.html"},{"title":"ScaleSquareTrigonometryTaylor – NTPoly","text":"public subroutine ScaleSquareTrigonometryTaylor(InputMat, OutputMat, solver_parameters_in) Compute trigonometric functions of a matrix using a taylor series. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/scalesquaretrigonometrytaylor.html"},{"title":"MatrixMemoryPool_p – NTPoly","text":"public interface MatrixMemoryPool_p Contents Module Procedures ConstructMatrixMemoryPool_p Module Procedures private pure function ConstructMatrixMemoryPool_p(matrix) result(this) Construct Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matrix The associated distributed sparse matrix. Return Value type( MatrixMemoryPool_p ) A constructed Matrix Memory Pool object.","tags":"","loc":"interface/matrixmemorypool_p.html"},{"title":"DestructMatrixMemoryPool – NTPoly","text":"public interface DestructMatrixMemoryPool Contents Module Procedures DestructMatrixMemoryPool_p Module Procedures private subroutine DestructMatrixMemoryPool_p(this) Destruct a Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this Distributed Matrix Memory Pool object to destroy.","tags":"","loc":"interface/destructmatrixmemorypool.html"},{"title":"CheckMemoryPoolValidity – NTPoly","text":"public interface CheckMemoryPoolValidity Contents Module Procedures CheckMemoryPoolValidity_p Module Procedures private pure function CheckMemoryPoolValidity_p(this, matrix) result(isvalid) Checks if a given distributed memory pool has been validly allocated to\n handle the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(in) :: this The memory pool to check. type( Matrix_ps ), intent(in) :: matrix The associated matrix to check against. Return Value logical True if the memory pool is valid.","tags":"","loc":"interface/checkmemorypoolvalidity.html"},{"title":"ConstructTripletList_r – NTPoly","text":"public pure function ConstructTripletList_r(size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_r ) The triplet list to construct. Contents None","tags":"","loc":"proc/constructtripletlist_r.html"},{"title":"ConstructTripletList_c – NTPoly","text":"public pure function ConstructTripletList_c(size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_c ) The triplet list to construct. Contents None","tags":"","loc":"proc/constructtripletlist_c.html"},{"title":"GetTripletListSize_r – NTPoly","text":"public pure function GetTripletListSize_r(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. Contents None","tags":"","loc":"proc/gettripletlistsize_r.html"},{"title":"GetTripletListSize_c – NTPoly","text":"public pure function GetTripletListSize_c(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. Contents None","tags":"","loc":"proc/gettripletlistsize_c.html"},{"title":"ConstructTripletListSup_r – NTPoly","text":"public subroutine ConstructTripletListSup_r(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Contents None","tags":"","loc":"proc/constructtripletlistsup_r.html"},{"title":"ConstructTripletListSup_c – NTPoly","text":"public subroutine ConstructTripletListSup_c(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Contents None","tags":"","loc":"proc/constructtripletlistsup_c.html"},{"title":"DestructTripletList_r – NTPoly","text":"public subroutine DestructTripletList_r(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. Contents None","tags":"","loc":"proc/destructtripletlist_r.html"},{"title":"DestructTripletList_c – NTPoly","text":"public subroutine DestructTripletList_c(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct. Contents None","tags":"","loc":"proc/destructtripletlist_c.html"},{"title":"ResizeTripletList_r – NTPoly","text":"public subroutine ResizeTripletList_r(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. Contents None","tags":"","loc":"proc/resizetripletlist_r.html"},{"title":"ResizeTripletList_c – NTPoly","text":"public subroutine ResizeTripletList_c(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. Contents None","tags":"","loc":"proc/resizetripletlist_c.html"},{"title":"AppendToTripletList_r – NTPoly","text":"public subroutine AppendToTripletList_r(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. Contents None","tags":"","loc":"proc/appendtotripletlist_r.html"},{"title":"AppendToTripletList_c – NTPoly","text":"public subroutine AppendToTripletList_c(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append. Contents None","tags":"","loc":"proc/appendtotripletlist_c.html"},{"title":"AccumulateTripletList_r – NTPoly","text":"public subroutine AccumulateTripletList_r(this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to add in. Contents None","tags":"","loc":"proc/accumulatetripletlist_r.html"},{"title":"AccumulateTripletList_c – NTPoly","text":"public subroutine AccumulateTripletList_c(this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to add in. Contents None","tags":"","loc":"proc/accumulatetripletlist_c.html"},{"title":"SetTripletAt_r – NTPoly","text":"public subroutine SetTripletAt_r(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. Contents None","tags":"","loc":"proc/settripletat_r.html"},{"title":"SetTripletAt_c – NTPoly","text":"public subroutine SetTripletAt_c(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set. Contents None","tags":"","loc":"proc/settripletat_c.html"},{"title":"GetTripletAt_r – NTPoly","text":"public subroutine GetTripletAt_r(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. Contents None","tags":"","loc":"proc/gettripletat_r.html"},{"title":"GetTripletAt_c – NTPoly","text":"public subroutine GetTripletAt_c(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value. Contents None","tags":"","loc":"proc/gettripletat_c.html"},{"title":"SortTripletList_r – NTPoly","text":"public subroutine SortTripletList_r(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. Contents None","tags":"","loc":"proc/sorttripletlist_r.html"},{"title":"SortTripletList_c – NTPoly","text":"public subroutine SortTripletList_c(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. Contents None","tags":"","loc":"proc/sorttripletlist_c.html"},{"title":"RedistributeTripletLists_r – NTPoly","text":"public subroutine RedistributeTripletLists_r(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. Contents None","tags":"","loc":"proc/redistributetripletlists_r.html"},{"title":"RedistributeTripletLists_c – NTPoly","text":"public subroutine RedistributeTripletLists_c(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list. Contents None","tags":"","loc":"proc/redistributetripletlists_c.html"},{"title":"ShiftTripletList_r – NTPoly","text":"public subroutine ShiftTripletList_r(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. Contents None","tags":"","loc":"proc/shifttripletlist_r.html"},{"title":"ShiftTripletList_c – NTPoly","text":"public subroutine ShiftTripletList_c(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. Contents None","tags":"","loc":"proc/shifttripletlist_c.html"},{"title":"SortDenseTripletList_r – NTPoly","text":"public subroutine SortDenseTripletList_r(input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_r ), intent(out) :: sorted_list Sorted and ready to use for building matrices. Contents None","tags":"","loc":"proc/sortdensetripletlist_r.html"},{"title":"SortDenseTripletList_c – NTPoly","text":"public subroutine SortDenseTripletList_c(input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_c ), intent(out) :: sorted_list Sorted and ready to use for building matrices. Contents None","tags":"","loc":"proc/sortdensetripletlist_c.html"},{"title":"SymmetrizeTripletList_r – NTPoly","text":"public subroutine SymmetrizeTripletList_r(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. Contents None","tags":"","loc":"proc/symmetrizetripletlist_r.html"},{"title":"SymmetrizeTripletList_c – NTPoly","text":"public subroutine SymmetrizeTripletList_c(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. Contents None","tags":"","loc":"proc/symmetrizetripletlist_c.html"},{"title":"ConvertTripletListToReal – NTPoly","text":"public subroutine ConvertTripletListToReal(cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. Contents None","tags":"","loc":"proc/converttripletlisttoreal.html"},{"title":"ConvertTripletListToComplex – NTPoly","text":"public subroutine ConvertTripletListToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list. Contents None","tags":"","loc":"proc/converttripletlisttocomplex.html"},{"title":"TripletList_r – NTPoly","text":"public interface TripletList_r Contents Module Procedures ConstructTripletList_r Module Procedures public pure function ConstructTripletList_r (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_r ) The triplet list to construct.","tags":"","loc":"interface/tripletlist_r.html"},{"title":"TripletList_c – NTPoly","text":"public interface TripletList_c Contents Module Procedures ConstructTripletList_c Module Procedures public pure function ConstructTripletList_c (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_c ) The triplet list to construct.","tags":"","loc":"interface/tripletlist_c.html"},{"title":"ConstructTripletList – NTPoly","text":"public interface ConstructTripletList Contents Module Procedures ConstructTripletListSup_r ConstructTripletListSup_c Module Procedures public subroutine ConstructTripletListSup_r (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). public subroutine ConstructTripletListSup_c (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0).","tags":"","loc":"interface/constructtripletlist.html"},{"title":"DestructTripletList – NTPoly","text":"public interface DestructTripletList Contents Module Procedures DestructTripletList_r DestructTripletList_c Module Procedures public subroutine DestructTripletList_r (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. public subroutine DestructTripletList_c (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct.","tags":"","loc":"interface/destructtripletlist.html"},{"title":"ResizeTripletList – NTPoly","text":"public interface ResizeTripletList Contents Module Procedures ResizeTripletList_r ResizeTripletList_c Module Procedures public subroutine ResizeTripletList_r (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. public subroutine ResizeTripletList_c (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to.","tags":"","loc":"interface/resizetripletlist.html"},{"title":"AppendToTripletList – NTPoly","text":"public interface AppendToTripletList Contents Module Procedures AppendToTripletList_r AppendToTripletList_c Module Procedures public subroutine AppendToTripletList_r (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. public subroutine AppendToTripletList_c (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append.","tags":"","loc":"interface/appendtotripletlist.html"},{"title":"AccumulateTripletList – NTPoly","text":"public interface AccumulateTripletList Contents Module Procedures AccumulateTripletList_r AccumulateTripletList_c Module Procedures public subroutine AccumulateTripletList_r (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to add in. public subroutine AccumulateTripletList_c (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to add in.","tags":"","loc":"interface/accumulatetripletlist.html"},{"title":"SetTripletAt – NTPoly","text":"public interface SetTripletAt Contents Module Procedures SetTripletAt_r SetTripletAt_c Module Procedures public subroutine SetTripletAt_r (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. public subroutine SetTripletAt_c (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set.","tags":"","loc":"interface/settripletat.html"},{"title":"GetTripletAt – NTPoly","text":"public interface GetTripletAt Contents Module Procedures GetTripletAt_r GetTripletAt_c Module Procedures public subroutine GetTripletAt_r (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. public subroutine GetTripletAt_c (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value.","tags":"","loc":"interface/gettripletat.html"},{"title":"SortTripletList – NTPoly","text":"public interface SortTripletList Contents Module Procedures SortTripletList_r SortTripletList_c Module Procedures public subroutine SortTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. public subroutine SortTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort.","tags":"","loc":"interface/sorttripletlist.html"},{"title":"SortDenseTripletList – NTPoly","text":"public interface SortDenseTripletList Contents Module Procedures SortDenseTripletList_r SortDenseTripletList_c Module Procedures public subroutine SortDenseTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_r ), intent(out) :: sorted_list Sorted and ready to use for building matrices. public subroutine SortDenseTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_c ), intent(out) :: sorted_list Sorted and ready to use for building matrices.","tags":"","loc":"interface/sortdensetripletlist.html"},{"title":"SymmetrizeTripletList – NTPoly","text":"public interface SymmetrizeTripletList Contents Module Procedures SymmetrizeTripletList_r SymmetrizeTripletList_c Module Procedures public subroutine SymmetrizeTripletList_r (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public subroutine SymmetrizeTripletList_c (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry.","tags":"","loc":"interface/symmetrizetripletlist.html"},{"title":"GetTripletListSize – NTPoly","text":"public interface GetTripletListSize Contents Module Procedures GetTripletListSize_r GetTripletListSize_c Module Procedures public pure function GetTripletListSize_r (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. public pure function GetTripletListSize_c (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list.","tags":"","loc":"interface/gettripletlistsize.html"},{"title":"RedistributeTripletLists – NTPoly","text":"public interface RedistributeTripletLists Contents Module Procedures RedistributeTripletLists_r RedistributeTripletLists_c Module Procedures public subroutine RedistributeTripletLists_r (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. public subroutine RedistributeTripletLists_c (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list.","tags":"","loc":"interface/redistributetripletlists.html"},{"title":"ShiftTripletList – NTPoly","text":"public interface ShiftTripletList Contents Module Procedures ShiftTripletList_r ShiftTripletList_c Module Procedures public subroutine ShiftTripletList_r (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public subroutine ShiftTripletList_c (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by.","tags":"","loc":"interface/shifttripletlist.html"},{"title":"ConvertTripletListType – NTPoly","text":"public interface ConvertTripletListType Contents Module Procedures ConvertTripletListToReal ConvertTripletListToComplex Module Procedures public subroutine ConvertTripletListToReal (cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. public subroutine ConvertTripletListToComplex (rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list.","tags":"","loc":"interface/converttripletlisttype.html"},{"title":"SetParametersConvergeDiff – NTPoly","text":"public subroutine SetParametersConvergeDiff(this, new_value) Set the value of the convergence difference. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. Contents None","tags":"","loc":"proc/setparametersconvergediff.html"},{"title":"SetParametersMaxIterations – NTPoly","text":"public subroutine SetParametersMaxIterations(this, new_value) Set the value of the max iterations. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. integer, intent(in) :: new_value Value to set it to. Contents None","tags":"","loc":"proc/setparametersmaxiterations.html"},{"title":"SetParametersThreshold – NTPoly","text":"public subroutine SetParametersThreshold(this, new_value) Set the value of the threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. Contents None","tags":"","loc":"proc/setparametersthreshold.html"},{"title":"SetParametersBeVerbose – NTPoly","text":"public subroutine SetParametersBeVerbose(this, new_value) Set the value of the verbosity. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. logical, intent(in) :: new_value Value to set it to. Contents None","tags":"","loc":"proc/setparametersbeverbose.html"},{"title":"SetParametersLoadBalance – NTPoly","text":"public subroutine SetParametersLoadBalance(this, new_value) Set the value of the load balance. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. type( Permutation_t ), intent(in) :: new_value Value to set it to. Contents None","tags":"","loc":"proc/setparametersloadbalance.html"},{"title":"PrintParameters – NTPoly","text":"public subroutine PrintParameters(this) Print out the iterative solver parameter values. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: this The parameter object. Contents None","tags":"","loc":"proc/printparameters.html"},{"title":"DestructSolverParameters – NTPoly","text":"public subroutine DestructSolverParameters(this) Cleanup the solver parameters datastructure. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. Contents None","tags":"","loc":"proc/destructsolverparameters.html"},{"title":"SolverParameters_t – NTPoly","text":"public interface SolverParameters_t Contents Module Procedures SolverParameters_init Module Procedures private pure function SolverParameters_init(converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in) result(this) Construct a data type which stores iterative solver parameters. Arguments Type Intent Optional Attributes Name real(kind=NTREAL), intent(in), optional :: converge_diff_in Converge_diff_in the difference between iterations to consider\n a calculation converged. real(kind=NTREAL), intent(in), optional :: threshold_in The zero threshold integer, intent(in), optional :: max_iterations_in The maximum number of iterations to perform logical, intent(in), optional :: be_verbose_in Whether to print during the calculation (default = False) type( Permutation_t ), intent(in), optional :: BalancePermutation_in For load balancing Return Value type( SolverParameters_t )","tags":"","loc":"interface/solverparameters_t.html"},{"title":"MapMatrix_psr – NTPoly","text":"public subroutine MapMatrix_psr(inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (real). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. Contents None","tags":"","loc":"proc/mapmatrix_psr.html"},{"title":"MapMatrix_psc – NTPoly","text":"public subroutine MapMatrix_psc(inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (complex). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. Contents None","tags":"","loc":"proc/mapmatrix_psc.html"},{"title":"MapTripletList – NTPoly","text":"public interface MapTripletList Contents Module Procedures MapTripletList_r MapTripletList_c MapTripletListArray_r MapTripletListArray_c Module Procedures private subroutine MapTripletList_r(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletList_c(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletListArray_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletListArray_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0).","tags":"","loc":"interface/maptripletlist.html"},{"title":"RegisterTimer – NTPoly","text":"public subroutine RegisterTimer(timer_name) Register a timer with the timer module.  Call this before using that timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Contents None","tags":"","loc":"proc/registertimer.html"},{"title":"StartTimer – NTPoly","text":"public subroutine StartTimer(timer_name) Start the clock running for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents None","tags":"","loc":"proc/starttimer.html"},{"title":"StopTimer – NTPoly","text":"public subroutine StopTimer(timer_name) Stop the clock for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents None","tags":"","loc":"proc/stoptimer.html"},{"title":"PrintTimer – NTPoly","text":"public subroutine PrintTimer(timer_name) Print out the elapsed time for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents None","tags":"","loc":"proc/printtimer.html"},{"title":"PrintAllTimers – NTPoly","text":"public subroutine PrintAllTimers() Print out the elapsed time for each timer on this process. Arguments None Contents None","tags":"","loc":"proc/printalltimers.html"},{"title":"PrintAllTimersDistributed – NTPoly","text":"public subroutine PrintAllTimersDistributed() Print out the elapsed time for each timer based on the max value across\n processes. Arguments None Contents None","tags":"","loc":"proc/printalltimersdistributed.html"},{"title":"PermuteMatrix – NTPoly","text":"public subroutine PermuteMatrix(mat, mat_out, permutation, memorypool_in) Apply a permutation to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat The matrix to permute. type( Matrix_ps ), intent(inout) :: mat_out The permuted matrix. type( Permutation_t ), intent(in) :: permutation The permutation to apply. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use Contents None","tags":"","loc":"proc/permutematrix.html"},{"title":"UndoPermuteMatrix – NTPoly","text":"public subroutine UndoPermuteMatrix(mat, mat_out, permutation, memorypool_in) Undo a permutation applied to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat Matrix to undo permutation of. type( Matrix_ps ), intent(inout) :: mat_out Unpermuted matrix. type( Permutation_t ), intent(in) :: permutation Permutation to remove. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use. Contents None","tags":"","loc":"proc/undopermutematrix.html"},{"title":"MatrixMemoryPool_lr – NTPoly","text":"public interface MatrixMemoryPool_lr Contents Module Procedures ConstructMatrixMemoryPool_lr Module Procedures private function ConstructMatrixMemoryPool_lr(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lr ),\n  TARGET The matrix to construct.","tags":"","loc":"interface/matrixmemorypool_lr.html"},{"title":"MatrixMemoryPool_lc – NTPoly","text":"public interface MatrixMemoryPool_lc Contents Module Procedures ConstructMatrixMemoryPool_lc Module Procedures private function ConstructMatrixMemoryPool_lc(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lc ),\n  TARGET The matrix to construct.","tags":"","loc":"interface/matrixmemorypool_lc.html"},{"title":"ConstructMatrixMemoryPool – NTPoly","text":"public interface ConstructMatrixMemoryPool Contents Module Procedures ConstructMatrixMemoryPoolSub_lr ConstructMatrixMemoryPoolSub_lc Module Procedures private subroutine ConstructMatrixMemoryPoolSub_lr(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), TARGET :: this The matrix to construct. integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). private subroutine ConstructMatrixMemoryPoolSub_lc(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), TARGET :: this The matrix to construct. integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional).","tags":"","loc":"interface/constructmatrixmemorypool.html"},{"title":"DestructMatrixMemoryPool – NTPoly","text":"public interface DestructMatrixMemoryPool Contents Module Procedures DestructMatrixMemoryPool_lr DestructMatrixMemoryPool_lc Module Procedures private subroutine DestructMatrixMemoryPool_lr(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout) :: this The matrix being destructed. private subroutine DestructMatrixMemoryPool_lc(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout) :: this The matrix being destructed.","tags":"","loc":"interface/destructmatrixmemorypool~2.html"},{"title":"CheckMemoryPoolValidity – NTPoly","text":"public interface CheckMemoryPoolValidity Contents Module Procedures CheckMemoryPoolValidity_lr CheckMemoryPoolValidity_lc Module Procedures private pure function CheckMemoryPoolValidity_lr(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\n the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. private pure function CheckMemoryPoolValidity_lc(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\n Checks if a given memory pool has been validly allocated to handle\n the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid.","tags":"","loc":"interface/checkmemorypoolvalidity~2.html"},{"title":"SetPoolSparsity – NTPoly","text":"public interface SetPoolSparsity Contents Module Procedures SetPoolSparsity_lr SetPoolSparsity_lc Module Procedures private subroutine SetPoolSparsity_lr(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. private subroutine SetPoolSparsity_lc(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value.","tags":"","loc":"interface/setpoolsparsity.html"},{"title":"PM – NTPoly","text":"public subroutine PM(Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the PM method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents None","tags":"","loc":"proc/pm.html"},{"title":"TRS2 – NTPoly","text":"public subroutine TRS2(Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS2 method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents None","tags":"","loc":"proc/trs2.html"},{"title":"TRS4 – NTPoly","text":"public subroutine TRS4(Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS4 method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents None","tags":"","loc":"proc/trs4.html"},{"title":"HPCP – NTPoly","text":"public subroutine HPCP(Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the HPCP method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents None","tags":"","loc":"proc/hpcp.html"},{"title":"EnergyDensityMatrix – NTPoly","text":"public subroutine EnergyDensityMatrix(Hamiltonian, Density, EnergyDensity, threshold_in) Compute the energy-weighted density matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute from. type( Matrix_ps ), intent(in) :: Density The density matrix. type( Matrix_ps ), intent(inout) :: EnergyDensity The energy-weighted density matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0). Contents None","tags":"","loc":"proc/energydensitymatrix.html"},{"title":"TestReduceSizeRequest – NTPoly","text":"public function TestReduceSizeRequest(helper) result(request_completed) Test if a request for the size of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents None","tags":"","loc":"proc/testreducesizerequest.html"},{"title":"TestReduceInnerRequest – NTPoly","text":"public function TestReduceInnerRequest(helper) result(request_completed) Test if a request for the inner indices of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents None","tags":"","loc":"proc/testreduceinnerrequest.html"},{"title":"TestReduceDataRequest – NTPoly","text":"public function TestReduceDataRequest(helper) result(request_completed) Test if a request for the data of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents None","tags":"","loc":"proc/testreducedatarequest.html"},{"title":"ReduceAndComposeMatrixSizes – NTPoly","text":"public interface ReduceAndComposeMatrixSizes Contents Module Procedures ReduceAndComposeMatrixSizes_lsr ReduceAndComposeMatrixSizes_lsc Module Procedures private subroutine ReduceAndComposeMatrixSizes_lsr(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private subroutine ReduceAndComposeMatrixSizes_lsc(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: communicator type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper","tags":"","loc":"interface/reduceandcomposematrixsizes.html"},{"title":"ReduceAndComposeMatrixData – NTPoly","text":"public interface ReduceAndComposeMatrixData Contents Module Procedures ReduceAndComposeMatrixData_lsr ReduceAndComposeMatrixData_lsc Module Procedures private subroutine ReduceAndComposeMatrixData_lsr(matrix, communicator, gathered_matrix, helper) Second function to call, will gather the data and align it one matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndComposeMatrixData_lsc(matrix, communicator, gathered_matrix, helper) Second function to call, will gather the data and align it one matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandcomposematrixdata.html"},{"title":"ReduceAndComposeMatrixCleanup – NTPoly","text":"public interface ReduceAndComposeMatrixCleanup Contents Module Procedures ReduceAndComposeMatrixCleanup_lsr ReduceAndComposeMatrixCleanup_lsc Module Procedures private subroutine ReduceAndComposeMatrixCleanup_lsr(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndComposeMatrixCleanup_lsc(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandcomposematrixcleanup.html"},{"title":"ReduceAndSumMatrixSizes – NTPoly","text":"public interface ReduceAndSumMatrixSizes Contents Module Procedures ReduceAndSumMatrixSizes_lsr ReduceAndSumMatrixSizes_lsc Module Procedures private subroutine ReduceAndSumMatrixSizes_lsr(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private subroutine ReduceAndSumMatrixSizes_lsc(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: communicator type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper","tags":"","loc":"interface/reduceandsummatrixsizes.html"},{"title":"ReduceAndSumMatrixData – NTPoly","text":"public interface ReduceAndSumMatrixData Contents Module Procedures ReduceAndSumMatrixData_lsr ReduceAndSumMatrixData_lsc Module Procedures private subroutine ReduceAndSumMatrixData_lsr(matrix, gathered_matrix, communicator, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. integer, intent(inout) :: communicator The communicator to send along. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndSumMatrixData_lsc(matrix, gathered_matrix, communicator, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. integer, intent(inout) :: communicator The communicator to send along. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandsummatrixdata.html"},{"title":"ReduceAndSumMatrixCleanup – NTPoly","text":"public interface ReduceAndSumMatrixCleanup Contents Module Procedures ReduceAndSumMatrixCleanup_lsr ReduceAndSumMatrixCleanup_lsc Module Procedures private subroutine ReduceAndSumMatrixCleanup_lsr(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndSumMatrixCleanup_lsc(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandsummatrixcleanup.html"},{"title":"Matrix_lsr – NTPoly","text":"public interface Matrix_lsr Contents Module Procedures ConstructEmptyMatrix_lsr ConstructMatrixFromFile_lsr ConstructMatrixFromTripletList_lsr Module Procedures private pure function ConstructEmptyMatrix_lsr(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsr ) The matrix to construct. private function ConstructMatrixFromFile_lsr(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsr ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsr(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsr ) The matrix being constructed","tags":"","loc":"interface/matrix_lsr.html"},{"title":"Matrix_lsc – NTPoly","text":"public interface Matrix_lsc Contents Module Procedures ConstructEmptyMatrix_lsc ConstructMatrixFromFile_lsc ConstructMatrixFromTripletList_lsc Module Procedures private pure function ConstructEmptyMatrix_lsc(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsc ) The matrix to construct. private function ConstructMatrixFromFile_lsc(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsc ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsc(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsc ) The matrix being constructed","tags":"","loc":"interface/matrix_lsc.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrixSub_lsr ConstructEmptyMatrixSub_lsc Module Procedures private subroutine ConstructEmptyMatrixSub_lsr(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. private subroutine ConstructEmptyMatrixSub_lsc(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero.","tags":"","loc":"interface/constructemptymatrix.html"},{"title":"ConstructMatrixFromFile – NTPoly","text":"public interface ConstructMatrixFromFile Contents Module Procedures ConstructMatrixFromFileSub_lsr ConstructMatrixFromFileSub_lsc Module Procedures private subroutine ConstructMatrixFromFileSub_lsr(this, file_name) Subroutine wrapper for the construct from file function. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. private subroutine ConstructMatrixFromFileSub_lsc(this, file_name) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file.","tags":"","loc":"interface/constructmatrixfromfile.html"},{"title":"ConstructMatrixFromTripletList – NTPoly","text":"public interface ConstructMatrixFromTripletList Contents Module Procedures ConstructMatrixFromTripletListSub_lsr ConstructMatrixFromTripletListSub_lsc Module Procedures private subroutine ConstructMatrixFromTripletListSub_lsr(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns private subroutine ConstructMatrixFromTripletListSub_lsc(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns","tags":"","loc":"interface/constructmatrixfromtripletlist.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_lsr DestructMatrix_lsc Module Procedures private subroutine DestructMatrix_lsr(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to free up. private subroutine DestructMatrix_lsc(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to free up.","tags":"","loc":"interface/destructmatrix.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_lsr CopyMatrix_lsc Module Procedures private subroutine CopyMatrix_lsr(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix to copy type( Matrix_lsr ), intent(inout) :: matB matB = matA private subroutine CopyMatrix_lsc(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix to copy type( Matrix_lsc ), intent(inout) :: matB matB = matA","tags":"","loc":"interface/copymatrix.html"},{"title":"GetMatrixRows – NTPoly","text":"public interface GetMatrixRows Contents Module Procedures GetMatrixRows_lsr GetMatrixRows_lsc Module Procedures private pure function GetMatrixRows_lsr(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix. Return Value integer The number of rows. private pure function GetMatrixRows_lsc(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix. Return Value integer The number of rows.","tags":"","loc":"interface/getmatrixrows.html"},{"title":"GetMatrixColumns – NTPoly","text":"public interface GetMatrixColumns Contents Module Procedures GetMatrixColumns_lsr GetMatrixColumns_lsc Module Procedures private pure function GetMatrixColumns_lsr(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this Return Value integer The number of columns. private pure function GetMatrixColumns_lsc(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this Return Value integer The number of columns.","tags":"","loc":"interface/getmatrixcolumns.html"},{"title":"ExtractMatrixRow – NTPoly","text":"public interface ExtractMatrixRow Contents Module Procedures ExtractMatrixRow_lsr ExtractMatrixRow_lsc Module Procedures private subroutine ExtractMatrixRow_lsr(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsr ), intent(inout) :: row_out The matrix representing that row. private subroutine ExtractMatrixRow_lsc(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsc ), intent(inout) :: row_out The matrix representing that row.","tags":"","loc":"interface/extractmatrixrow.html"},{"title":"ExtractMatrixColumn – NTPoly","text":"public interface ExtractMatrixColumn Contents Module Procedures ExtractMatrixColumn_lsr ExtractMatrixColumn_lsc Module Procedures private subroutine ExtractMatrixColumn_lsr(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsr ), intent(inout) :: column_out The column representing that row. private subroutine ExtractMatrixColumn_lsc(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsc ), intent(inout) :: column_out The column representing that row.","tags":"","loc":"interface/extractmatrixcolumn.html"},{"title":"SplitMatrix – NTPoly","text":"public interface SplitMatrix Contents Module Procedures SplitMatrix_lsr SplitMatrix_lsc Module Procedures private subroutine SplitMatrix_lsr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsr ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private subroutine SplitMatrix_lsc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns.","tags":"","loc":"interface/splitmatrix.html"},{"title":"SplitMatrixColumns – NTPoly","text":"public interface SplitMatrixColumns Contents Module Procedures SplitMatrixColumns_lsr SplitMatrixColumns_lsc Module Procedures private subroutine SplitMatrixColumns_lsr(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsr ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. private subroutine SplitMatrixColumns_lsc(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsc ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks.","tags":"","loc":"interface/splitmatrixcolumns.html"},{"title":"ComposeMatrix – NTPoly","text":"public interface ComposeMatrix Contents Module Procedures ComposeMatrix_lsr ComposeMatrix_lsc Module Procedures private subroutine ComposeMatrix_lsr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(block_rows,block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsr ), intent(inout) :: out_matrix The composed matrix. private subroutine ComposeMatrix_lsc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(block_rows,block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsc ), intent(inout) :: out_matrix The composed matrix.","tags":"","loc":"interface/composematrix.html"},{"title":"ComposeMatrixColumns – NTPoly","text":"public interface ComposeMatrixColumns Contents Module Procedures ComposeMatrixColumns_lsr ComposeMatrixColumns_lsc Module Procedures private subroutine ComposeMatrixColumns_lsr(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\n the first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsr ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. private subroutine ComposeMatrixColumns_lsc(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\n the first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsc ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...].","tags":"","loc":"interface/composematrixcolumns.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_lsr TransposeMatrix_lsc Module Procedures private subroutine TransposeMatrix_lsr(this, matT) Transpose a sparse matrix and return it in a separate matrix.\n The current implementation has you go from matrix to triplet list,\n triplet list to transposed triplet list. The triplet list must then be\n sorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be transposed. type( Matrix_lsr ), intent(inout) :: matT The input matrix transposed. private subroutine TransposeMatrix_lsc(this, matT) Transpose a sparse matrix and return it in a separate matrix.\n The current implementation has you go from matrix to triplet list,\n triplet list to transposed triplet list. The triplet list must then be\n sorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be transposed. type( Matrix_lsc ), intent(inout) :: matT The input matrix transposed.","tags":"","loc":"interface/transposematrix.html"},{"title":"ConjugateMatrix – NTPoly","text":"public interface ConjugateMatrix Contents Module Procedures ConjugateMatrix_lsc Module Procedures private subroutine ConjugateMatrix_lsc(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to compute the complex conjugate of.","tags":"","loc":"interface/conjugatematrix.html"},{"title":"PrintMatrix – NTPoly","text":"public interface PrintMatrix Contents Module Procedures PrintMatrix_lsr PrintMatrix_lsc Module Procedures private subroutine PrintMatrix_lsr(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. private subroutine PrintMatrix_lsc(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to.","tags":"","loc":"interface/printmatrix.html"},{"title":"MatrixToTripletList – NTPoly","text":"public interface MatrixToTripletList Contents Module Procedures MatrixToTripletList_lsr MatrixToTripletList_lsc Module Procedures private subroutine MatrixToTripletList_lsr(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_r ), intent(inout) :: triplet_list The triplet list we created. private subroutine MatrixToTripletList_lsc(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_c ), intent(inout) :: triplet_list The triplet list we created.","tags":"","loc":"interface/matrixtotripletlist.html"},{"title":"ConvertMatrixType – NTPoly","text":"public interface ConvertMatrixType Contents Module Procedures ConvertMatrixType_lsrtolsc ConvertMatrixType_lsctolsr Module Procedures private subroutine ConvertMatrixType_lsrtolsc(cin, rout) Convert a complex matrix to a real matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: cin The starting matrix. type( Matrix_lsr ), intent(inout) :: rout Real valued matrix. private subroutine ConvertMatrixType_lsctolsr(rin, cout) Convert a real matrix to a complex matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: rin The starting matrix. type( Matrix_lsc ), intent(inout) :: cout The complex valued matrix.","tags":"","loc":"interface/convertmatrixtype.html"},{"title":"ComputeExponential – NTPoly","text":"public subroutine ComputeExponential(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computeexponential.html"},{"title":"ComputeExponentialPade – NTPoly","text":"public subroutine ComputeExponentialPade(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a pade approximation.\n Be warned, the pade method can result in a lot of intermediate fill. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computeexponentialpade.html"},{"title":"ComputeExponentialTaylor – NTPoly","text":"public subroutine ComputeExponentialTaylor(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a taylor series expansion.\n This is only really useful if you have a very small spectrum, because\n quite a bit of scaling is required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computeexponentialtaylor.html"},{"title":"ComputeLogarithm – NTPoly","text":"public subroutine ComputeLogarithm(InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computelogarithm.html"},{"title":"ComputeLogarithmTaylor – NTPoly","text":"public subroutine ComputeLogarithmTaylor(InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix using a taylor series expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/computelogarithmtaylor.html"},{"title":"ConstructDefaultPermutation – NTPoly","text":"public subroutine ConstructDefaultPermutation(this, matrix_dimension) Constructs a permutation that preserves the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: matrix_dimension The dimension of the matrix. Contents None","tags":"","loc":"proc/constructdefaultpermutation.html"},{"title":"ConstructReversePermutation – NTPoly","text":"public subroutine ConstructReversePermutation(this, matrix_dimension) Constructs a permutation that reverses the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. Contents None","tags":"","loc":"proc/constructreversepermutation.html"},{"title":"ConstructRandomPermutation – NTPoly","text":"public subroutine ConstructRandomPermutation(this, matrix_dimension, process_grid_in) Constructs a permutation that has a random order.\n Implements Knuth shuffle. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\n This is to synchronize random number across processes. Contents None","tags":"","loc":"proc/constructrandompermutation.html"},{"title":"ConstructLimitedRandomPermutation – NTPoly","text":"public subroutine ConstructLimitedRandomPermutation(this, actual_matrix_dimension, logical_matrix_dimension, process_grid_in) Constructs a permutation that has a random order, but there is no\n permutation from beyond the actual matrix dimension. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: actual_matrix_dimension Actual size of the matrix. integer, intent(in) :: logical_matrix_dimension Padded size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\n This is to synchronize random number across processes. Contents None","tags":"","loc":"proc/constructlimitedrandompermutation.html"},{"title":"DestructPermutation – NTPoly","text":"public subroutine DestructPermutation(this) Destruct a permutation object. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to destruct. Contents None","tags":"","loc":"proc/destructpermutation.html"},{"title":"CGSolver – NTPoly","text":"public subroutine CGSolver(AMat, XMat, BMat, solver_parameters_in) Solve the matrix equation AX = B using the conjugate gradient method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: XMat The solved for matrix X. type( Matrix_ps ), intent(in) :: BMat The right hand side. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/cgsolver.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_horner Module Procedures private subroutine ConstructPolynomial_horner(this, degree) Construct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial.","tags":"","loc":"interface/constructpolynomial~2.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_horner Module Procedures private subroutine DestructPolynomial_horner(this) Destruct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial~2.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_horner Module Procedures private subroutine SetCoefficient_horner(this, degree, coefficient) Set a coefficient of a Hermite polynomial. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree The degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value to set.","tags":"","loc":"interface/setcoefficient~2.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_horner Module Procedures private subroutine Compute_horner(InputMat, OutputMat, poly, solver_parameters_in) Compute The Hermite Polynomial of the matrix.\n This method uses the standard Hermite Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix. type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( HermitePolynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"interface/compute~2.html"},{"title":"ScaleMatrix – NTPoly","text":"public interface ScaleMatrix Contents Module Procedures ScaleMatrix_lsr ScaleMatrix_lsc ScaleMatrix_lsc_c Module Procedures private subroutine ScaleMatrix_lsr(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private subroutine ScaleMatrix_lsc(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private subroutine ScaleMatrix_lsc_c(matA, constant) Will scale a sparse matrix by a constant.\n Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. complex(kind=NTCOMPLEX), intent(in) :: constant Constant scale factor.","tags":"","loc":"interface/scalematrix.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_lsr IncrementMatrix_lsc Module Procedures private subroutine IncrementMatrix_lsr(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\n This will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default=1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0). private subroutine IncrementMatrix_lsc(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\n This will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default=1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0).","tags":"","loc":"interface/incrementmatrix.html"},{"title":"DotMatrix – NTPoly","text":"public interface DotMatrix Contents Module Procedures DotMatrix_lsr DotMatrix_lsc Module Procedures private subroutine DotMatrix_lsr(matA, matB, product) Product = sum(MatA[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product Dot product. private subroutine DotMatrix_lsc(matA, matB, product) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product Dot product.","tags":"","loc":"interface/dotmatrix.html"},{"title":"PairwiseMultiplyMatrix – NTPoly","text":"public interface PairwiseMultiplyMatrix Contents Module Procedures PairwiseMultiplyMatrix_lsr PairwiseMultiplyMatrix_lsc Module Procedures private subroutine PairwiseMultiplyMatrix_lsr(matA, matB, matC) Pairwise Multiply two matrices.\n This will utilize the sparse vector pairwise multiply routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = MatA mult MatB. private subroutine PairwiseMultiplyMatrix_lsc(matA, matB, matC) Pairwise Multiply two matrices.\n This will utilize the sparse vector pairwise routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = MatA mult MatB.","tags":"","loc":"interface/pairwisemultiplymatrix.html"},{"title":"MatrixMultiply – NTPoly","text":"public interface MatrixMultiply Contents Module Procedures GemmMatrix_lsr GemmMatrix_lsc Module Procedures private subroutine GemmMatrix_lsr(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lr ), intent(inout), optional TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. private subroutine GemmMatrix_lsc(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lc ), intent(inout), optional TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation.","tags":"","loc":"interface/matrixmultiply.html"},{"title":"MatrixColumnNorm – NTPoly","text":"public interface MatrixColumnNorm Contents Module Procedures MatrixColumnNorm_lsr MatrixColumnNorm_lsc Module Procedures private subroutine MatrixColumnNorm_lsr(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. private subroutine MatrixColumnNorm_lsc(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix.","tags":"","loc":"interface/matrixcolumnnorm.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_lsr MatrixNorm_lsc Module Procedures private pure function MatrixNorm_lsr(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private pure function MatrixNorm_lsc(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix.","tags":"","loc":"interface/matrixnorm.html"},{"title":"MatrixGrandSum – NTPoly","text":"public interface MatrixGrandSum Contents Module Procedures MatrixGrandSum_lsr MatrixGrandSum_lsc Module Procedures private subroutine MatrixGrandSum_lsr(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to sum real(kind=NTREAL), intent(out) :: sum_value The sum of the matrix elements private subroutine MatrixGrandSum_lsc(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to sum complex(kind=NTCOMPLEX), intent(out) :: sum_value The sum of the matrix elements","tags":"","loc":"interface/matrixgrandsum.html"},{"title":"GershgorinBounds – NTPoly","text":"public subroutine GershgorinBounds(this, min_value, max_value) Compute a bounds on the minimum and maximum eigenvalue of a matrix.\n Uses Gershgorin's theorem. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: min_value A lower bound on the eigenspectrum. real(kind=NTREAL), intent(out) :: max_value An uppder bound on the eigenspectrum. Contents None","tags":"","loc":"proc/gershgorinbounds.html"},{"title":"PowerBounds – NTPoly","text":"public subroutine PowerBounds(this, max_value, solver_parameters_in) Compute a bounds on the maximum eigenvalue of a matrix.\n Uses The Power Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: max_value An upper bound on the eigenspectrum. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The parameters for this calculation. Contents None","tags":"","loc":"proc/powerbounds.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_stand Module Procedures private subroutine ConstructPolynomial_stand(this, degree) Construct a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial.","tags":"","loc":"interface/constructpolynomial~3.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_stand Module Procedures private subroutine DestructPolynomial_stand(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial~3.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_stand Module Procedures private subroutine SetCoefficient_stand(this, degree, coefficient) Set coefficient of a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value.","tags":"","loc":"interface/setcoefficient~3.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_stand Module Procedures private subroutine Compute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using Horner's Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/compute~3.html"},{"title":"FactorizedCompute – NTPoly","text":"public interface FactorizedCompute Contents Module Procedures FactorizedCompute_stand Module Procedures private subroutine FactorizedCompute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using Paterson and Stockmeyer's method.\n This method first factors the polynomial to reduce the number of\n matrix multiplies required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly The polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/factorizedcompute~2.html"},{"title":"Matrix_ldr – NTPoly","text":"public interface Matrix_ldr Contents Module Procedures ConstructEmptyMatrix_ldr Module Procedures private pure function ConstructEmptyMatrix_ldr(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldr ) The matrix to construct.","tags":"","loc":"interface/matrix_ldr.html"},{"title":"Matrix_ldc – NTPoly","text":"public interface Matrix_ldc Contents Module Procedures ConstructEmptyMatrix_ldc Module Procedures private pure function ConstructEmptyMatrix_ldc(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldc ) The matrix to construct.","tags":"","loc":"interface/matrix_ldc.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrixSup_ldr ConstructEmptyMatrixSup_ldc Module Procedures private subroutine ConstructEmptyMatrixSup_ldr(this, rows, columns) A subroutine wrapper for the empty constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to construct integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix private subroutine ConstructEmptyMatrixSup_ldc(this, rows, columns) A subroutine style wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of rows of the matrix. integer, intent(in) :: columns The number of columns o the matrix.","tags":"","loc":"interface/constructemptymatrix~2.html"},{"title":"ConstructMatrixDFromS – NTPoly","text":"public interface ConstructMatrixDFromS Contents Module Procedures ConstructMatrixDFromS_ldr ConstructMatrixDFromS_ldc Module Procedures private subroutine ConstructMatrixDFromS_ldr(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldr ), intent(inout) :: dense_matrix Output. Must be preallocated. private subroutine ConstructMatrixDFromS_ldc(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldc ), intent(inout) :: dense_matrix Dense matrix output. Must be preallocated.","tags":"","loc":"interface/constructmatrixdfroms.html"},{"title":"ConstructMatrixSFromD – NTPoly","text":"public interface ConstructMatrixSFromD Contents Module Procedures ConstructMatrixSFromD_ldr ConstructMatrixSFromD_ldc Module Procedures private subroutine ConstructMatrixSFromD_ldr(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: dense_matrix Matrix to convert. type( Matrix_lsr ), intent(inout) :: sparse_matrix Output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. private subroutine ConstructMatrixSFromD_ldc(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: dense_matrix The matrix to convert. type( Matrix_lsc ), intent(inout) :: sparse_matrix The sparse output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero.","tags":"","loc":"interface/constructmatrixsfromd.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_ldr CopyMatrix_ldc Module Procedures private subroutine CopyMatrix_ldr(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA The matrix to copy. type( Matrix_ldr ), intent(inout) :: matB matB = matA private subroutine CopyMatrix_ldc(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to copy. type( Matrix_ldc ), intent(inout) :: matB matB = matA","tags":"","loc":"interface/copymatrix~2.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_ldr DestructMatrix_ldc Module Procedures private subroutine DestructMatrix_ldr(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to delete. private subroutine DestructMatrix_ldc(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this This the matrix to delete.","tags":"","loc":"interface/destructmatrix~2.html"},{"title":"SplitMatrix – NTPoly","text":"public interface SplitMatrix Contents Module Procedures SplitMatrix_ldr SplitMatrix_ldc Module Procedures private subroutine SplitMatrix_ldr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldr ), intent(inout), DIMENSION(:,:) :: split_array A block_columns x block_rows array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private subroutine SplitMatrix_ldc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns.","tags":"","loc":"interface/splitmatrix~2.html"},{"title":"ComposeMatrix – NTPoly","text":"public interface ComposeMatrix Contents Module Procedures ComposeMatrix_ldr ComposeMatrix_ldc Module Procedures private subroutine ComposeMatrix_ldr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldr ), intent(inout) :: out_matrix The composed matrix. private subroutine ComposeMatrix_ldc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldc ), intent(inout) :: out_matrix The composed matrix.","tags":"","loc":"interface/composematrix~2.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_ldr MatrixNorm_ldc Module Procedures private function MatrixNorm_ldr(this) result(norm) Compute the norm of a dense matrix.\n Computes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private function MatrixNorm_ldc(this) result(norm) Compute the norm of a dense matrix.\n Computes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix.","tags":"","loc":"interface/matrixnorm~2.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_ldr IncrementMatrix_ldc Module Procedures private subroutine IncrementMatrix_ldr(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA is added type( Matrix_ldr ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. private subroutine IncrementMatrix_ldc(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA MatA is added type( Matrix_ldc ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter.","tags":"","loc":"interface/incrementmatrix~2.html"},{"title":"MultiplyMatrix – NTPoly","text":"public interface MultiplyMatrix Contents Module Procedures MultiplyMatrix_ldr MultiplyMatrix_ldc Module Procedures private subroutine MultiplyMatrix_ldr(MatA, MatB, MatC) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA The first matrix. type( Matrix_ldr ), intent(in) :: MatB The second matrix. type( Matrix_ldr ), intent(inout) :: MatC MatC = MatA*MatB. private subroutine MultiplyMatrix_ldc(MatA, MatB, MatC) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The first matrix. type( Matrix_ldc ), intent(in) :: MatB The second matrix. type( Matrix_ldc ), intent(inout) :: MatC MatC = MatA*MatB.","tags":"","loc":"interface/multiplymatrix.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_ldr TransposeMatrix_ldc Module Procedures private subroutine TransposeMatrix_ldr(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA matA the matrix to transpose. type( Matrix_ldr ), intent(inout) :: matAT matAT = matA&#94;T. private subroutine TransposeMatrix_ldc(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to transpose. type( Matrix_ldc ), intent(inout) :: matAT matAT = matA&#94;T.","tags":"","loc":"interface/transposematrix~2.html"},{"title":"ParseMMHeader – NTPoly","text":"public function ParseMMHeader(line, sparsity_type, data_type, pattern_type) result(no_error) Parse a matrix market header. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line String to parse. integer, intent(out) :: sparsity_type If coordinate or array type. integer, intent(out) :: data_type If real, integer, complex, pattern. integer, intent(out) :: pattern_type If general, symmetric, skew_symmetric, hermitian. Return Value logical True if no errors. Contents None","tags":"","loc":"proc/parsemmheader.html"},{"title":"SetMatrixProcessGrid – NTPoly","text":"public subroutine SetMatrixProcessGrid(this, grid) When you want to change the process grid of a matrix, you can call\n this routine with the new process grid value. Data will be automatically\n redistributed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to set the grid of. type( ProcessGrid_t ), intent(in) :: grid The grid to set it to. Contents None","tags":"","loc":"proc/setmatrixprocessgrid.html"},{"title":"GetMatrixSlice – NTPoly","text":"public subroutine GetMatrixSlice(this, submatrix, start_row, end_row, start_column, end_column) Copy an arbitrary slice from a matrix into a new smaller matrix.\n NTPoly only works with square matrices, so if the number of rows and\n columns is different the matrix is resized to the maximum size. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( Matrix_ps ), intent(inout) :: submatrix The slice to fill. integer :: start_row The starting row to include in this matrix. integer :: end_row The ending row to include in this matrix. integer :: start_column The starting column to include in this matrix. integer :: end_column The last column to include in this matrix. Contents None","tags":"","loc":"proc/getmatrixslice.html"},{"title":"ConvertMatrixToReal – NTPoly","text":"public subroutine ConvertMatrixToReal(in, out) Converts the current matrix to a real type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Real version of the matrix. Contents None","tags":"","loc":"proc/convertmatrixtoreal.html"},{"title":"ConvertMatrixToComplex – NTPoly","text":"public subroutine ConvertMatrixToComplex(in, out) Converts the current matrix to a complex type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Complex version of the matrix. Contents None","tags":"","loc":"proc/convertmatrixtocomplex.html"},{"title":"ResizeMatrix – NTPoly","text":"public subroutine ResizeMatrix(this, new_size) Change the size of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to resize. integer, intent(in) :: new_size The new size of the matrix. Contents None","tags":"","loc":"proc/resizematrix.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrix_ps ConstructEmptyMatrix_ps_cp Module Procedures private subroutine ConstructEmptyMatrix_ps(this, matrix_dim_, process_grid_in, is_complex_in) Construct an empty sparse, distributed, matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. integer, intent(in) :: matrix_dim_ The dimension of the full matrix. type( ProcessGrid_t ), intent(in), optional TARGET :: process_grid_in A process grid to host the matrix. logical, intent(in), optional :: is_complex_in True if you want to use complex numbers. private subroutine ConstructEmptyMatrix_ps_cp(this, reference_matrix) Construct an empty sparse, distributed, matrix using another matrix\n to determine the parameters. Note that no data is copied, the matrix\n will be empty. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. type( Matrix_ps ), intent(in) :: reference_matrix The reference matrix to take parameters from.","tags":"","loc":"interface/constructemptymatrix~3.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_ps Module Procedures private subroutine DestructMatrix_ps(this) Destruct a distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to destruct.","tags":"","loc":"interface/destructmatrix~3.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_ps Module Procedures private subroutine CopyMatrix_ps(matA, matB) Copy a distributed sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA The matrix to copy. type( Matrix_ps ), intent(inout) :: matB matB = matA.","tags":"","loc":"interface/copymatrix~3.html"},{"title":"ConstructMatrixFromMatrixMarket – NTPoly","text":"public interface ConstructMatrixFromMatrixMarket Contents Module Procedures ConstructMatrixFromMatrixMarket_ps Module Procedures private subroutine ConstructMatrixFromMatrixMarket_ps(this, file_name, process_grid_in) Construct distributed sparse matrix from a matrix market file in parallel.\n Read \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on.","tags":"","loc":"interface/constructmatrixfrommatrixmarket.html"},{"title":"ConstructMatrixFromBinary – NTPoly","text":"public interface ConstructMatrixFromBinary Contents Module Procedures ConstructMatrixFromBinary_ps Module Procedures private subroutine ConstructMatrixFromBinary_ps(this, file_name, process_grid_in) Construct a distributed sparse matrix from a binary file in parallel.\n Faster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on.","tags":"","loc":"interface/constructmatrixfrombinary.html"},{"title":"WriteMatrixToMatrixMarket – NTPoly","text":"public interface WriteMatrixToMatrixMarket Contents Module Procedures WriteMatrixToMatrixMarket_ps Module Procedures private subroutine WriteMatrixToMatrixMarket_ps(this, file_name) Write a distributed sparse matrix to a matrix market file.\n Read \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to.","tags":"","loc":"interface/writematrixtomatrixmarket.html"},{"title":"WriteMatrixToBinary – NTPoly","text":"public interface WriteMatrixToBinary Contents Module Procedures WriteMatrixToBinary_ps Module Procedures private subroutine WriteMatrixToBinary_ps(this, file_name) Save a distributed sparse matrix to a binary file.\n Faster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to.","tags":"","loc":"interface/writematrixtobinary.html"},{"title":"FillMatrixFromTripletList – NTPoly","text":"public interface FillMatrixFromTripletList Contents Module Procedures FillMatrixFromTripletList_psr FillMatrixFromTripletList_psc Module Procedures private subroutine FillMatrixFromTripletList_psr(this, triplet_list, preduplicated_in) This routine fills in a matrix based on local triplet lists. Each process\n should pass in triplet lists with global coordinates. It doesn't matter\n where each triplet is stored, as long as global coordinates are given. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to fill. type( TripletList_r ) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. private subroutine FillMatrixFromTripletList_psc(this, triplet_list, preduplicated_in) This routine fills in a matrix based on local triplet lists. Each process\n should pass in triplet lists with global coordinates. It doesn't matter\n where each triplet is stored, as long as global coordinates are given. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to fill. type( TripletList_c ) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true.","tags":"","loc":"interface/fillmatrixfromtripletlist.html"},{"title":"FillMatrixIdentity – NTPoly","text":"public interface FillMatrixIdentity Contents Module Procedures FillMatrixIdentity_ps Module Procedures private subroutine FillMatrixIdentity_ps(this) Fill in the values of a distributed matrix with the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled.","tags":"","loc":"interface/fillmatrixidentity.html"},{"title":"FillMatrixPermutation – NTPoly","text":"public interface FillMatrixPermutation Contents Module Procedures FillMatrixPermutation_ps Module Procedures private subroutine FillMatrixPermutation_ps(this, permutation_vector, permute_rows_in) Fill in the values of a distributed matrix with a permutation.\n If you don't specify permuterows, will default to permuting rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. integer, intent(in), DIMENSION(:) :: permutation_vector Describes for each row/column, where it goes. logical, intent(in), optional :: permute_rows_in If true permute rows, false permute columns.","tags":"","loc":"interface/fillmatrixpermutation.html"},{"title":"GetMatrixActualDimension – NTPoly","text":"public interface GetMatrixActualDimension Contents Module Procedures GetMatrixActualDimension_ps Module Procedures private pure function GetMatrixActualDimension_ps(this) result(DIMENSION) Get the actual dimension of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix","tags":"","loc":"interface/getmatrixactualdimension.html"},{"title":"GetMatrixLogicalDimension – NTPoly","text":"public interface GetMatrixLogicalDimension Contents Module Procedures GetMatrixLogicalDimension_ps Module Procedures private pure function GetMatrixLogicalDimension_ps(this) result(DIMENSION) Get the logical dimension of the matrix.\n Includes padding. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix","tags":"","loc":"interface/getmatrixlogicaldimension.html"},{"title":"GetMatrixTripletList – NTPoly","text":"public interface GetMatrixTripletList Contents Module Procedures GetMatrixTripletList_psr GetMatrixTripletList_psc Module Procedures private subroutine GetMatrixTripletList_psr(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. private subroutine GetMatrixTripletList_psc(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill.","tags":"","loc":"interface/getmatrixtripletlist.html"},{"title":"GetMatrixBlock – NTPoly","text":"public interface GetMatrixBlock Contents Module Procedures GetMatrixBlock_psr GetMatrixBlock_psc Module Procedures private subroutine GetMatrixBlock_psr(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\n defined by the row/column start/end values.\n This is slower than GetMatrixTripletList, because communication is required\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. integer :: start_row The starting row for data to store on this process. integer :: end_row The ending row for data to store on this process. integer :: start_column The starting col for data to store on this process integer :: end_column The ending col for data to store on this process private subroutine GetMatrixBlock_psc(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\n defined by the row/column start/end values.\n This is slower than GetMatrixTripletList, because communication is required\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. integer :: start_row The starting row for data to store on this process. integer :: end_row The ending row for data to store on this process. integer :: start_column The starting col for data to store on this process integer :: end_column The ending col for data to store on this process","tags":"","loc":"interface/getmatrixblock.html"},{"title":"PrintMatrix – NTPoly","text":"public interface PrintMatrix Contents Module Procedures PrintMatrix_ps Module Procedures private subroutine PrintMatrix_ps(this, file_name_in) Print out a distributed sparse matrix.\n This is a serial print routine, and should probably only be used for debug\n purposes. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to print. character(len=*), intent(in), optional :: file_name_in Optionally, you can pass a file to print to instead of the console.","tags":"","loc":"interface/printmatrix~2.html"},{"title":"PrintMatrixInformation – NTPoly","text":"public interface PrintMatrixInformation Contents Module Procedures PrintMatrixInformation_ps Module Procedures private subroutine PrintMatrixInformation_ps(this) Print out information about a distributed sparse matrix.\n Sparsity, and load balancing information. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this This the matrix to print information about.","tags":"","loc":"interface/printmatrixinformation.html"},{"title":"GetMatrixLoadBalance – NTPoly","text":"public interface GetMatrixLoadBalance Contents Module Procedures GetMatrixLoadBalance_ps Module Procedures private subroutine GetMatrixLoadBalance_ps(this, min_size, max_size) Get a measure of how load balanced this matrix is. For each process, the\n number of non-zero entries is calculated. Then, this function returns\n the max and min of those values. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the measure on. integer, intent(out) :: min_size The minimum entries contained on a single process. integer, intent(out) :: max_size The maximum entries contained on a single process.","tags":"","loc":"interface/getmatrixloadbalance.html"},{"title":"GetMatrixSize – NTPoly","text":"public interface GetMatrixSize Contents Module Procedures GetMatrixSize_ps Module Procedures private function GetMatrixSize_ps(this) result(total_size) Get the total number of non-zero entries in the distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to calculate the number of non-zero entries of. Return Value integer(kind=c_long) The number of non-zero entries in the matrix.","tags":"","loc":"interface/getmatrixsize.html"},{"title":"FilterMatrix – NTPoly","text":"public interface FilterMatrix Contents Module Procedures FilterMatrix_ps Module Procedures private subroutine FilterMatrix_ps(this, threshold) A utility routine that filters a sparse matrix.\n All (absolute) values below the threshold are set to zero. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to filter. real(kind=NTREAL), intent(in) :: threshold Threshold (absolute) values below this are filtered","tags":"","loc":"interface/filtermatrix.html"},{"title":"MergeMatrixLocalBlocks – NTPoly","text":"public interface MergeMatrixLocalBlocks Contents Module Procedures MergeMatrixLocalBlocks_psr MergeMatrixLocalBlocks_psc Module Procedures private subroutine MergeMatrixLocalBlocks_psr(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsr ), intent(inout) :: merged_matrix The merged matrix. private subroutine MergeMatrixLocalBlocks_psc(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsc ), intent(inout) :: merged_matrix The merged matrix.","tags":"","loc":"interface/mergematrixlocalblocks.html"},{"title":"SplitMatrixToLocalBlocks – NTPoly","text":"public interface SplitMatrixToLocalBlocks Contents Module Procedures SplitMatrixToLocalBlocks_psr SplitMatrixToLocalBlocks_psc Module Procedures private subroutine SplitMatrixToLocalBlocks_psr(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsr ), intent(in) :: matrix_to_split The matrix to split up. private subroutine SplitMatrixToLocalBlocks_psc(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsc ), intent(in) :: matrix_to_split The matrix to split up.","tags":"","loc":"interface/splitmatrixtolocalblocks.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_ps Module Procedures private subroutine TransposeMatrix_ps(AMat, TransMat) Transpose a sparse matrix. Note that this is a pure transpose, there is\n no complex conjugate performed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix to transpose. type( Matrix_ps ), intent(out) :: TransMat TransMat = A&#94;T .","tags":"","loc":"interface/transposematrix~3.html"},{"title":"ConjugateMatrix – NTPoly","text":"public interface ConjugateMatrix Contents Module Procedures ConjugateMatrix_ps Module Procedures private subroutine ConjugateMatrix_ps(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to compute the complex conjugate of.","tags":"","loc":"interface/conjugatematrix~2.html"},{"title":"CommSplitMatrix – NTPoly","text":"public interface CommSplitMatrix Contents Module Procedures CommSplitMatrix_ps Module Procedures private subroutine CommSplitMatrix_ps(this, split_mat, my_color, split_slice) Split the current communicator, and give each group a complete copy of this Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to split. type( Matrix_ps ), intent(inout) :: split_mat A copy of the matrix hosted on a small process grid. integer, intent(out) :: my_color Distinguishes between the two groups. logical, intent(out) :: split_slice If we split along the slice direction, this is True","tags":"","loc":"interface/commsplitmatrix.html"},{"title":"GatherMatrixToProcess – NTPoly","text":"public interface GatherMatrixToProcess Contents Module Procedures GatherMatrixToProcess_psr GatherMatrixToProcess_psc Module Procedures private subroutine GatherMatrixToProcess_psr(this, local_mat, proc_id) This subroutine gathers the entire matrix into a local matrix on the Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: proc_id Which process to gather on. private subroutine GatherMatrixToProcess_psc(this, local_mat, proc_id) This subroutine gathers the entire matrix into a local matrix on the Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: proc_id Which process to gather on.","tags":"","loc":"interface/gathermatrixtoprocess.html"},{"title":"SignFunction – NTPoly","text":"public subroutine SignFunction(Mat, SignMat, solver_parameters_in) Computes the matrix sign function. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The input matrix. type( Matrix_ps ), intent(inout) :: SignMat The sign of Mat. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/signfunction.html"},{"title":"PolarDecomposition – NTPoly","text":"public subroutine PolarDecomposition(Mat, Umat, Hmat, solver_parameters_in) Computes the polar decomposition of a matrix Mat = U*H. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The input matrix. type( Matrix_ps ), intent(inout) :: Umat The unitary polar factor. type( Matrix_ps ), intent(inout), optional :: Hmat The hermitian matrix factor. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents None","tags":"","loc":"proc/polardecomposition.html"},{"title":"PurificationExtrapolate – NTPoly","text":"public subroutine PurificationExtrapolate(PreviousDensity, Overlap, nel, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\n Based on the purification algorithm in \\cite niklasson2010trace . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity Previous density to extrapolate from. type( Matrix_ps ), intent(in) :: Overlap The overlap matrix of the new geometry. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/purificationextrapolate.html"},{"title":"LowdinExtrapolate – NTPoly","text":"public subroutine LowdinExtrapolate(PreviousDensity, OldOverlap, NewOverlap, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\n Based on the lowdin algorithm in \\cite exner2002comparison . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity THe previous density to extrapolate from. type( Matrix_ps ), intent(in) :: OldOverlap The old overlap matrix from the previous geometry. type( Matrix_ps ), intent(in) :: NewOverlap The new overlap matrix from the current geometry. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/lowdinextrapolate.html"},{"title":"IsRoot – NTPoly","text":"public function IsRoot(grid) result(is_root) Check if the current process is the root process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: grid The process grid. Return Value logical True if the current process is root. Contents None","tags":"","loc":"proc/isroot.html"},{"title":"GetMySlice – NTPoly","text":"public function GetMySlice(grid) result(return_val) Get the slice of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer Slice number of the current process. Contents None","tags":"","loc":"proc/getmyslice.html"},{"title":"GetMyColumn – NTPoly","text":"public function GetMyColumn(grid) result(return_val) Get the column of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The column number of the current process. Contents None","tags":"","loc":"proc/getmycolumn.html"},{"title":"GetMyRow – NTPoly","text":"public function GetMyRow(grid) result(return_val) Get the row of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The row number of the current process. Contents None","tags":"","loc":"proc/getmyrow.html"},{"title":"CopyProcessGrid – NTPoly","text":"public subroutine CopyProcessGrid(old_grid, new_grid) Copy a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: old_grid The grid to copy. type( ProcessGrid_t ), intent(inout) :: new_grid New_grid = old_grid Contents None","tags":"","loc":"proc/copyprocessgrid.html"},{"title":"DestructProcessGrid – NTPoly","text":"public subroutine DestructProcessGrid(grid_in) Destruct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout), optional :: grid_in The grid to destruct. If none specified this destroys the global grid. Contents None","tags":"","loc":"proc/destructprocessgrid.html"},{"title":"SplitProcessGrid – NTPoly","text":"public subroutine SplitProcessGrid(old_grid, new_grid, my_color, split_slice, between_grid_comm) Given a process grid, this splits it into two grids of even size Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: old_grid The old grid to split type( ProcessGrid_t ), intent(inout) :: new_grid The new grid that we are creating integer, intent(out) :: my_color A color value indicating which set this process was split into logical, intent(out) :: split_slice True if we were able to split along slices. integer, intent(out) :: between_grid_comm A communicator for sending messages between groups. Contents None","tags":"","loc":"proc/splitprocessgrid.html"},{"title":"ConstructProcessGrid – NTPoly","text":"public interface ConstructProcessGrid Contents Module Procedures ConstructProcessGrid_full ConstructProcessGrid_onlyslice Module Procedures private subroutine ConstructProcessGrid_full(world_comm_, process_rows_, process_columns_, process_slices_, be_verbose_in) Setup the default process grid. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in) :: process_rows_ The number of grid rows. integer(kind=c_int), intent(in) :: process_columns_ The number of grid columns. integer(kind=c_int), intent(in) :: process_slices_ The number of grid slices. logical(kind=c_bool), intent(in), optional :: be_verbose_in Set true to print process grid info. private subroutine ConstructProcessGrid_onlyslice(world_comm_, process_slices_in, be_verbose_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in), optional :: process_slices_in The number of grid slices. logical(kind=c_bool), intent(in), optional :: be_verbose_in Set true to print process grid info.","tags":"","loc":"interface/constructprocessgrid.html"},{"title":"ConstructNewProcessGrid – NTPoly","text":"public interface ConstructNewProcessGrid Contents Module Procedures ConstructNewProcessGrid_full ConstructNewProcessGrid_onlyslice Module Procedures private subroutine ConstructNewProcessGrid_full(grid, world_comm_, process_rows_, process_columns_, process_slices_) Construct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in) :: process_rows_ The number of grid rows. integer(kind=c_int), intent(in) :: process_columns_ The number of grid columns. integer(kind=c_int), intent(in) :: process_slices_ The number of grid slices. private subroutine ConstructNewProcessGrid_onlyslice(grid, world_comm_, process_slices_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in), optional :: process_slices_in The number of grid slices.","tags":"","loc":"interface/constructnewprocessgrid.html"},{"title":"GetMPITripletType_r – NTPoly","text":"public function GetMPITripletType_r() result(mpi_triplet_type) Returns an MPI Derived Data Type For A Triplet.\n We statically store this derived type so that we don't have to recreate\n it every time this function is called. Thus this functional call should\n add very little overhead. Arguments None Return Value integer MPI Derived Type Contents None","tags":"","loc":"proc/getmpitriplettype_r.html"},{"title":"GetMPITripletType_c – NTPoly","text":"public function GetMPITripletType_c() result(mpi_triplet_type) Returns an MPI Derived Data Type For A Triplet.\n We statically store this derived type so that we don't have to recreate\n it every time this function is called. Thus this functional call should\n add very little overhead. Arguments None Return Value integer MPI Derived Type Contents None","tags":"","loc":"proc/getmpitriplettype_c.html"},{"title":"SetTriplet – NTPoly","text":"public interface SetTriplet Contents Module Procedures SetTriplet_r SetTriplet_c Module Procedures private subroutine SetTriplet_r(this, index_column, index_row, point_value) Set the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. real(kind=NTREAL), intent(in) :: point_value The value at that point. private subroutine SetTriplet_c(this, index_column, index_row, point_value) Set the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. complex(kind=NTCOMPLEX), intent(in) :: point_value The value at that point.","tags":"","loc":"interface/settriplet.html"},{"title":"GetTripletValues – NTPoly","text":"public interface GetTripletValues Contents Module Procedures GetTripletValues_r GetTripletValues_c Module Procedures private subroutine GetTripletValues_r(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. real(kind=NTREAL), intent(out) :: point_value Actual stored value. private subroutine GetTripletValues_c(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. complex(kind=NTCOMPLEX), intent(out) :: point_value Actual stored value.","tags":"","loc":"interface/gettripletvalues.html"},{"title":"CompareTriplets – NTPoly","text":"public interface CompareTriplets Contents Module Procedures CompareTriplets_r CompareTriplets_c Module Procedures private pure function CompareTriplets_r(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\n second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: tripA First triplet. type( Triplet_r ), intent(in) :: tripB Second triplet. Return Value logical A < B. private pure function CompareTriplets_c(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\n second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: tripA First triplet. type( Triplet_c ), intent(in) :: tripB Second triplet. Return Value logical A < B.","tags":"","loc":"interface/comparetriplets.html"},{"title":"ConvertTripletType – NTPoly","text":"public interface ConvertTripletType Contents Module Procedures ConvertTripletToReal ConvertTripletToComplex Module Procedures private subroutine ConvertTripletToReal(cin_triplet, rout_triplet) Convert a complex triplet to a real triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: cin_triplet The starting triplet type( Triplet_r ), intent(inout) :: rout_triplet Real valued triplet. private subroutine ConvertTripletToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: rin_triplet The starting triplet. type( Triplet_c ), intent(inout) :: cout_triplet Complex valued triplet.","tags":"","loc":"interface/converttriplettype.html"},{"title":"ActivateLogger – NTPoly","text":"public subroutine ActivateLogger() Activate the logger. Arguments None Contents None","tags":"","loc":"proc/activatelogger.html"},{"title":"DeactivateLogger – NTPoly","text":"public subroutine DeactivateLogger() Deactivate the logger. Arguments None Contents None","tags":"","loc":"proc/deactivatelogger.html"},{"title":"EnterSubLog – NTPoly","text":"public subroutine EnterSubLog() Call this subroutine when you enter into a section with verbose output Arguments None Contents None","tags":"","loc":"proc/entersublog.html"},{"title":"ExitSubLog – NTPoly","text":"public subroutine ExitSubLog() Call this subroutine when you exit a section with verbose output Arguments None Contents None","tags":"","loc":"proc/exitsublog.html"},{"title":"WriteHeader – NTPoly","text":"public subroutine WriteHeader(header_value) Write out a header to the log. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_value The text of the header. Contents None","tags":"","loc":"proc/writeheader.html"},{"title":"WriteCitation – NTPoly","text":"public subroutine WriteCitation(citation_list) Write out a citation element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: citation_list A list of citations, separated by a space. Contents None","tags":"","loc":"proc/writecitation.html"},{"title":"WriteListElement – NTPoly","text":"public interface WriteListElement Contents Module Procedures WriteListElement_bool WriteListElement_float WriteListElement_int WriteListElement_string Module Procedures private subroutine WriteListElement_bool(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: value A bool value to write. private subroutine WriteListElement_float(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: value A float value to write. private subroutine WriteListElement_int(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: value An integer value to write. private subroutine WriteListElement_string(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in) :: value A text value to write.","tags":"","loc":"interface/writelistelement.html"},{"title":"WriteElement – NTPoly","text":"public interface WriteElement Contents Module Procedures WriteElement_bool WriteElement_float WriteElement_int WriteElement_string Module Procedures private subroutine WriteElement_bool(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: value An integer value to write. private subroutine WriteElement_float(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: value A float value to write. private subroutine WriteElement_int(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: value An integer value to write. private subroutine WriteElement_string(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: value A text value to write.","tags":"","loc":"interface/writeelement.html"},{"title":"MatrixSigma – NTPoly","text":"public interface MatrixSigma Contents Module Procedures MatrixSigma_ps Module Procedures private subroutine MatrixSigma_ps(this, sigma_value) Compute sigma for the inversion method.\n See \\cite ozaki2001efficient for details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the sigma value of. real(kind=NTREAL), intent(out) :: sigma_value Sigma","tags":"","loc":"interface/matrixsigma.html"},{"title":"MatrixMultiply – NTPoly","text":"public interface MatrixMultiply Contents Module Procedures MatrixMultiply_ps Module Procedures private subroutine MatrixMultiply_ps(matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA matB+ beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = alpha matA matB + beta*matC real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. type( MatrixMemoryPool_p ), intent(inout), optional :: memory_pool_in A memory pool for the calculation.","tags":"","loc":"interface/matrixmultiply~2.html"},{"title":"MatrixGrandSum – NTPoly","text":"public interface MatrixGrandSum Contents Module Procedures MatrixGrandSum_psr MatrixGrandSum_psc Module Procedures private subroutine MatrixGrandSum_psr(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. real(kind=NTREAL), intent(out) :: sum The sum of all elements. private subroutine MatrixGrandSum_psc(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. complex(kind=NTCOMPLEX), intent(out) :: sum The sum of all elements.","tags":"","loc":"interface/matrixgrandsum~2.html"},{"title":"PairwiseMultiplyMatrix – NTPoly","text":"public interface PairwiseMultiplyMatrix Contents Module Procedures PairwiseMultiplyMatrix_ps Module Procedures private subroutine PairwiseMultiplyMatrix_ps(matA, matB, matC) Elementwise multiplication. C_ij = A_ij * B_ij.\n Also known as a Hadamard product. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = MatA mult MatB.","tags":"","loc":"interface/pairwisemultiplymatrix~2.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_ps Module Procedures private function MatrixNorm_ps(this) result(norm_value) Compute the norm of a distributed sparse matrix along the rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm value of the full distributed sparse matrix.","tags":"","loc":"interface/matrixnorm~3.html"},{"title":"DotMatrix – NTPoly","text":"public interface DotMatrix Contents Module Procedures DotMatrix_psr DotMatrix_psc Module Procedures private subroutine DotMatrix_psr(matA, matB, product) product = dot(Matrix A,Matrix B)\n Note that a dot product is the sum of elementwise multiplication, not\n traditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product The dot product. private subroutine DotMatrix_psc(matA, matB, product) product = dot(Matrix A,Matrix B)\n Note that a dot product is the sum of elementwise multiplication, not\n traditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product The dot product.","tags":"","loc":"interface/dotmatrix~2.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_ps Module Procedures private subroutine IncrementMatrix_ps(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY)\n This will utilize the sparse vector increment routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default= 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0).","tags":"","loc":"interface/incrementmatrix~3.html"},{"title":"ScaleMatrix – NTPoly","text":"public interface ScaleMatrix Contents Module Procedures ScaleMatrix_psr ScaleMatrix_psc Module Procedures private subroutine ScaleMatrix_psr(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. real(kind=NTREAL), intent(in) :: constant A constant scale factor. private subroutine ScaleMatrix_psc(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. complex(kind=NTCOMPLEX), intent(in) :: constant A constant scale factor.","tags":"","loc":"interface/scalematrix~2.html"},{"title":"MatrixTrace – NTPoly","text":"public interface MatrixTrace Contents Module Procedures MatrixTrace_psr Module Procedures private subroutine MatrixTrace_psr(this, trace_value) Compute the trace of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the trace of. real(kind=NTREAL), intent(out) :: trace_value The trace value of the full distributed sparse matrix.","tags":"","loc":"interface/matrixtrace.html"},{"title":"CheckMPIError – NTPoly","text":"public function CheckMPIError(this, error_description, mpi_error, immediate_cleanup_in) result(error_occurred) Routine to call to check if an MPI error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: mpi_error The error variable produced by mpi. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. Contents None","tags":"","loc":"proc/checkmpierror.html"},{"title":"CheckAllocError – NTPoly","text":"public function CheckAllocError(this, error_description, alloc_error, immediate_cleanup_in) result(error_occurred) Routine to call if an alloc error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this This the error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: alloc_error The error variable produced by alloc. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. Contents None","tags":"","loc":"proc/checkallocerror.html"},{"title":"ErrorOccurred – NTPoly","text":"public function ErrorOccurred(this) result(occurred) Check if an error has occurred or not. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error variable to check. Return Value logical True if an error has occurred, false otherwise. Contents None","tags":"","loc":"proc/erroroccurred.html"},{"title":"ConstructError – NTPoly","text":"public subroutine ConstructError(this) Default constructor for an error type. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The newly constructed error type Contents None","tags":"","loc":"proc/constructerror.html"},{"title":"SetGenericError – NTPoly","text":"public subroutine SetGenericError(this, error_description, immediate_cleanup_in) Routine to call if a generic error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Contents None","tags":"","loc":"proc/setgenericerror.html"},{"title":"PrintError – NTPoly","text":"public subroutine PrintError(this) Print out that an error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error to print out. Contents None","tags":"","loc":"proc/printerror.html"},{"title":"Cleanup – NTPoly","text":"public subroutine Cleanup(this) As a last case resort, this will print an error message and quit. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error which has caused the need to cleanup the program. Contents None","tags":"","loc":"proc/cleanup.html"},{"title":"SquareRoot – NTPoly","text":"public subroutine SquareRoot(InputMat, OutputMat, solver_parameters_in, order_in) Compute the square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). Contents None","tags":"","loc":"proc/squareroot.html"},{"title":"InverseSquareRoot – NTPoly","text":"public subroutine InverseSquareRoot(InputMat, OutputMat, solver_parameters_in, order_in) Compute the inverse square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). Contents None","tags":"","loc":"proc/inversesquareroot.html"},{"title":"AddSparseVectors – NTPoly","text":"public interface AddSparseVectors Contents Module Procedures AddSparseVectors_r AddSparseVectors_c Module Procedures private subroutine AddSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\n The values that are returned for C are only valid in the range\n (1:total_values_c). We do not do an automatic shrinking of the array\n to keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. private subroutine AddSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\n The values that are returned for C are only valid in the range\n (1:total_values_c). We do not do an automatic shrinking of the array\n to keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0.","tags":"","loc":"interface/addsparsevectors.html"},{"title":"DotSparseVectors – NTPoly","text":"public interface DotSparseVectors Contents Module Procedures DotSparseVectors_r DotSparseVectors_c Module Procedures private pure function DotSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value real(kind=NTREAL) Dot product. private pure function DotSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value complex(kind=NTCOMPLEX) Dot product.","tags":"","loc":"interface/dotsparsevectors.html"},{"title":"PairwiseMultiplyVectors – NTPoly","text":"public interface PairwiseMultiplyVectors Contents Module Procedures PairwiseMultiplyVectors_r PairwiseMultiplyVectors_c Module Procedures private subroutine PairwiseMultiplyVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c This is the total number of values in C. private subroutine PairwiseMultiplyVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c This is the total number of values in C. integer, intent(out) :: total_values_c This is the total number of values in C.","tags":"","loc":"interface/pairwisemultiplyvectors.html"},{"title":"Invert – NTPoly","text":"public subroutine Invert(Mat, InverseMat, solver_parameters_in) Compute the inverse of a matrix.\n An implementation of Hotelling's method \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to invert. type( Matrix_ps ), intent(inout) :: InverseMat The inverse of that matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/invert.html"},{"title":"PseudoInverse – NTPoly","text":"public subroutine PseudoInverse(Mat, InverseMat, solver_parameters_in) Compute the pseudoinverse of a matrix.\n An implementation of Hotelling's method \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: InverseMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents None","tags":"","loc":"proc/pseudoinverse.html"},{"title":"RootSolversModule – NTPoly","text":"A Module For Computing General Matrix Roots. Uses DataTypesModule EigenBoundsModule InverseSolversModule LoadBalancerModule LoggingModule PolynomialSolversModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule SquareRootSolversModule Contents Subroutines ComputeRoot ComputeInverseRoot Subroutines public subroutine ComputeRoot (InputMat, OutputMat, root, solver_parameters_in) Compute a general matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine ComputeInverseRoot (InputMat, OutputMat, root, solver_parameters_in) Compute a general inverse matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;-1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"module/rootsolversmodule.html"},{"title":"ChebyshevSolversModule – NTPoly","text":"A Module For Computing Matrix functions based on Chebyshev polynomials. Uses DataTypesModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute FactorizedCompute Derived Types ChebyshevPolynomial_t Interfaces public interface ConstructPolynomial private subroutine ConstructPolynomial_cheby(this, degree) Construct a Chebyshev polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree Degree of the polynomial. public interface DestructPolynomial private subroutine DestructPolynomial_cheby(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to destruct. public interface SetCoefficient private subroutine SetCoefficient_cheby(this, degree, coefficient) Set a coefficient of a Chebyshev polynomial. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value. public interface Compute private subroutine Compute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\n This method uses the standard Chebyshev Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public interface FactorizedCompute private subroutine FactorizedCompute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\n This version first factors the Chebyshev Polynomial and computes the\n function using a divide and conquer algorithm. Based on a simplified\n version of the first method in \\cite liang2003improved . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Derived Types type, public :: ChebyshevPolynomial_t A datatype that represents a Chebyshev polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/chebyshevsolversmodule.html"},{"title":"NTMPIModule – NTPoly","text":"This module wraps the MPI include statement because on certain platforms Uses mpi Contents None","tags":"","loc":"module/ntmpimodule.html"},{"title":"TrigonometrySolversModule – NTPoly","text":"A Module For Computing Trigonometric functions of a Matrix. Uses DataTypesModule EigenBoundsModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines Sine Cosine ScaleSquareTrigonometryTaylor Subroutines public subroutine Sine (InputMat, OutputMat, solver_parameters_in) Compute the sine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public subroutine Cosine (InputMat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public subroutine ScaleSquareTrigonometryTaylor (InputMat, OutputMat, solver_parameters_in) Compute trigonometric functions of a matrix using a taylor series. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"module/trigonometrysolversmodule.html"},{"title":"PMatrixMemoryPoolModule – NTPoly","text":"A module for handling scratch memory for distributed matrix multiplication. Uses PSMatrixModule MatrixMemoryPoolModule Contents Interfaces MatrixMemoryPool_p DestructMatrixMemoryPool CheckMemoryPoolValidity Derived Types MatrixMemoryPool_p Interfaces public interface MatrixMemoryPool_p private pure function ConstructMatrixMemoryPool_p(matrix) result(this) Construct Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matrix The associated distributed sparse matrix. Return Value type( MatrixMemoryPool_p ) A constructed Matrix Memory Pool object. public interface DestructMatrixMemoryPool private subroutine DestructMatrixMemoryPool_p(this) Destruct a Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this Distributed Matrix Memory Pool object to destroy. public interface CheckMemoryPoolValidity private pure function CheckMemoryPoolValidity_p(this, matrix) result(isvalid) Checks if a given distributed memory pool has been validly allocated to\n handle the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(in) :: this The memory pool to check. type( Matrix_ps ), intent(in) :: matrix The associated matrix to check against. Return Value logical True if the memory pool is valid. Derived Types type, public :: MatrixMemoryPool_p A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial type( MatrixMemoryPool_lr ), public, DIMENSION(:,:), ALLOCATABLE :: grid_r Grid of local pools. type( MatrixMemoryPool_lc ), public, DIMENSION(:,:), ALLOCATABLE :: grid_c Grid of local pools (complex). Constructor private pure function ConstructMatrixMemoryPool_p (matrix) Construct Distributed Matrix Memory Pool object.","tags":"","loc":"module/pmatrixmemorypoolmodule.html"},{"title":"TripletListModule – NTPoly","text":"A Module For Storing Lists of Triplets. Uses DataTypesModule TripletModule MatrixMarketModule iso_c_binding Contents Interfaces TripletList_r TripletList_c ConstructTripletList DestructTripletList ResizeTripletList AppendToTripletList AccumulateTripletList SetTripletAt GetTripletAt SortTripletList SortDenseTripletList SymmetrizeTripletList GetTripletListSize RedistributeTripletLists ShiftTripletList ConvertTripletListType Derived Types TripletList_r TripletList_c Functions ConstructTripletList_r ConstructTripletList_c GetTripletListSize_r GetTripletListSize_c Subroutines ConstructTripletListSup_r ConstructTripletListSup_c DestructTripletList_r DestructTripletList_c ResizeTripletList_r ResizeTripletList_c AppendToTripletList_r AppendToTripletList_c AccumulateTripletList_r AccumulateTripletList_c SetTripletAt_r SetTripletAt_c GetTripletAt_r GetTripletAt_c SortTripletList_r SortTripletList_c RedistributeTripletLists_r RedistributeTripletLists_c ShiftTripletList_r ShiftTripletList_c SortDenseTripletList_r SortDenseTripletList_c SymmetrizeTripletList_r SymmetrizeTripletList_c ConvertTripletListToReal ConvertTripletListToComplex Interfaces public interface TripletList_r public pure function ConstructTripletList_r (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_r ) The triplet list to construct. public interface TripletList_c public pure function ConstructTripletList_c (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_c ) The triplet list to construct. public interface ConstructTripletList public subroutine ConstructTripletListSup_r (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). public subroutine ConstructTripletListSup_c (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). public interface DestructTripletList public subroutine DestructTripletList_r (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. public subroutine DestructTripletList_c (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct. public interface ResizeTripletList public subroutine ResizeTripletList_r (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. public subroutine ResizeTripletList_c (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. public interface AppendToTripletList public subroutine AppendToTripletList_r (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. public subroutine AppendToTripletList_c (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append. public interface AccumulateTripletList public subroutine AccumulateTripletList_r (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to add in. public subroutine AccumulateTripletList_c (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to add in. public interface SetTripletAt public subroutine SetTripletAt_r (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. public subroutine SetTripletAt_c (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set. public interface GetTripletAt public subroutine GetTripletAt_r (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. public subroutine GetTripletAt_c (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value. public interface SortTripletList public subroutine SortTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. public subroutine SortTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. public interface SortDenseTripletList public subroutine SortDenseTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_r ), intent(out) :: sorted_list Sorted and ready to use for building matrices. public subroutine SortDenseTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_c ), intent(out) :: sorted_list Sorted and ready to use for building matrices. public interface SymmetrizeTripletList public subroutine SymmetrizeTripletList_r (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public subroutine SymmetrizeTripletList_c (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public interface GetTripletListSize public pure function GetTripletListSize_r (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. public pure function GetTripletListSize_c (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. public interface RedistributeTripletLists public subroutine RedistributeTripletLists_r (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. public subroutine RedistributeTripletLists_c (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list. public interface ShiftTripletList public subroutine ShiftTripletList_r (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public subroutine ShiftTripletList_c (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public interface ConvertTripletListType public subroutine ConvertTripletListToReal (cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. public subroutine ConvertTripletListToComplex (rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list. Derived Types type, public :: TripletList_r A data type for a list of triplets. Components Type Visibility Attributes Name Initial type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list Constructor public pure function ConstructTripletList_r (size_in) Construct a triplet list. type, public :: TripletList_c A data type for a list of triplets. Components Type Visibility Attributes Name Initial type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list Constructor public pure function ConstructTripletList_c (size_in) Construct a triplet list. Functions public pure function ConstructTripletList_r (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_r ) The triplet list to construct. public pure function ConstructTripletList_c (size_in) result(this) Construct a triplet list. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). Return Value type( TripletList_c ) The triplet list to construct. public pure function GetTripletListSize_r (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. public pure function GetTripletListSize_c (triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. Subroutines public subroutine ConstructTripletListSup_r (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). public subroutine ConstructTripletListSup_c (this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer(kind=c_int), intent(in), optional :: size_in The length of the triplet list (default=0). public subroutine DestructTripletList_r (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. public subroutine DestructTripletList_c (this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct. public subroutine ResizeTripletList_r (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. public subroutine ResizeTripletList_c (this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer(kind=c_int), intent(in) :: size Size to resize to. public subroutine AppendToTripletList_r (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. public subroutine AppendToTripletList_c (this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append. public subroutine AccumulateTripletList_r (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to add in. public subroutine AccumulateTripletList_c (this, triplet_value) (Just for a related project) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to add in. public subroutine SetTripletAt_r (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. public subroutine SetTripletAt_c (this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer(kind=c_int), intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set. public subroutine GetTripletAt_r (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. public subroutine GetTripletAt_c (this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer(kind=c_int), intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value. public subroutine SortTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. public subroutine SortTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\n Implementation is based on bucket sort. This is why it needs the number of\n matrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you don't need the final bubble sort. public subroutine RedistributeTripletLists_r (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. public subroutine RedistributeTripletLists_c (triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\n Takes in a list of triplet lists, one list for each processor. Then the\n all to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list. public subroutine ShiftTripletList_r (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public subroutine ShiftTripletList_c (triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\n Frequently, we have a triplet list that comes from the global matrix which\n we would like to shift into a local matrix. In that case, just pass\n the negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public subroutine SortDenseTripletList_r (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_r ), intent(out) :: sorted_list Sorted and ready to use for building matrices. public subroutine SortDenseTripletList_c (input_list, matrix_columns, matrix_rows, sorted_list) Sort a triplet list assuming that the matrix it corresponds to is nearly\n dense. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list The list to sort. integer, intent(in) :: matrix_columns Number of columns for the corresponding matrix. integer, intent(in) :: matrix_rows Number of rows for the corresponding matrix. type( TripletList_c ), intent(out) :: sorted_list Sorted and ready to use for building matrices. public subroutine SymmetrizeTripletList_r (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public subroutine SymmetrizeTripletList_c (triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\n symmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public subroutine ConvertTripletListToReal (cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. public subroutine ConvertTripletListToComplex (rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list.","tags":"","loc":"module/tripletlistmodule.html"},{"title":"SolverParametersModule – NTPoly","text":"A Module For Storing The Parameters For Iterative Solvers. Uses DataTypesModule LoggingModule PermutationModule Contents Variables CONVERGENCE_DIFF_CONST MAX_ITERATIONS_CONST Interfaces SolverParameters_t Derived Types SolverParameters_t Subroutines SetParametersConvergeDiff SetParametersMaxIterations SetParametersThreshold SetParametersBeVerbose SetParametersLoadBalance PrintParameters DestructSolverParameters Variables Type Visibility Attributes Name Initial real(kind=NTREAL), public, parameter :: CONVERGENCE_DIFF_CONST = 1e-6 The default convergence difference. integer, public, parameter :: MAX_ITERATIONS_CONST = 1000 The default maximum number of iterations. Interfaces public interface SolverParameters_t private pure function SolverParameters_init(converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in) result(this) Construct a data type which stores iterative solver parameters. Arguments Type Intent Optional Attributes Name real(kind=NTREAL), intent(in), optional :: converge_diff_in Converge_diff_in the difference between iterations to consider\n a calculation converged. real(kind=NTREAL), intent(in), optional :: threshold_in The zero threshold integer, intent(in), optional :: max_iterations_in The maximum number of iterations to perform logical, intent(in), optional :: be_verbose_in Whether to print during the calculation (default = False) type( Permutation_t ), intent(in), optional :: BalancePermutation_in For load balancing Return Value type( SolverParameters_t ) Derived Types type, public :: SolverParameters_t A class for passing parameters to an iterative solver. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public :: converge_diff When do we consider a calculation converged. integer, public :: max_iterations Maximum number of iterations of a solver before termination. real(kind=NTREAL), public :: threshold Threshold for sparse multiplication and addition. logical, public :: be_verbose If true, the sparse solver prints out information each loop iteration. logical, public :: do_load_balancing If true, the sparse solver will try and load balance before calculation. type( Permutation_t ), public :: BalancePermutation The permutation used for load balancing. Constructor private pure function SolverParameters_init (converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in) Construct a data type which stores iterative solver parameters. Subroutines public subroutine SetParametersConvergeDiff (this, new_value) Set the value of the convergence difference. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. public subroutine SetParametersMaxIterations (this, new_value) Set the value of the max iterations. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. integer, intent(in) :: new_value Value to set it to. public subroutine SetParametersThreshold (this, new_value) Set the value of the threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. public subroutine SetParametersBeVerbose (this, new_value) Set the value of the verbosity. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. logical, intent(in) :: new_value Value to set it to. public subroutine SetParametersLoadBalance (this, new_value) Set the value of the load balance. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. type( Permutation_t ), intent(in) :: new_value Value to set it to. public subroutine PrintParameters (this) Print out the iterative solver parameter values. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: this The parameter object. public subroutine DestructSolverParameters (this) Cleanup the solver parameters datastructure. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object.","tags":"","loc":"module/solverparametersmodule.html"},{"title":"MatrixMapsModule – NTPoly","text":"A Module For Simplfiying Per Element Operations on Matrices. Uses DataTypesModule PSMatrixModule TripletListModule TripletModule Contents Interfaces MapTripletList Subroutines MapMatrix_psr MapMatrix_psc Interfaces public interface MapTripletList private subroutine MapTripletList_r(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletList_c(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletListArray_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private subroutine MapTripletListArray_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. public function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). Subroutines public subroutine MapMatrix_psr (inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (real). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. real(kind=NTREAL), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element. public subroutine MapMatrix_psc (inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (complex). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. public function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: row The row value of an element. integer, intent(inout) :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout) :: val The actual value of an element. Return Value logical Set this to false to filter an element.","tags":"","loc":"module/matrixmapsmodule.html"},{"title":"TimerModule – NTPoly","text":"A module to do timings. Uses LoggingModule ProcessGridModule NTMPIModule Contents Subroutines RegisterTimer StartTimer StopTimer PrintTimer PrintAllTimers PrintAllTimersDistributed Subroutines public subroutine RegisterTimer (timer_name) Register a timer with the timer module.  Call this before using that timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. public subroutine StartTimer (timer_name) Start the clock running for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public subroutine StopTimer (timer_name) Stop the clock for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public subroutine PrintTimer (timer_name) Print out the elapsed time for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public subroutine PrintAllTimers () Print out the elapsed time for each timer on this process. Arguments None public subroutine PrintAllTimersDistributed () Print out the elapsed time for each timer based on the max value across\n processes. Arguments None","tags":"","loc":"module/timermodule.html"},{"title":"LoadBalancerModule – NTPoly","text":"Module for load balancing the matrix multiplication calculation. Uses PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule PermutationModule Contents Subroutines PermuteMatrix UndoPermuteMatrix Subroutines public subroutine PermuteMatrix (mat, mat_out, permutation, memorypool_in) Apply a permutation to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat The matrix to permute. type( Matrix_ps ), intent(inout) :: mat_out The permuted matrix. type( Permutation_t ), intent(in) :: permutation The permutation to apply. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use public subroutine UndoPermuteMatrix (mat, mat_out, permutation, memorypool_in) Undo a permutation applied to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat Matrix to undo permutation of. type( Matrix_ps ), intent(inout) :: mat_out Unpermuted matrix. type( Permutation_t ), intent(in) :: permutation Permutation to remove. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use.","tags":"","loc":"module/loadbalancermodule.html"},{"title":"GemmTasksModule – NTPoly","text":"This module contains some enumerators which name the tasks for Gemm. Contents Enumerations Enumerations enum, bind(c) Enumerators enumerator :: TaskRunningA = 0 Something is in progress enumerator :: LocalGatherA = 1 First we gather the blocks of A and send the size. enumerator :: SendSizeA = 2 After the local gather, we then send the size to the other tasks. enumerator :: ComposeA = 3 Next we compose those blocks of A into one big send buffer and send. enumerator :: WaitOuterA = 4 Wait for the outer index values to be gathered. enumerator :: WaitInnerA = 5 Wait for the inner index values to be gathered. enumerator :: WaitDataA = 6 Wait for the data values to be gathered, enumerator :: AdjustIndicesA = 7 Need to adjusts indices, transpose the values of A. enumerator :: CleanupA = 8 Just waiting on that last task. enumerator :: FinishedA = 9 No more work to do. enum, bind(c) Enumerators enumerator :: TaskRunningB = 0 Something is in progress enumerator :: LocalGatherB = 1 First we gather the blocks of B and send the size. enumerator :: LocalComposeB = 2 Next we compose those blocks of B into one big send buffer and send. enumerator :: SendSizeB = 3 After the local gather, we then send the size to the other tasks. enumerator :: WaitOuterB = 4 Wait for the outer index values to be gathered. enumerator :: WaitInnerB = 5 Wait for the inner index values to be gathered. enumerator :: WaitDataB = 6 Wait for the data values to be gathered, and then adjusts the indices. enumerator :: AdjustIndicesB = 7 Need to adjusts indices of B. enumerator :: CleanupB = 8 Just waiting on that last task. enumerator :: FinishedB = 9 No more work to do. enum, bind(c) Enumerators enumerator :: TaskRunningAB = 0 Something is in progress. enumerator :: AwaitingAB = 1 A and B matrix both missing, so it can't do gemm. enumerator :: GemmAB = 2 Actually call gemm and compute a block, and send its size. enumerator :: SendSizeAB = 3 After the local Gemm, we then send the size to the other tasks. enumerator :: GatherAndSumAB = 4 Start sending the data for summing. enumerator :: WaitOuterAB = 5 Wait for the outer index values to be gathered. enumerator :: WaitInnerAB = 6 Wait for the inner index values to be gathered. enumerator :: WaitDataAB = 7 Wait for the data values to be gathered. Once receive, we increment. enumerator :: LocalSumAB = 8 Sum up the gathered matrices. enumerator :: CleanupAB = 9 Just waiting on that last task. enumerator :: FinishedAB = 10 No more work to do.","tags":"","loc":"module/gemmtasksmodule.html"},{"title":"MatrixMemoryPoolModule – NTPoly","text":"A module for handling scratch memory for matrix multiplication.\n The purpose of this module is to avoid having to allocate memory on the\n heap during a matrix multiply, and to manage the underlying hash table. Uses DataTypesModule TripletModule iso_c_binding Contents Interfaces MatrixMemoryPool_lr MatrixMemoryPool_lc ConstructMatrixMemoryPool DestructMatrixMemoryPool CheckMemoryPoolValidity SetPoolSparsity Derived Types MatrixMemoryPool_lr MatrixMemoryPool_lc Interfaces public interface MatrixMemoryPool_lr private function ConstructMatrixMemoryPool_lr(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lr ),\n  TARGET The matrix to construct. public interface MatrixMemoryPool_lc private function ConstructMatrixMemoryPool_lc(columns, rows, sparsity_in) result(this) Construct Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). Return Value type( MatrixMemoryPool_lc ),\n  TARGET The matrix to construct. public interface ConstructMatrixMemoryPool private subroutine ConstructMatrixMemoryPoolSub_lr(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), TARGET :: this The matrix to construct. integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). private subroutine ConstructMatrixMemoryPoolSub_lc(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), TARGET :: this The matrix to construct. integer(kind=c_int), intent(in) :: columns Number of columns in the matrix. integer(kind=c_int), intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). public interface DestructMatrixMemoryPool private subroutine DestructMatrixMemoryPool_lr(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout) :: this The matrix being destructed. private subroutine DestructMatrixMemoryPool_lc(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout) :: this The matrix being destructed. public interface CheckMemoryPoolValidity private pure function CheckMemoryPoolValidity_lr(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\n the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. private pure function CheckMemoryPoolValidity_lc(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\n Checks if a given memory pool has been validly allocated to handle\n the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. public interface SetPoolSparsity private subroutine SetPoolSparsity_lr(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. private subroutine SetPoolSparsity_lc(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. Derived Types type, public :: MatrixMemoryPool_lr A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets. Constructor private  function ConstructMatrixMemoryPool_lr (columns, rows, sparsity_in) Construct Matrix Memory Pool object. type, public :: MatrixMemoryPool_lc A memory pool datatype that can be reused for matrix matrix multiplication.\n this is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets. Constructor private  function ConstructMatrixMemoryPool_lc (columns, rows, sparsity_in) Construct Matrix Memory Pool object.","tags":"","loc":"module/matrixmemorypoolmodule.html"},{"title":"DensityMatrixSolversModule – NTPoly","text":"A Module For Solving Quantum Chemistry Systems using Purification. Uses DataTypesModule EigenBoundsModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines PM TRS2 TRS4 HPCP EnergyDensityMatrix Subroutines public subroutine PM (Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the PM method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public subroutine TRS2 (Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS2 method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public subroutine TRS4 (Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS4 method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public subroutine HPCP (Hamiltonian, InverseSquareRoot, nel, Density, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the HPCP method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: InverseSquareRoot The inverse square root of the overlap matrix. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: Density The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public subroutine EnergyDensityMatrix (Hamiltonian, Density, EnergyDensity, threshold_in) Compute the energy-weighted density matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Hamiltonian The matrix to compute from. type( Matrix_ps ), intent(in) :: Density The density matrix. type( Matrix_ps ), intent(inout) :: EnergyDensity The energy-weighted density matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0).","tags":"","loc":"module/densitymatrixsolversmodule.html"},{"title":"MatrixReduceModule – NTPoly","text":"Module for reducing matrices across processes. Uses DataTypesModule SMatrixAlgebraModule SMatrixModule NTMPIModule Contents Interfaces ReduceAndComposeMatrixSizes ReduceAndComposeMatrixData ReduceAndComposeMatrixCleanup ReduceAndSumMatrixSizes ReduceAndSumMatrixData ReduceAndSumMatrixCleanup Derived Types ReduceHelper_t Functions TestReduceSizeRequest TestReduceInnerRequest TestReduceDataRequest Interfaces public interface ReduceAndComposeMatrixSizes private subroutine ReduceAndComposeMatrixSizes_lsr(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private subroutine ReduceAndComposeMatrixSizes_lsc(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: communicator type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper public interface ReduceAndComposeMatrixData private subroutine ReduceAndComposeMatrixData_lsr(matrix, communicator, gathered_matrix, helper) Second function to call, will gather the data and align it one matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndComposeMatrixData_lsc(matrix, communicator, gathered_matrix, helper) Second function to call, will gather the data and align it one matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public interface ReduceAndComposeMatrixCleanup private subroutine ReduceAndComposeMatrixCleanup_lsr(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndComposeMatrixCleanup_lsc(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public interface ReduceAndSumMatrixSizes private subroutine ReduceAndSumMatrixSizes_lsr(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: communicator The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private subroutine ReduceAndSumMatrixSizes_lsc(matrix, communicator, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: communicator type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper public interface ReduceAndSumMatrixData private subroutine ReduceAndSumMatrixData_lsr(matrix, gathered_matrix, communicator, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. integer, intent(inout) :: communicator The communicator to send along. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndSumMatrixData_lsc(matrix, gathered_matrix, communicator, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. integer, intent(inout) :: communicator The communicator to send along. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public interface ReduceAndSumMatrixCleanup private subroutine ReduceAndSumMatrixCleanup_lsr(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private subroutine ReduceAndSumMatrixCleanup_lsc(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. Derived Types type, public :: ReduceHelper_t A data structure to stores internal information about a reduce call. Components Type Visibility Attributes Name Initial integer, public :: comm_size Number of processors involved in this gather. integer, public :: outer_request A request object for gathering outer indices. integer, public :: inner_request A request object for gathering inner indices. integer, public :: data_request A request object for gathering data. integer, public :: error_code The error code after an MPI call. integer, public, DIMENSION(:), ALLOCATABLE :: values_per_process Number of values to gather from each process. integer, public, DIMENSION(:), ALLOCATABLE :: displacement The displacements for where those gathered values should go. Functions public function TestReduceSizeRequest (helper) result(request_completed) Test if a request for the size of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. public function TestReduceInnerRequest (helper) result(request_completed) Test if a request for the inner indices of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. public function TestReduceDataRequest (helper) result(request_completed) Test if a request for the data of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished.","tags":"","loc":"module/matrixreducemodule.html"},{"title":"SMatrixModule – NTPoly","text":"A module for handling locally stored CSR matrices. Uses DataTypesModule MatrixMarketModule TripletListModule TripletModule Contents Interfaces Matrix_lsr Matrix_lsc ConstructEmptyMatrix ConstructMatrixFromFile ConstructMatrixFromTripletList DestructMatrix CopyMatrix GetMatrixRows GetMatrixColumns ExtractMatrixRow ExtractMatrixColumn SplitMatrix SplitMatrixColumns ComposeMatrix ComposeMatrixColumns TransposeMatrix ConjugateMatrix PrintMatrix MatrixToTripletList ConvertMatrixType Derived Types Matrix_lsr Matrix_lsc Interfaces public interface Matrix_lsr private pure function ConstructEmptyMatrix_lsr(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsr ) The matrix to construct. private function ConstructMatrixFromFile_lsr(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsr ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsr(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsr ) The matrix being constructed public interface Matrix_lsc private pure function ConstructEmptyMatrix_lsc(rows, columns, zero_in) result(this) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. Return Value type( Matrix_lsc ) The matrix to construct. private function ConstructMatrixFromFile_lsc(file_name) result(this) Create a sparse matrix by reading in a matrix market file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name Name of the file. Return Value type( Matrix_lsc ) The matrix being constructed. private pure function ConstructMatrixFromTripletList_lsc(triplet_list, rows, columns) result(this) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns Return Value type( Matrix_lsc ) The matrix being constructed public interface ConstructEmptyMatrix private subroutine ConstructEmptyMatrixSub_lsr(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. private subroutine ConstructEmptyMatrixSub_lsc(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. public interface ConstructMatrixFromFile private subroutine ConstructMatrixFromFileSub_lsr(this, file_name) Subroutine wrapper for the construct from file function. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. private subroutine ConstructMatrixFromFileSub_lsc(this, file_name) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. public interface ConstructMatrixFromTripletList private subroutine ConstructMatrixFromTripletListSub_lsr(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns private subroutine ConstructMatrixFromTripletListSub_lsc(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns public interface DestructMatrix private subroutine DestructMatrix_lsr(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to free up. private subroutine DestructMatrix_lsc(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to free up. public interface CopyMatrix private subroutine CopyMatrix_lsr(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix to copy type( Matrix_lsr ), intent(inout) :: matB matB = matA private subroutine CopyMatrix_lsc(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix to copy type( Matrix_lsc ), intent(inout) :: matB matB = matA public interface GetMatrixRows private pure function GetMatrixRows_lsr(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix. Return Value integer The number of rows. private pure function GetMatrixRows_lsc(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix. Return Value integer The number of rows. public interface GetMatrixColumns private pure function GetMatrixColumns_lsr(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this Return Value integer The number of columns. private pure function GetMatrixColumns_lsc(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this Return Value integer The number of columns. public interface ExtractMatrixRow private subroutine ExtractMatrixRow_lsr(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsr ), intent(inout) :: row_out The matrix representing that row. private subroutine ExtractMatrixRow_lsc(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsc ), intent(inout) :: row_out The matrix representing that row. public interface ExtractMatrixColumn private subroutine ExtractMatrixColumn_lsr(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsr ), intent(inout) :: column_out The column representing that row. private subroutine ExtractMatrixColumn_lsc(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsc ), intent(inout) :: column_out The column representing that row. public interface SplitMatrix private subroutine SplitMatrix_lsr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsr ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private subroutine SplitMatrix_lsc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. public interface SplitMatrixColumns private subroutine SplitMatrixColumns_lsr(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsr ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. private subroutine SplitMatrixColumns_lsc(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsc ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. public interface ComposeMatrix private subroutine ComposeMatrix_lsr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(block_rows,block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsr ), intent(inout) :: out_matrix The composed matrix. private subroutine ComposeMatrix_lsc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(block_rows,block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsc ), intent(inout) :: out_matrix The composed matrix. public interface ComposeMatrixColumns private subroutine ComposeMatrixColumns_lsr(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\n the first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsr ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. private subroutine ComposeMatrixColumns_lsc(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\n the first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsc ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. public interface TransposeMatrix private subroutine TransposeMatrix_lsr(this, matT) Transpose a sparse matrix and return it in a separate matrix.\n The current implementation has you go from matrix to triplet list,\n triplet list to transposed triplet list. The triplet list must then be\n sorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be transposed. type( Matrix_lsr ), intent(inout) :: matT The input matrix transposed. private subroutine TransposeMatrix_lsc(this, matT) Transpose a sparse matrix and return it in a separate matrix.\n The current implementation has you go from matrix to triplet list,\n triplet list to transposed triplet list. The triplet list must then be\n sorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be transposed. type( Matrix_lsc ), intent(inout) :: matT The input matrix transposed. public interface ConjugateMatrix private subroutine ConjugateMatrix_lsc(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to compute the complex conjugate of. public interface PrintMatrix private subroutine PrintMatrix_lsr(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. private subroutine PrintMatrix_lsc(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. public interface MatrixToTripletList private subroutine MatrixToTripletList_lsr(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_r ), intent(inout) :: triplet_list The triplet list we created. private subroutine MatrixToTripletList_lsc(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_c ), intent(inout) :: triplet_list The triplet list we created. public interface ConvertMatrixType private subroutine ConvertMatrixType_lsrtolsc(cin, rout) Convert a complex matrix to a real matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: cin The starting matrix. type( Matrix_lsr ), intent(inout) :: rout Real valued matrix. private subroutine ConvertMatrixType_lsctolsr(rin, cout) Convert a real matrix to a complex matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: rin The starting matrix. type( Matrix_lsc ), intent(inout) :: cout The complex valued matrix. Derived Types type, public :: Matrix_lsr A datatype for storing a local, real CSR matrix. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns Constructor private pure function ConstructEmptyMatrix_lsr (rows, columns, zero_in) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. private  function ConstructMatrixFromFile_lsr (file_name) Create a sparse matrix by reading in a matrix market file. private pure function ConstructMatrixFromTripletList_lsr (triplet_list, rows, columns) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list. type, public :: Matrix_lsc A datatype for storing a local, complex CSR matrix. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices complex(kind=NTCOMPLEX), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns Constructor private pure function ConstructEmptyMatrix_lsc (rows, columns, zero_in) Create a sparse matrix with a certain number of columns\n and rows. Will allocate storage for the outer values, nothing else unless\n you set zero_in to true. private  function ConstructMatrixFromFile_lsc (file_name) Create a sparse matrix by reading in a matrix market file. private pure function ConstructMatrixFromTripletList_lsc (triplet_list, rows, columns) Construct a sparse matrix from a \\b SORTED triplet list.\n The triplet list must be sorted to efficiently fill in the matrix. This\n constructor assumes \\b you have already sorted the triplet list.","tags":"","loc":"module/smatrixmodule.html"},{"title":"DataTypesModule – NTPoly","text":"A module to store specifications for basic data types. Uses NTMPIModule iso_c_binding Contents Variables NTREAL MPINTREAL NTCOMPLEX MPINTCOMPLEX MPINTINTEGER Variables Type Visibility Attributes Name Initial integer, public, parameter :: NTREAL = C_DOUBLE The precision of floating point numbers we will use in this program. integer, public :: MPINTREAL = MPI_DOUBLE_PRECISION MPI floating point datatype with the precision we will use in this program. integer, public, parameter :: NTCOMPLEX = C_DOUBLE_COMPLEX The complex numbers we will use in this program. integer, public, parameter :: MPINTCOMPLEX = MPI_DOUBLE_COMPLEX MPI complex datatype with the precision we will use in this program. integer, public, parameter :: MPINTINTEGER = MPI_INT MPI Integer type we will use in this program.","tags":"","loc":"module/datatypesmodule.html"},{"title":"ExponentialSolversModule – NTPoly","text":"A Module For Computing Matrix Exponentials and Logarithms. Uses ChebyshevSolversModule DataTypesModule EigenBoundsModule LinearSolversModule LoadBalancerModule LoggingModule PSMatrixAlgebraModule PMatrixMemoryPoolModule PSMatrixModule RootSolversModule SolverParametersModule SquareRootSolversModule Contents Subroutines ComputeExponential ComputeExponentialPade ComputeExponentialTaylor ComputeLogarithm ComputeLogarithmTaylor Subroutines public subroutine ComputeExponential (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine ComputeExponentialPade (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a pade approximation.\n Be warned, the pade method can result in a lot of intermediate fill. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine ComputeExponentialTaylor (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a taylor series expansion.\n This is only really useful if you have a very small spectrum, because\n quite a bit of scaling is required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine ComputeLogarithm (InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine ComputeLogarithmTaylor (InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix using a taylor series expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/exponentialsolversmodule.html"},{"title":"PermutationModule – NTPoly","text":"Module for load balancing the matrix multiplication calculation. Uses DataTypesModule ProcessGridModule NTMPIModule Contents Derived Types Permutation_t Subroutines ConstructDefaultPermutation ConstructReversePermutation ConstructRandomPermutation ConstructLimitedRandomPermutation DestructPermutation Derived Types type, public :: Permutation_t A data structure for storing permutations. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: index_lookup For each row/column, what index does it correspond to in the\n unperturbed matrix. integer, public, DIMENSION(:), ALLOCATABLE :: reverse_index_lookup For each row/column in the unperturbed, what index does it correspond to\n in this matrix. Subroutines public subroutine ConstructDefaultPermutation (this, matrix_dimension) Constructs a permutation that preserves the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: matrix_dimension The dimension of the matrix. public subroutine ConstructReversePermutation (this, matrix_dimension) Constructs a permutation that reverses the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. public subroutine ConstructRandomPermutation (this, matrix_dimension, process_grid_in) Constructs a permutation that has a random order.\n Implements Knuth shuffle. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\n This is to synchronize random number across processes. public subroutine ConstructLimitedRandomPermutation (this, actual_matrix_dimension, logical_matrix_dimension, process_grid_in) Constructs a permutation that has a random order, but there is no\n permutation from beyond the actual matrix dimension. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: actual_matrix_dimension Actual size of the matrix. integer, intent(in) :: logical_matrix_dimension Padded size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\n This is to synchronize random number across processes. public subroutine DestructPermutation (this) Destruct a permutation object. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to destruct.","tags":"","loc":"module/permutationmodule.html"},{"title":"LinearSolversModule – NTPoly","text":"Solve the matrix equation AX = B Uses DataTypesModule DMatrixModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines CGSolver Subroutines public subroutine CGSolver (AMat, XMat, BMat, solver_parameters_in) Solve the matrix equation AX = B using the conjugate gradient method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: XMat The solved for matrix X. type( Matrix_ps ), intent(in) :: BMat The right hand side. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/linearsolversmodule.html"},{"title":"HermiteSolversModule – NTPoly","text":"A module for computing matrix functions based on Hermite polynomials. Uses DataTypesModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute Derived Types HermitePolynomial_t Interfaces public interface ConstructPolynomial private subroutine ConstructPolynomial_horner(this, degree) Construct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial. public interface DestructPolynomial private subroutine DestructPolynomial_horner(this) Destruct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to destruct. public interface SetCoefficient private subroutine SetCoefficient_horner(this, degree, coefficient) Set a coefficient of a Hermite polynomial. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree The degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value to set. public interface Compute private subroutine Compute_horner(InputMat, OutputMat, poly, solver_parameters_in) Compute The Hermite Polynomial of the matrix.\n This method uses the standard Hermite Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix. type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( HermitePolynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Derived Types type, public :: HermitePolynomial_t A datatype that represents a Hermite polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/hermitesolversmodule.html"},{"title":"SMatrixAlgebraModule – NTPoly","text":"A module for performing linear algebra using sparse matrices. Uses DataTypesModule DMatrixModule MatrixMemoryPoolModule SMatrixModule SVectorModule TripletListModule Contents Interfaces ScaleMatrix IncrementMatrix DotMatrix PairwiseMultiplyMatrix MatrixMultiply MatrixColumnNorm MatrixNorm MatrixGrandSum Interfaces public interface ScaleMatrix private subroutine ScaleMatrix_lsr(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private subroutine ScaleMatrix_lsc(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private subroutine ScaleMatrix_lsc_c(matA, constant) Will scale a sparse matrix by a constant.\n Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. complex(kind=NTCOMPLEX), intent(in) :: constant Constant scale factor. public interface IncrementMatrix private subroutine IncrementMatrix_lsr(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\n This will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default=1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0). private subroutine IncrementMatrix_lsc(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\n This will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default=1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0). public interface DotMatrix private subroutine DotMatrix_lsr(matA, matB, product) Product = sum(MatA[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product Dot product. private subroutine DotMatrix_lsc(matA, matB, product) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product Dot product. public interface PairwiseMultiplyMatrix private subroutine PairwiseMultiplyMatrix_lsr(matA, matB, matC) Pairwise Multiply two matrices.\n This will utilize the sparse vector pairwise multiply routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = MatA mult MatB. private subroutine PairwiseMultiplyMatrix_lsc(matA, matB, matC) Pairwise Multiply two matrices.\n This will utilize the sparse vector pairwise routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = MatA mult MatB. public interface MatrixMultiply private subroutine GemmMatrix_lsr(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lr ), intent(inout), optional TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. private subroutine GemmMatrix_lsc(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lc ), intent(inout), optional TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. public interface MatrixColumnNorm private subroutine MatrixColumnNorm_lsr(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. private subroutine MatrixColumnNorm_lsc(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. public interface MatrixNorm private pure function MatrixNorm_lsr(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private pure function MatrixNorm_lsc(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. public interface MatrixGrandSum private subroutine MatrixGrandSum_lsr(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to sum real(kind=NTREAL), intent(out) :: sum_value The sum of the matrix elements private subroutine MatrixGrandSum_lsc(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to sum complex(kind=NTCOMPLEX), intent(out) :: sum_value The sum of the matrix elements","tags":"","loc":"module/smatrixalgebramodule.html"},{"title":"EigenBoundsModule – NTPoly","text":"A module for computing estimates of the bounds of a matrix's spectrum. Uses DataTypesModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule TripletListModule TripletModule NTMPIModule Contents Subroutines GershgorinBounds PowerBounds Subroutines public subroutine GershgorinBounds (this, min_value, max_value) Compute a bounds on the minimum and maximum eigenvalue of a matrix.\n Uses Gershgorin's theorem. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: min_value A lower bound on the eigenspectrum. real(kind=NTREAL), intent(out) :: max_value An uppder bound on the eigenspectrum. public subroutine PowerBounds (this, max_value, solver_parameters_in) Compute a bounds on the maximum eigenvalue of a matrix.\n Uses The Power Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: max_value An upper bound on the eigenspectrum. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The parameters for this calculation.","tags":"","loc":"module/eigenboundsmodule.html"},{"title":"PolynomialSolversModule – NTPoly","text":"A Module For Computing General Matrix Polynomials. Uses DataTypesModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute FactorizedCompute Derived Types Polynomial_t Interfaces public interface ConstructPolynomial private subroutine ConstructPolynomial_stand(this, degree) Construct a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial. public interface DestructPolynomial private subroutine DestructPolynomial_stand(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to destruct. public interface SetCoefficient private subroutine SetCoefficient_stand(this, degree, coefficient) Set coefficient of a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value. public interface Compute private subroutine Compute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using Horner's Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public interface FactorizedCompute private subroutine FactorizedCompute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using Paterson and Stockmeyer's method.\n This method first factors the polynomial to reduce the number of\n matrix multiplies required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly The polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Derived Types type, public :: Polynomial_t A datatype that represents a polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/polynomialsolversmodule.html"},{"title":"DMatrixModule – NTPoly","text":"This module allows one to convert a sparse matrix to a dense matrix. It also Uses DataTypesModule SMatrixModule TripletListModule TripletModule Contents Interfaces Matrix_ldr Matrix_ldc ConstructEmptyMatrix ConstructMatrixDFromS ConstructMatrixSFromD CopyMatrix DestructMatrix SplitMatrix ComposeMatrix MatrixNorm IncrementMatrix MultiplyMatrix TransposeMatrix Derived Types Matrix_ldr Matrix_ldc Interfaces public interface Matrix_ldr private pure function ConstructEmptyMatrix_ldr(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldr ) The matrix to construct. public interface Matrix_ldc private pure function ConstructEmptyMatrix_ldc(rows, columns) result(this) Construct an empty dense matrix with a set number of rows and columns Arguments Type Intent Optional Attributes Name integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix. Return Value type( Matrix_ldc ) The matrix to construct. public interface ConstructEmptyMatrix private subroutine ConstructEmptyMatrixSup_ldr(this, rows, columns) A subroutine wrapper for the empty constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to construct integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix private subroutine ConstructEmptyMatrixSup_ldc(this, rows, columns) A subroutine style wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of rows of the matrix. integer, intent(in) :: columns The number of columns o the matrix. public interface ConstructMatrixDFromS private subroutine ConstructMatrixDFromS_ldr(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldr ), intent(inout) :: dense_matrix Output. Must be preallocated. private subroutine ConstructMatrixDFromS_ldc(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldc ), intent(inout) :: dense_matrix Dense matrix output. Must be preallocated. public interface ConstructMatrixSFromD private subroutine ConstructMatrixSFromD_ldr(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: dense_matrix Matrix to convert. type( Matrix_lsr ), intent(inout) :: sparse_matrix Output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. private subroutine ConstructMatrixSFromD_ldc(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: dense_matrix The matrix to convert. type( Matrix_lsc ), intent(inout) :: sparse_matrix The sparse output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. public interface CopyMatrix private subroutine CopyMatrix_ldr(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA The matrix to copy. type( Matrix_ldr ), intent(inout) :: matB matB = matA private subroutine CopyMatrix_ldc(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to copy. type( Matrix_ldc ), intent(inout) :: matB matB = matA public interface DestructMatrix private subroutine DestructMatrix_ldr(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to delete. private subroutine DestructMatrix_ldc(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this This the matrix to delete. public interface SplitMatrix private subroutine SplitMatrix_ldr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldr ), intent(inout), DIMENSION(:,:) :: split_array A block_columns x block_rows array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private subroutine SplitMatrix_ldc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional DIMENSION(:) :: block_size_column_in Specifies the size of the columns. public interface ComposeMatrix private subroutine ComposeMatrix_ldr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldr ), intent(inout) :: out_matrix The composed matrix. private subroutine ComposeMatrix_ldc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\n to another. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldc ), intent(inout) :: out_matrix The composed matrix. public interface MatrixNorm private function MatrixNorm_ldr(this) result(norm) Compute the norm of a dense matrix.\n Computes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private function MatrixNorm_ldc(this) result(norm) Compute the norm of a dense matrix.\n Computes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. public interface IncrementMatrix private subroutine IncrementMatrix_ldr(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA is added type( Matrix_ldr ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. private subroutine IncrementMatrix_ldc(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA MatA is added type( Matrix_ldc ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. public interface MultiplyMatrix private subroutine MultiplyMatrix_ldr(MatA, MatB, MatC) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA The first matrix. type( Matrix_ldr ), intent(in) :: MatB The second matrix. type( Matrix_ldr ), intent(inout) :: MatC MatC = MatA*MatB. private subroutine MultiplyMatrix_ldc(MatA, MatB, MatC) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The first matrix. type( Matrix_ldc ), intent(in) :: MatB The second matrix. type( Matrix_ldc ), intent(inout) :: MatC MatC = MatA*MatB. public interface TransposeMatrix private subroutine TransposeMatrix_ldr(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA matA the matrix to transpose. type( Matrix_ldr ), intent(inout) :: matAT matAT = matA&#94;T. private subroutine TransposeMatrix_ldc(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to transpose. type( Matrix_ldc ), intent(inout) :: matAT matAT = matA&#94;T. Derived Types type, public :: Matrix_ldr A datatype for storing a dense matrix. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns. Constructor private pure function ConstructEmptyMatrix_ldr (rows, columns) Construct an empty dense matrix with a set number of rows and columns type, public :: Matrix_ldc A datatype for storing a dense matrix. Components Type Visibility Attributes Name Initial complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns. Constructor private pure function ConstructEmptyMatrix_ldc (rows, columns) Construct an empty dense matrix with a set number of rows and columns","tags":"","loc":"module/dmatrixmodule.html"},{"title":"MatrixMarketModule – NTPoly","text":"This module contains helpers for processing matrix market files. Contents Enumerations Functions ParseMMHeader Enumerations enum, bind(c) Enumerators enumerator :: MM_COORDINATE = 1 Sparse coordinate file. enumerator :: MM_ARRAY = 2 Dense array file. enumerator :: MM_REAL = 1 Real data being read in. enumerator :: MM_INTEGER = 2 Integer data being read in. enumerator :: MM_COMPLEX = 3 Complex numbers being read in. enumerator :: MM_PATTERN = 4 Just a pattern of non zeros. enumerator :: MM_GENERAL = 1 File lacks symmetry. enumerator :: MM_SYMMETRIC = 2 File is symmetric enumerator :: MM_SKEW_SYMMETRIC = 3 File is skew symmetric. enumerator :: MM_HERMITIAN = 4 File is hermitian. Functions public function ParseMMHeader (line, sparsity_type, data_type, pattern_type) result(no_error) Parse a matrix market header. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line String to parse. integer, intent(out) :: sparsity_type If coordinate or array type. integer, intent(out) :: data_type If real, integer, complex, pattern. integer, intent(out) :: pattern_type If general, symmetric, skew_symmetric, hermitian. Return Value logical True if no errors.","tags":"","loc":"module/matrixmarketmodule.html"},{"title":"PSMatrixModule – NTPoly","text":"A Module For Performing Distributed Sparse Matrix Operations. Uses DataTypesModule ErrorModule LoggingModule MatrixMarketModule PermutationModule ProcessGridModule MatrixReduceModule SMatrixModule TimerModule TripletModule TripletListModule NTMPIModule iso_c_binding Contents Interfaces ConstructEmptyMatrix DestructMatrix CopyMatrix ConstructMatrixFromMatrixMarket ConstructMatrixFromBinary WriteMatrixToMatrixMarket WriteMatrixToBinary FillMatrixFromTripletList FillMatrixIdentity FillMatrixPermutation GetMatrixActualDimension GetMatrixLogicalDimension GetMatrixTripletList GetMatrixBlock PrintMatrix PrintMatrixInformation GetMatrixLoadBalance GetMatrixSize FilterMatrix MergeMatrixLocalBlocks SplitMatrixToLocalBlocks TransposeMatrix ConjugateMatrix CommSplitMatrix GatherMatrixToProcess Derived Types Matrix_ps Subroutines SetMatrixProcessGrid GetMatrixSlice ConvertMatrixToReal ConvertMatrixToComplex ResizeMatrix Interfaces public interface ConstructEmptyMatrix private subroutine ConstructEmptyMatrix_ps(this, matrix_dim_, process_grid_in, is_complex_in) Construct an empty sparse, distributed, matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. integer, intent(in) :: matrix_dim_ The dimension of the full matrix. type( ProcessGrid_t ), intent(in), optional TARGET :: process_grid_in A process grid to host the matrix. logical, intent(in), optional :: is_complex_in True if you want to use complex numbers. private subroutine ConstructEmptyMatrix_ps_cp(this, reference_matrix) Construct an empty sparse, distributed, matrix using another matrix\n to determine the parameters. Note that no data is copied, the matrix\n will be empty. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. type( Matrix_ps ), intent(in) :: reference_matrix The reference matrix to take parameters from. public interface DestructMatrix private subroutine DestructMatrix_ps(this) Destruct a distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to destruct. public interface CopyMatrix private subroutine CopyMatrix_ps(matA, matB) Copy a distributed sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA The matrix to copy. type( Matrix_ps ), intent(inout) :: matB matB = matA. public interface ConstructMatrixFromMatrixMarket private subroutine ConstructMatrixFromMatrixMarket_ps(this, file_name, process_grid_in) Construct distributed sparse matrix from a matrix market file in parallel.\n Read \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on. public interface ConstructMatrixFromBinary private subroutine ConstructMatrixFromBinary_ps(this, file_name, process_grid_in) Construct a distributed sparse matrix from a binary file in parallel.\n Faster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on. public interface WriteMatrixToMatrixMarket private subroutine WriteMatrixToMatrixMarket_ps(this, file_name) Write a distributed sparse matrix to a matrix market file.\n Read \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to. public interface WriteMatrixToBinary private subroutine WriteMatrixToBinary_ps(this, file_name) Save a distributed sparse matrix to a binary file.\n Faster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to. public interface FillMatrixFromTripletList private subroutine FillMatrixFromTripletList_psr(this, triplet_list, preduplicated_in) This routine fills in a matrix based on local triplet lists. Each process\n should pass in triplet lists with global coordinates. It doesn't matter\n where each triplet is stored, as long as global coordinates are given. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to fill. type( TripletList_r ) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. private subroutine FillMatrixFromTripletList_psc(this, triplet_list, preduplicated_in) This routine fills in a matrix based on local triplet lists. Each process\n should pass in triplet lists with global coordinates. It doesn't matter\n where each triplet is stored, as long as global coordinates are given. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to fill. type( TripletList_c ) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. public interface FillMatrixIdentity private subroutine FillMatrixIdentity_ps(this) Fill in the values of a distributed matrix with the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. public interface FillMatrixPermutation private subroutine FillMatrixPermutation_ps(this, permutation_vector, permute_rows_in) Fill in the values of a distributed matrix with a permutation.\n If you don't specify permuterows, will default to permuting rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. integer, intent(in), DIMENSION(:) :: permutation_vector Describes for each row/column, where it goes. logical, intent(in), optional :: permute_rows_in If true permute rows, false permute columns. public interface GetMatrixActualDimension private pure function GetMatrixActualDimension_ps(this) result(DIMENSION) Get the actual dimension of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix public interface GetMatrixLogicalDimension private pure function GetMatrixLogicalDimension_ps(this) result(DIMENSION) Get the logical dimension of the matrix.\n Includes padding. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix public interface GetMatrixTripletList private subroutine GetMatrixTripletList_psr(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. private subroutine GetMatrixTripletList_psc(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. public interface GetMatrixBlock private subroutine GetMatrixBlock_psr(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\n defined by the row/column start/end values.\n This is slower than GetMatrixTripletList, because communication is required\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. integer :: start_row The starting row for data to store on this process. integer :: end_row The ending row for data to store on this process. integer :: start_column The starting col for data to store on this process integer :: end_column The ending col for data to store on this process private subroutine GetMatrixBlock_psc(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\n defined by the row/column start/end values.\n This is slower than GetMatrixTripletList, because communication is required\n Data is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. integer :: start_row The starting row for data to store on this process. integer :: end_row The ending row for data to store on this process. integer :: start_column The starting col for data to store on this process integer :: end_column The ending col for data to store on this process public interface PrintMatrix private subroutine PrintMatrix_ps(this, file_name_in) Print out a distributed sparse matrix.\n This is a serial print routine, and should probably only be used for debug\n purposes. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to print. character(len=*), intent(in), optional :: file_name_in Optionally, you can pass a file to print to instead of the console. public interface PrintMatrixInformation private subroutine PrintMatrixInformation_ps(this) Print out information about a distributed sparse matrix.\n Sparsity, and load balancing information. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this This the matrix to print information about. public interface GetMatrixLoadBalance private subroutine GetMatrixLoadBalance_ps(this, min_size, max_size) Get a measure of how load balanced this matrix is. For each process, the\n number of non-zero entries is calculated. Then, this function returns\n the max and min of those values. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the measure on. integer, intent(out) :: min_size The minimum entries contained on a single process. integer, intent(out) :: max_size The maximum entries contained on a single process. public interface GetMatrixSize private function GetMatrixSize_ps(this) result(total_size) Get the total number of non-zero entries in the distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to calculate the number of non-zero entries of. Return Value integer(kind=c_long) The number of non-zero entries in the matrix. public interface FilterMatrix private subroutine FilterMatrix_ps(this, threshold) A utility routine that filters a sparse matrix.\n All (absolute) values below the threshold are set to zero. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to filter. real(kind=NTREAL), intent(in) :: threshold Threshold (absolute) values below this are filtered public interface MergeMatrixLocalBlocks private subroutine MergeMatrixLocalBlocks_psr(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsr ), intent(inout) :: merged_matrix The merged matrix. private subroutine MergeMatrixLocalBlocks_psc(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsc ), intent(inout) :: merged_matrix The merged matrix. public interface SplitMatrixToLocalBlocks private subroutine SplitMatrixToLocalBlocks_psr(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsr ), intent(in) :: matrix_to_split The matrix to split up. private subroutine SplitMatrixToLocalBlocks_psc(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsc ), intent(in) :: matrix_to_split The matrix to split up. public interface TransposeMatrix private subroutine TransposeMatrix_ps(AMat, TransMat) Transpose a sparse matrix. Note that this is a pure transpose, there is\n no complex conjugate performed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix to transpose. type( Matrix_ps ), intent(out) :: TransMat TransMat = A&#94;T . public interface ConjugateMatrix private subroutine ConjugateMatrix_ps(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to compute the complex conjugate of. public interface CommSplitMatrix private subroutine CommSplitMatrix_ps(this, split_mat, my_color, split_slice) Split the current communicator, and give each group a complete copy of this Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to split. type( Matrix_ps ), intent(inout) :: split_mat A copy of the matrix hosted on a small process grid. integer, intent(out) :: my_color Distinguishes between the two groups. logical, intent(out) :: split_slice If we split along the slice direction, this is True public interface GatherMatrixToProcess private subroutine GatherMatrixToProcess_psr(this, local_mat, proc_id) This subroutine gathers the entire matrix into a local matrix on the Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: proc_id Which process to gather on. private subroutine GatherMatrixToProcess_psc(this, local_mat, proc_id) This subroutine gathers the entire matrix into a local matrix on the Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: proc_id Which process to gather on. Derived Types type, public :: Matrix_ps A datatype for a distributed blocked CSR matrix. Components Type Visibility Attributes Name Initial integer, public :: logical_matrix_dimension Number of matrix rows/columns for full matrix, scaled for process grid. integer, public :: actual_matrix_dimension Number of matrix rows/columns for the full matrix, unscaled. type( Matrix_lsr ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_r A 2D array of local CSR matrices. type( Matrix_lsc ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_c A 2D array of local CSC matrices. integer, public :: start_column first column stored locally. integer, public :: end_column last column stored locally  is less than this. integer, public :: start_row first row stored locally. integer, public :: end_row last row stored locally is less than this. integer, public :: local_columns number of local columns. integer, public :: local_rows number of local rows. type( ProcessGrid_t ), public, POINTER :: process_grid process grid to operate on logical, public :: is_complex true if the matrix data is true. Subroutines public subroutine SetMatrixProcessGrid (this, grid) When you want to change the process grid of a matrix, you can call\n this routine with the new process grid value. Data will be automatically\n redistributed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to set the grid of. type( ProcessGrid_t ), intent(in) :: grid The grid to set it to. public subroutine GetMatrixSlice (this, submatrix, start_row, end_row, start_column, end_column) Copy an arbitrary slice from a matrix into a new smaller matrix.\n NTPoly only works with square matrices, so if the number of rows and\n columns is different the matrix is resized to the maximum size. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( Matrix_ps ), intent(inout) :: submatrix The slice to fill. integer :: start_row The starting row to include in this matrix. integer :: end_row The ending row to include in this matrix. integer :: start_column The starting column to include in this matrix. integer :: end_column The last column to include in this matrix. public subroutine ConvertMatrixToReal (in, out) Converts the current matrix to a real type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Real version of the matrix. public subroutine ConvertMatrixToComplex (in, out) Converts the current matrix to a complex type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Complex version of the matrix. public subroutine ResizeMatrix (this, new_size) Change the size of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to resize. integer, intent(in) :: new_size The new size of the matrix.","tags":"","loc":"module/psmatrixmodule.html"},{"title":"SignSolversModule – NTPoly","text":"A Module For Computing The Matrix Sign Function. Uses DataTypesModule EigenBoundsModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines SignFunction PolarDecomposition Subroutines public subroutine SignFunction (Mat, SignMat, solver_parameters_in) Computes the matrix sign function. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The input matrix. type( Matrix_ps ), intent(inout) :: SignMat The sign of Mat. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public subroutine PolarDecomposition (Mat, Umat, Hmat, solver_parameters_in) Computes the polar decomposition of a matrix Mat = U*H. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The input matrix. type( Matrix_ps ), intent(inout) :: Umat The unitary polar factor. type( Matrix_ps ), intent(inout), optional :: Hmat The hermitian matrix factor. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"module/signsolversmodule.html"},{"title":"GeometryOptimizationModule – NTPoly","text":"A Module For Geometry Optimization Uses DataTypesModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule SquareRootSolversModule Contents Subroutines PurificationExtrapolate LowdinExtrapolate Subroutines public subroutine PurificationExtrapolate (PreviousDensity, Overlap, nel, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\n Based on the purification algorithm in \\cite niklasson2010trace . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity Previous density to extrapolate from. type( Matrix_ps ), intent(in) :: Overlap The overlap matrix of the new geometry. integer, intent(in) :: nel The number of electrons. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine LowdinExtrapolate (PreviousDensity, OldOverlap, NewOverlap, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\n Based on the lowdin algorithm in \\cite exner2002comparison . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity THe previous density to extrapolate from. type( Matrix_ps ), intent(in) :: OldOverlap The old overlap matrix from the previous geometry. type( Matrix_ps ), intent(in) :: NewOverlap The new overlap matrix from the current geometry. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/geometryoptimizationmodule.html"},{"title":"ProcessGridModule – NTPoly","text":"A module to manage the process grid. Uses ErrorModule LoggingModule NTMPIModule iso_c_binding omp_lib Contents Variables global_grid Interfaces ConstructProcessGrid ConstructNewProcessGrid Derived Types ProcessGrid_t Functions IsRoot GetMySlice GetMyColumn GetMyRow Subroutines CopyProcessGrid DestructProcessGrid SplitProcessGrid Variables Type Visibility Attributes Name Initial type( ProcessGrid_t ), public, TARGET :: global_grid The default process grid. Interfaces public interface ConstructProcessGrid private subroutine ConstructProcessGrid_full(world_comm_, process_rows_, process_columns_, process_slices_, be_verbose_in) Setup the default process grid. Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in) :: process_rows_ The number of grid rows. integer(kind=c_int), intent(in) :: process_columns_ The number of grid columns. integer(kind=c_int), intent(in) :: process_slices_ The number of grid slices. logical(kind=c_bool), intent(in), optional :: be_verbose_in Set true to print process grid info. private subroutine ConstructProcessGrid_onlyslice(world_comm_, process_slices_in, be_verbose_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in), optional :: process_slices_in The number of grid slices. logical(kind=c_bool), intent(in), optional :: be_verbose_in Set true to print process grid info. public interface ConstructNewProcessGrid private subroutine ConstructNewProcessGrid_full(grid, world_comm_, process_rows_, process_columns_, process_slices_) Construct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in) :: process_rows_ The number of grid rows. integer(kind=c_int), intent(in) :: process_columns_ The number of grid columns. integer(kind=c_int), intent(in) :: process_slices_ The number of grid slices. private subroutine ConstructNewProcessGrid_onlyslice(grid, world_comm_, process_slices_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer(kind=c_int), intent(in) :: world_comm_ A communicator that every process in the grid is a part of. integer(kind=c_int), intent(in), optional :: process_slices_in The number of grid slices. Derived Types type, public :: ProcessGrid_t A datatype which stores a process grid and all its communicators. Components Type Visibility Attributes Name Initial integer, public :: total_processors total processors in the grid. integer, public :: num_process_rows number of rows in the grid. integer, public :: num_process_columns number of columns in the grid. integer, public :: num_process_slices number of 2D slices in the grid. integer, public :: slice_size the size of a 2D slice. integer, public :: my_slice which slice is the current process in. integer, public :: my_row which row is the current process in. integer, public :: my_column which column is the current process in. integer, public :: global_rank current process's rank amongst processes. integer, public :: within_slice_rank rank for within slice communication. integer, public :: between_slice_rank rank for between slice communication. integer, public :: column_rank rank for within column communication. integer, public :: row_rank rank for within row communication. integer, public :: global_comm communicator with every other process. integer, public :: row_comm communicator within a row. integer, public :: column_comm communicator within a column. integer, public :: within_slice_comm communicator within a slice. integer, public :: between_slice_comm communicator between slices. integer, public :: grid_error stores errors from MPI calls. integer, public :: RootID = 0 Which rank is root? integer, public :: block_multiplier Block scaling factor. integer, public :: number_of_blocks_columns number of column blocks. integer, public :: number_of_blocks_rows number of row blocks. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_row_comm blocked communicator within a row. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_column_comm blocked communicator within a column. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_within_slice_comm blocked communicator within a slice. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_between_slice_comm blocked communicator between slices. Functions public function IsRoot (grid) result(is_root) Check if the current process is the root process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: grid The process grid. Return Value logical True if the current process is root. public function GetMySlice (grid) result(return_val) Get the slice of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer Slice number of the current process. public function GetMyColumn (grid) result(return_val) Get the column of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The column number of the current process. public function GetMyRow (grid) result(return_val) Get the row of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The row number of the current process. Subroutines public subroutine CopyProcessGrid (old_grid, new_grid) Copy a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: old_grid The grid to copy. type( ProcessGrid_t ), intent(inout) :: new_grid New_grid = old_grid public subroutine DestructProcessGrid (grid_in) Destruct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout), optional :: grid_in The grid to destruct. If none specified this destroys the global grid. public subroutine SplitProcessGrid (old_grid, new_grid, my_color, split_slice, between_grid_comm) Given a process grid, this splits it into two grids of even size Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: old_grid The old grid to split type( ProcessGrid_t ), intent(inout) :: new_grid The new grid that we are creating integer, intent(out) :: my_color A color value indicating which set this process was split into logical, intent(out) :: split_slice True if we were able to split along slices. integer, intent(out) :: between_grid_comm A communicator for sending messages between groups.","tags":"","loc":"module/processgridmodule.html"},{"title":"TripletModule – NTPoly","text":"A Module For Storing Triplets of Integer, Integer, Value. Uses DataTypesModule NTMPIModule iso_c_binding Contents Interfaces SetTriplet GetTripletValues CompareTriplets ConvertTripletType Derived Types Triplet_r Triplet_c Functions GetMPITripletType_r GetMPITripletType_c Interfaces public interface SetTriplet private subroutine SetTriplet_r(this, index_column, index_row, point_value) Set the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. real(kind=NTREAL), intent(in) :: point_value The value at that point. private subroutine SetTriplet_c(this, index_column, index_row, point_value) Set the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. complex(kind=NTCOMPLEX), intent(in) :: point_value The value at that point. public interface GetTripletValues private subroutine GetTripletValues_r(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. real(kind=NTREAL), intent(out) :: point_value Actual stored value. private subroutine GetTripletValues_c(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. complex(kind=NTCOMPLEX), intent(out) :: point_value Actual stored value. public interface CompareTriplets private pure function CompareTriplets_r(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\n second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: tripA First triplet. type( Triplet_r ), intent(in) :: tripB Second triplet. Return Value logical A < B. private pure function CompareTriplets_c(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\n second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: tripA First triplet. type( Triplet_c ), intent(in) :: tripB Second triplet. Return Value logical A < B. public interface ConvertTripletType private subroutine ConvertTripletToReal(cin_triplet, rout_triplet) Convert a complex triplet to a real triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: cin_triplet The starting triplet type( Triplet_r ), intent(inout) :: rout_triplet Real valued triplet. private subroutine ConvertTripletToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: rin_triplet The starting triplet. type( Triplet_c ), intent(inout) :: cout_triplet Complex valued triplet. Derived Types type, public :: Triplet_r A data type for a triplet of integer, integer, double.\n As this is related to matrix multiplication, the referencing indices are\n rows and columns. Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index_column column value. integer(kind=c_int), public :: index_row row value. real(kind=NTREAL), public :: point_value actual value at those indices. type, public :: Triplet_c A data type for a triplet of integer, integer, complex.\n As this is related to matrix multiplication, the referencing indices are\n rows and columns. Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: index_column column value. integer(kind=c_int), public :: index_row row value. complex(kind=NTCOMPLEX), public :: point_value actual value at those indices. Functions public function GetMPITripletType_r () result(mpi_triplet_type) Returns an MPI Derived Data Type For A Triplet.\n We statically store this derived type so that we don't have to recreate\n it every time this function is called. Thus this functional call should\n add very little overhead. Arguments None Return Value integer MPI Derived Type public function GetMPITripletType_c () result(mpi_triplet_type) Returns an MPI Derived Data Type For A Triplet.\n We statically store this derived type so that we don't have to recreate\n it every time this function is called. Thus this functional call should\n add very little overhead. Arguments None Return Value integer MPI Derived Type","tags":"","loc":"module/tripletmodule.html"},{"title":"LoggingModule – NTPoly","text":"A module for writing data to the log file. Uses DataTypesModule Contents Interfaces WriteListElement WriteElement Subroutines ActivateLogger DeactivateLogger EnterSubLog ExitSubLog WriteHeader WriteCitation Interfaces public interface WriteListElement private subroutine WriteListElement_bool(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: value A bool value to write. private subroutine WriteListElement_float(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: value A float value to write. private subroutine WriteListElement_int(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: value An integer value to write. private subroutine WriteListElement_string(key, value) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in) :: value A text value to write. public interface WriteElement private subroutine WriteElement_bool(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: value An integer value to write. private subroutine WriteElement_float(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: value A float value to write. private subroutine WriteElement_int(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: value An integer value to write. private subroutine WriteElement_string(key, value) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: value A text value to write. Subroutines public subroutine ActivateLogger () Activate the logger. Arguments None public subroutine DeactivateLogger () Deactivate the logger. Arguments None public subroutine EnterSubLog () Call this subroutine when you enter into a section with verbose output Arguments None public subroutine ExitSubLog () Call this subroutine when you exit a section with verbose output Arguments None public subroutine WriteHeader (header_value) Write out a header to the log. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_value The text of the header. public subroutine WriteCitation (citation_list) Write out a citation element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: citation_list A list of citations, separated by a space.","tags":"","loc":"module/loggingmodule.html"},{"title":"PSMatrixAlgebraModule – NTPoly","text":"A Module For Performing Distributed Sparse Matrix Algebra Operations. Uses DataTypesModule GemmTasksModule PMatrixMemoryPoolModule PSMatrixModule MatrixReduceModule SMatrixAlgebraModule SMatrixModule TimerModule TripletListModule NTMPIModule iso_c_binding Contents Interfaces MatrixSigma MatrixMultiply MatrixGrandSum PairwiseMultiplyMatrix MatrixNorm DotMatrix IncrementMatrix ScaleMatrix MatrixTrace Interfaces public interface MatrixSigma private subroutine MatrixSigma_ps(this, sigma_value) Compute sigma for the inversion method.\n See \\cite ozaki2001efficient for details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the sigma value of. real(kind=NTREAL), intent(out) :: sigma_value Sigma public interface MatrixMultiply private subroutine MatrixMultiply_ps(matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in) Multiply two matrices together, and add to the third.\n C := alpha matA matB+ beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = alpha matA matB + beta*matC real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. type( MatrixMemoryPool_p ), intent(inout), optional :: memory_pool_in A memory pool for the calculation. public interface MatrixGrandSum private subroutine MatrixGrandSum_psr(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. real(kind=NTREAL), intent(out) :: sum The sum of all elements. private subroutine MatrixGrandSum_psc(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. complex(kind=NTCOMPLEX), intent(out) :: sum The sum of all elements. public interface PairwiseMultiplyMatrix private subroutine PairwiseMultiplyMatrix_ps(matA, matB, matC) Elementwise multiplication. C_ij = A_ij * B_ij.\n Also known as a Hadamard product. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = MatA mult MatB. public interface MatrixNorm private function MatrixNorm_ps(this) result(norm_value) Compute the norm of a distributed sparse matrix along the rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm value of the full distributed sparse matrix. public interface DotMatrix private subroutine DotMatrix_psr(matA, matB, product) product = dot(Matrix A,Matrix B)\n Note that a dot product is the sum of elementwise multiplication, not\n traditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product The dot product. private subroutine DotMatrix_psc(matA, matB, product) product = dot(Matrix A,Matrix B)\n Note that a dot product is the sum of elementwise multiplication, not\n traditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product The dot product. public interface IncrementMatrix private subroutine IncrementMatrix_ps(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY)\n This will utilize the sparse vector increment routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default= 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default=0). public interface ScaleMatrix private subroutine ScaleMatrix_psr(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. real(kind=NTREAL), intent(in) :: constant A constant scale factor. private subroutine ScaleMatrix_psc(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. complex(kind=NTCOMPLEX), intent(in) :: constant A constant scale factor. public interface MatrixTrace private subroutine MatrixTrace_psr(this, trace_value) Compute the trace of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the trace of. real(kind=NTREAL), intent(out) :: trace_value The trace value of the full distributed sparse matrix.","tags":"","loc":"module/psmatrixalgebramodule.html"},{"title":"ErrorModule – NTPoly","text":"A (under development) module to do handle error passing. Uses NTMPIModule Contents Derived Types Error_t Functions CheckMPIError CheckAllocError ErrorOccurred Subroutines ConstructError SetGenericError PrintError Cleanup Derived Types type, public :: Error_t A type that can be passed around to accumulate errors. Functions public function CheckMPIError (this, error_description, mpi_error, immediate_cleanup_in) result(error_occurred) Routine to call to check if an MPI error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: mpi_error The error variable produced by mpi. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. public function CheckAllocError (this, error_description, alloc_error, immediate_cleanup_in) result(error_occurred) Routine to call if an alloc error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this This the error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: alloc_error The error variable produced by alloc. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. public function ErrorOccurred (this) result(occurred) Check if an error has occurred or not. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error variable to check. Return Value logical True if an error has occurred, false otherwise. Subroutines public subroutine ConstructError (this) Default constructor for an error type. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The newly constructed error type public subroutine SetGenericError (this, error_description, immediate_cleanup_in) Routine to call if a generic error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. public subroutine PrintError (this) Print out that an error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error to print out. public subroutine Cleanup (this) As a last case resort, this will print an error message and quit. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error which has caused the need to cleanup the program.","tags":"","loc":"module/errormodule.html"},{"title":"SquareRootSolversModule – NTPoly","text":"A Module For Computing The Square Root of a Matrix. Uses DataTypesModule EigenBoundsModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines SquareRoot InverseSquareRoot Subroutines public subroutine SquareRoot (InputMat, OutputMat, solver_parameters_in, order_in) Compute the square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). public subroutine InverseSquareRoot (InputMat, OutputMat, solver_parameters_in, order_in) Compute the inverse square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5).","tags":"","loc":"module/squarerootsolversmodule.html"},{"title":"SVectorModule – NTPoly","text":"A module for handling compressed vectors. Uses DataTypesModule Contents Interfaces AddSparseVectors DotSparseVectors PairwiseMultiplyVectors Interfaces public interface AddSparseVectors private subroutine AddSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\n The values that are returned for C are only valid in the range\n (1:total_values_c). We do not do an automatic shrinking of the array\n to keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. private subroutine AddSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\n The values that are returned for C are only valid in the range\n (1:total_values_c). We do not do an automatic shrinking of the array\n to keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. public interface DotSparseVectors private pure function DotSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value real(kind=NTREAL) Dot product. private pure function DotSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value complex(kind=NTCOMPLEX) Dot product. public interface PairwiseMultiplyVectors private subroutine PairwiseMultiplyVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c This is the total number of values in C. private subroutine PairwiseMultiplyVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c This is the total number of values in C. integer, intent(out) :: total_values_c This is the total number of values in C.","tags":"","loc":"module/svectormodule.html"},{"title":"InverseSolversModule – NTPoly","text":"A Module For Computing The Inverse of a Matrix. Uses DataTypesModule LoadBalancerModule LoggingModule PMatrixMemoryPoolModule PSMatrixAlgebraModule PSMatrixModule SolverParametersModule Contents Subroutines Invert PseudoInverse Subroutines public subroutine Invert (Mat, InverseMat, solver_parameters_in) Compute the inverse of a matrix.\n An implementation of Hotelling's method \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to invert. type( Matrix_ps ), intent(inout) :: InverseMat The inverse of that matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public subroutine PseudoInverse (Mat, InverseMat, solver_parameters_in) Compute the pseudoinverse of a matrix.\n An implementation of Hotelling's method \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: InverseMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/inversesolversmodule.html"}]}