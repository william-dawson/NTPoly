var tipuesearch = {"pages":[{"title":" NTPoly ","text":"NTPoly Project Overview NTPoly is a massively parallel library for computing the functions of sparse,\nHermitian matrices based on polynomial expansions. For sufficiently sparse\nmatrices, most of the matrix functions in NTPoly can be computed in linear\ntime. Set Up Guide NTPoly is freely available and open source under the MIT license. It can be\ndownloaded from the Github repository. We of course recommend that you download a release version to get started. Installing NTPoly requires the following software: A Fortran Compiler. An MPI Installation (MPI-3 Standard+). CMake (Version 3.2+). BLAS: for multiplying dense matrices, if they emerge in the calculation. LAPACK: for dense solvers. The following optional software can greatly enhance the NTPoly experience: A C++ Compiler for building C++ bindings. Ford: for building documentation. Doxygen: for building C++ documentation. SWIG (Version 3.0+): for building the Python bindings. Python (Version 2.7+): if you would like python bindings. MPI4PY: for testing. SciPy: for testing. NumPy: for testing. EigenExa: for dense, parallel calculations. NTPoly uses CMake as a build system. First, take a look in the Targets\ndirectory. You'll find a list of .cmake files which have example\nconfigurations on popular systems. You should copy one of these files, and\ncreate your own mymachine.cmake file. Then, cd into the Build directory, and\ntype: cmake -DCMAKE_TOOLCHAIN_FILE=../Targets/mymachine.cmake .. After that you can build using: make And for the documentation: make doc If you aren't cross compiling and have built the python bindings, you can\nperform local tests using: make test There are a few options you can pass to CMake to modify the build. A few\nuseful standard options are:\n* -DCMAKE_BUILD_TYPE= Debug or Release .\n* -DCMAKE_INSTALL_PREFIX= followed by the path to your desired install\n directory. There are also some custom options special for NTPoly:\n* -DFORTRAN_ONLY= set to Yes if you only want to build the Fortran bindings.\n* -DNOSWIG= set to Yes if you don't want to build Python bindings.\n* -DUSE_MPIH= on some systems, there is no use mpi feature for Fortran,\n just #include \"mpi.h\" . You can set this option to activate the later.\n* -DNOIALLGATHER= on older MPI implementations, there is no non blocking\n collective operations. You can disable this feature using this option, but\n beware this might reduce performance. Online documentation is also available. Further details about the library can be found on the Wiki . Basic Theory The theory of matrix functions is a long studied branch of matrix algebra.\nMatrix functions have a wide range of applications, including graph problems,\ndifferential equations, and materials science. Common examples of matrix\nfunctions include the matrix exponential: f(A) = e&#94;A. from the study of networks, or the inverse square root: f(A) = A&#94;(-1/2) from quantum chemistry. NTPoly is a massively parallel library that can be used\nto compute a variety of matrix using polynomial expansions. Consider for example\nthe Taylor series expansion of a function f(x) . f(x) = f(0) + f'(0)x + f''(0)x&#94;2/2! + ... We can imagine expanding this from the function of a single variable, to a\nfunction of a matrix: f(A) = f(0) + f'(0)A + f''(0)A&#94;2/2! + ... where matrices can be summed using matrix addition, and raised to a power\nusing matrix multiplication. At the heart of NTPoly are polynomial expansions\nlike this. We implement not only Taylor expansions, but also Chebyshev\npolynomial expansions, and other specialized expansions based on the function\nof interest. When the input matrix A and the output matrix f(A) are sparse, we can\nreplace the dense matrix addition and multiplication routines with sparse\nmatrix routines. This allows us to use NTPoly to efficiently compute many\nfunctions of sparse matrices. Getting Start With Examples In the examples directory, there are a number of different example programs that\nuse NTPoly. You can check the ReadMe.md file in each example directory to\nlearn how to build and run each example. The simplest example is PremadeMatrix,\nwhich includes sample output you can compare to. Feature Outline The following features and methods have been implemented in NTPoly: General Polynomials Standard Polynomials Chebyshev Polynomials Hermite Polynomials Transcendental Functions Trigonometric Functions Exponential and Logarithm Matrix Roots Square Root and Inverse Square Root Matrix p th Root Quantum Chemistry Density Matrix Purification Chemical Potential Calculation Geometry Optimization Other Matrix Inverse/Moore-Penrose Pseudo Inverse Sign Function/Polar Decomposition Interface to Dense Eigen/Singular Value Decomposition Load Balancing Matrices File I/O Citation A description of the techniques used in NTPoly can be found in the following\nComputer Physics Communications paper: Dawson, William, and Takahito Nakajima. \"Massively parallel sparse matrix\nfunction calculations with NTPoly.\" Computer Physics Communications (2017). Please cite this paper in accordance to the practices in your field. How To Contribute To begin contributing to NTPoly, take a look at the Wiki pages. The Contributing Guide provides an overview of best development practices. Additionally, there is a Adding New Functionality page which documents how one would go about adding a matrix function to NTPoly.","tags":"home","loc":"index.html"},{"title":"ChebyshevPolynomial_t – NTPoly ","text":"type, public :: ChebyshevPolynomial_t A datatype that represents a Chebyshev polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/chebyshevpolynomial_t.html"},{"title":"MatrixMemoryPool_p – NTPoly ","text":"type, public :: MatrixMemoryPool_p A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Contents Variables grid_r grid_c Components Type Visibility Attributes Name Initial type( MatrixMemoryPool_lr ), public, DIMENSION(:,:), ALLOCATABLE :: grid_r Grid of local pools. type( MatrixMemoryPool_lc ), public, DIMENSION(:,:), ALLOCATABLE :: grid_c Grid of local pools (complex).","tags":"","loc":"type/matrixmemorypool_p.html"},{"title":"TripletList_r – NTPoly ","text":"type, public :: TripletList_r A data type for a list of triplets. Contents Variables DATA CurrentSize Components Type Visibility Attributes Name Initial type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list","tags":"","loc":"type/tripletlist_r.html"},{"title":"TripletList_c – NTPoly ","text":"type, public :: TripletList_c A data type for a list of triplets. Contents Variables DATA CurrentSize Components Type Visibility Attributes Name Initial type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list","tags":"","loc":"type/tripletlist_c.html"},{"title":"SolverParameters_t – NTPoly ","text":"type, public :: SolverParameters_t A class for passing parameters to an iterative solver. Contents Variables converge_diff max_iterations threshold be_verbose do_load_balancing BalancePermutation step_thresh Components Type Visibility Attributes Name Initial real(kind=NTREAL), public :: converge_diff When do we consider a calculation converged. integer, public :: max_iterations Maximum number of iterations of a solver before termination. real(kind=NTREAL), public :: threshold Threshold for sparse multiplication and addition. logical, public :: be_verbose If true, the sparse solver prints out information each loop iteration. logical, public :: do_load_balancing If true, the sparse solver will try and load balance before calculation. type( Permutation_t ), public :: BalancePermutation The permutation used for load balancing. real(kind=NTREAL), public :: step_thresh Thresholds for step size searches.","tags":"","loc":"type/solverparameters_t.html"},{"title":"MatrixMemoryPool_lr – NTPoly ","text":"type, public :: MatrixMemoryPool_lr A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Contents Variables columns rows pruned_list value_array dirty_array hash_index inserted_per_bucket hash_size Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets.","tags":"","loc":"type/matrixmemorypool_lr.html"},{"title":"MatrixMemoryPool_lc – NTPoly ","text":"type, public :: MatrixMemoryPool_lc A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Contents Variables columns rows pruned_list value_array dirty_array hash_index inserted_per_bucket hash_size Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets.","tags":"","loc":"type/matrixmemorypool_lc.html"},{"title":"ReduceHelper_t – NTPoly ","text":"type, public :: ReduceHelper_t A data structure to stores internal information about a reduce call. Contents Variables comm_size outer_request inner_request data_request error_code values_per_process displacement Components Type Visibility Attributes Name Initial integer, public :: comm_size Number of processors involved in this gather. integer, public :: outer_request A request object for gathering outer indices. integer, public :: inner_request A request object for gathering inner indices. integer, public :: data_request A request object for gathering data. integer, public :: error_code The error code after an MPI call. integer, public, DIMENSION(:), ALLOCATABLE :: values_per_process Number of values to gather from each process. integer, public, DIMENSION(:), ALLOCATABLE :: displacement The displacements for where those gathered values should go.","tags":"","loc":"type/reducehelper_t.html"},{"title":"Matrix_lsr – NTPoly ","text":"type, public :: Matrix_lsr A datatype for storing a local, real CSR matrix. Contents Variables outer_index inner_index values rows columns Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns","tags":"","loc":"type/matrix_lsr.html"},{"title":"Matrix_lsc – NTPoly ","text":"type, public :: Matrix_lsc A datatype for storing a local, complex CSR matrix. Contents Variables outer_index inner_index values rows columns Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices complex(kind=NTCOMPLEX), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns","tags":"","loc":"type/matrix_lsc.html"},{"title":"Permutation_t – NTPoly ","text":"type, public :: Permutation_t A data structure for storing permutations. Contents Variables index_lookup reverse_index_lookup Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: index_lookup For each row/column, what index does it correspond to in the\nunperturbed matrix. integer, public, DIMENSION(:), ALLOCATABLE :: reverse_index_lookup For each row/column in the unperturbed, what index does it correspond to\nin this matrix.","tags":"","loc":"type/permutation_t.html"},{"title":"HermitePolynomial_t – NTPoly ","text":"type, public :: HermitePolynomial_t A datatype that represents a Hermite polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/hermitepolynomial_t.html"},{"title":"Polynomial_t – NTPoly ","text":"type, public :: Polynomial_t A datatype that represents a polynomial. Contents Variables coefficients Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"type/polynomial_t.html"},{"title":"Matrix_ldr – NTPoly ","text":"type, public :: Matrix_ldr A datatype for storing a dense matrix. Contents Variables DATA rows columns Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns.","tags":"","loc":"type/matrix_ldr.html"},{"title":"Matrix_ldc – NTPoly ","text":"type, public :: Matrix_ldc A datatype for storing a dense matrix. Contents Variables DATA rows columns Components Type Visibility Attributes Name Initial complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns.","tags":"","loc":"type/matrix_ldc.html"},{"title":"Matrix_ps – NTPoly ","text":"type, public :: Matrix_ps A datatype for a distributed blocked CSR matrix. Contents Variables logical_matrix_dimension actual_matrix_dimension local_data_r local_data_c start_column end_column start_row end_row local_columns local_rows process_grid is_complex Components Type Visibility Attributes Name Initial integer, public :: logical_matrix_dimension Number of matrix rows/columns for full matrix, scaled for process grid. integer, public :: actual_matrix_dimension Number of matrix rows/columns for the full matrix, unscaled. type( Matrix_lsr ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_r A 2D array of local CSR matrices. type( Matrix_lsc ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_c A 2D array of local CSC matrices. integer, public :: start_column first column stored locally. integer, public :: end_column last column stored locally  is less than this. integer, public :: start_row first row stored locally. integer, public :: end_row last row stored locally is less than this. integer, public :: local_columns number of local columns. integer, public :: local_rows number of local rows. type( ProcessGrid_t ), public, POINTER :: process_grid process grid to operate on logical, public :: is_complex true if the matrix data is true.","tags":"","loc":"type/matrix_ps.html"},{"title":"ProcessGrid_t – NTPoly ","text":"type, public :: ProcessGrid_t A datatype which stores a process grid and all its communicators. Contents Variables total_processors num_process_rows num_process_columns num_process_slices slice_size my_slice my_row my_column global_rank within_slice_rank between_slice_rank column_rank row_rank global_comm row_comm column_comm within_slice_comm between_slice_comm grid_error RootID block_multiplier number_of_blocks_columns number_of_blocks_rows blocked_row_comm blocked_column_comm blocked_within_slice_comm blocked_between_slice_comm omp_max_threads Components Type Visibility Attributes Name Initial integer, public :: total_processors total processors in the grid. integer, public :: num_process_rows number of rows in the grid. integer, public :: num_process_columns number of columns in the grid. integer, public :: num_process_slices number of 2D slices in the grid. integer, public :: slice_size the size of a 2D slice. integer, public :: my_slice which slice is the current process in. integer, public :: my_row which row is the current process in. integer, public :: my_column which column is the current process in. integer, public :: global_rank current process rank amongst processes. integer, public :: within_slice_rank rank for within slice communication. integer, public :: between_slice_rank rank for between slice communication. integer, public :: column_rank rank for within column communication. integer, public :: row_rank rank for within row communication. integer, public :: global_comm communicator with every other process. integer, public :: row_comm communicator within a row. integer, public :: column_comm communicator within a column. integer, public :: within_slice_comm communicator within a slice. integer, public :: between_slice_comm communicator between slices. integer, public :: grid_error stores errors from MPI calls. integer, public :: RootID = 0 Which rank is root? integer, public :: block_multiplier Block scaling factor. integer, public :: number_of_blocks_columns number of column blocks. integer, public :: number_of_blocks_rows number of row blocks. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_row_comm blocked communicator within a row. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_column_comm blocked communicator within a column. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_within_slice_comm blocked communicator within a slice. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_between_slice_comm blocked communicator between slices. integer, public :: omp_max_threads The maximum number of openmp threads.","tags":"","loc":"type/processgrid_t.html"},{"title":"Triplet_r – NTPoly ","text":"type, public :: Triplet_r A data type for a triplet of integer, integer, double. Contents Variables index_column index_row point_value Components Type Visibility Attributes Name Initial integer, public :: index_column column value. integer, public :: index_row row value. real(kind=NTREAL), public :: point_value actual value at those indices.","tags":"","loc":"type/triplet_r.html"},{"title":"Triplet_c – NTPoly ","text":"type, public :: Triplet_c A data type for a triplet of integer, integer, complex. Contents Variables index_column index_row point_value Components Type Visibility Attributes Name Initial integer, public :: index_column column value. integer, public :: index_row row value. complex(kind=NTCOMPLEX), public :: point_value actual value at those indices.","tags":"","loc":"type/triplet_c.html"},{"title":"Error_t – NTPoly ","text":"type, public :: Error_t A type that can be passed around to accumulate errors. Contents None","tags":"","loc":"type/error_t.html"},{"title":"ComputeRoot – NTPoly","text":"public recursive subroutine ComputeRoot(InputMat, OutputMat, root, solver_parameters_in) Compute a general matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computeroot.html"},{"title":"ComputeInverseRoot – NTPoly","text":"public recursive subroutine ComputeInverseRoot(InputMat, OutputMat, root, solver_parameters_in) Compute a general inverse matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;-1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents","tags":"","loc":"proc/computeinverseroot.html"},{"title":"SingularValueDecomposition – NTPoly","text":"public  subroutine SingularValueDecomposition(this, left_vectors, right_vectors, singularvalues, solver_parameters_in) Compute the singular values and singular vectors of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to decompose. type( Matrix_ps ), intent(inout) :: left_vectors A matrix containing the left singular vectors. type( Matrix_ps ), intent(inout) :: right_vectors A matrix containing the right singular vectors. type( Matrix_ps ), intent(inout) :: singularvalues A diagonal matrix containing the singularvalues. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/singularvaluedecomposition.html"},{"title":"PivotedCholeskyDecomposition – NTPoly","text":"public  subroutine PivotedCholeskyDecomposition(AMat, LMat, rank_in, solver_parameters_in) Compute The Pivoted Cholesky Decomposition of a Hermitian Semi-Definite\nmatrix. This is one way to generate localized orbitals. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive semi-definite. type( Matrix_ps ), intent(inout) :: LMat The matrix computed. integer, intent(in) :: rank_in The target rank of the matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Tarameters for the solver Contents","tags":"","loc":"proc/pivotedcholeskydecomposition.html"},{"title":"ReduceDimension – NTPoly","text":"public  subroutine ReduceDimension(this, dim, ReducedMat, solver_parameters_in) When we want to only compute the first n eigenvalues of a matrix, this\nroutine will project out the higher eigenvalues. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The starting matrix. integer, intent(in) :: dim The number of eigenvalues ot keep. type( Matrix_ps ), intent(inout) :: ReducedMat a dimxdim matrix with the same first n eigenvalues as the first. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The solver parameters. Contents","tags":"","loc":"proc/reducedimension.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_cheby Module Procedures private pure subroutine ConstructPolynomial_cheby(this, degree) Construct a Chebyshev polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree Degree of the polynomial.","tags":"","loc":"interface/constructpolynomial.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_cheby Module Procedures private pure subroutine DestructPolynomial_cheby(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_cheby Module Procedures private  subroutine SetCoefficient_cheby(this, degree, coefficient) Set a coefficient of a Chebyshev polynomial. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value.","tags":"","loc":"interface/setcoefficient.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_cheby Module Procedures private  subroutine Compute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\nThis method uses the standard Chebyshev Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/compute.html"},{"title":"FactorizedCompute – NTPoly","text":"public interface FactorizedCompute Contents Module Procedures FactorizedCompute_cheby Module Procedures private  subroutine FactorizedCompute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\nThis version first factors the Chebyshev Polynomial and computes the\nfunction using a divide and conquer algorithm. Based on a simplified\nversion of the first method in \\cite liang2003improved . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/factorizedcompute.html"},{"title":"Sine – NTPoly","text":"public  subroutine Sine(InputMat, OutputMat, solver_parameters_in) Compute the sine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents","tags":"","loc":"proc/sine.html"},{"title":"DenseSine – NTPoly","text":"public  subroutine DenseSine(Mat, OutputMat, solver_parameters_in) Compute the sine of a matrix. (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The sine of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/densesine.html"},{"title":"Cosine – NTPoly","text":"public  subroutine Cosine(InputMat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents","tags":"","loc":"proc/cosine.html"},{"title":"DenseCosine – NTPoly","text":"public  subroutine DenseCosine(Mat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The cosine of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/densecosine.html"},{"title":"ScaleSquareTrigonometryTaylor – NTPoly","text":"public  subroutine ScaleSquareTrigonometryTaylor(InputMat, OutputMat, params) Compute trigonometric functions of a matrix using a taylor series. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in) :: params Parameters for the solver. Contents","tags":"","loc":"proc/scalesquaretrigonometrytaylor.html"},{"title":"ConstructMatrixMemoryPool – NTPoly","text":"public interface ConstructMatrixMemoryPool Contents Module Procedures ConstructMatrixMemoryPool_p Module Procedures private pure subroutine ConstructMatrixMemoryPool_p(this, matrix) Construct Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this A constructed Matrix Memory Pool object. type( Matrix_ps ), intent(in) :: matrix The associated distributed sparse matrix.","tags":"","loc":"interface/constructmatrixmemorypool.html"},{"title":"DestructMatrixMemoryPool – NTPoly","text":"public interface DestructMatrixMemoryPool Contents Module Procedures DestructMatrixMemoryPool_p Module Procedures private pure subroutine DestructMatrixMemoryPool_p(this) Destruct a Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this Distributed Matrix Memory Pool object to destroy.","tags":"","loc":"interface/destructmatrixmemorypool.html"},{"title":"CheckMemoryPoolValidity – NTPoly","text":"public interface CheckMemoryPoolValidity Contents Module Procedures CheckMemoryPoolValidity_p Module Procedures private pure function CheckMemoryPoolValidity_p(this, matrix) result(isvalid) Checks if a given distributed memory pool has been validly allocated to\nhandle the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(in) :: this The memory pool to check. type( Matrix_ps ), intent(in) :: matrix The associated matrix to check against. Return Value logical True if the memory pool is valid.","tags":"","loc":"interface/checkmemorypoolvalidity.html"},{"title":"ConstructTripletList – NTPoly","text":"public interface ConstructTripletList Contents Module Procedures ConstructTripletListSup_r ConstructTripletListSup_c Module Procedures private pure subroutine ConstructTripletListSup_r(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer, intent(in), optional :: size_in The length of the triplet list (default = 0). private pure subroutine ConstructTripletListSup_c(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer, intent(in), optional :: size_in The length of the triplet list (default = 0).","tags":"","loc":"interface/constructtripletlist.html"},{"title":"CopyTripletList – NTPoly","text":"public interface CopyTripletList Contents Module Procedures CopyTripletList_r CopyTripletList_c Module Procedures private  subroutine CopyTripletList_r(tripA, tripB) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: tripA The triplet list to copy. type( TripletList_r ), intent(inout) :: tripB tripB = tripA private  subroutine CopyTripletList_c(tripA, tripB) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: tripA The triplet list to copy. type( TripletList_c ), intent(inout) :: tripB tripB = tripA","tags":"","loc":"interface/copytripletlist.html"},{"title":"DestructTripletList – NTPoly","text":"public interface DestructTripletList Contents Module Procedures DestructTripletList_r DestructTripletList_c Module Procedures private pure subroutine DestructTripletList_r(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. private pure subroutine DestructTripletList_c(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct.","tags":"","loc":"interface/destructtripletlist.html"},{"title":"ResizeTripletList – NTPoly","text":"public interface ResizeTripletList Contents Module Procedures ResizeTripletList_r ResizeTripletList_c Module Procedures private pure subroutine ResizeTripletList_r(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer, intent(in) :: size Size to resize to. private pure subroutine ResizeTripletList_c(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer, intent(in) :: size Size to resize to.","tags":"","loc":"interface/resizetripletlist.html"},{"title":"AppendToTripletList – NTPoly","text":"public interface AppendToTripletList Contents Module Procedures AppendToTripletList_r AppendToTripletList_c Module Procedures private pure subroutine AppendToTripletList_r(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. private pure subroutine AppendToTripletList_c(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append.","tags":"","loc":"interface/appendtotripletlist.html"},{"title":"SetTripletAt – NTPoly","text":"public interface SetTripletAt Contents Module Procedures SetTripletAt_r SetTripletAt_c Module Procedures private pure subroutine SetTripletAt_r(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer, intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. private pure subroutine SetTripletAt_c(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer, intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set.","tags":"","loc":"interface/settripletat.html"},{"title":"GetTripletAt – NTPoly","text":"public interface GetTripletAt Contents Module Procedures GetTripletAt_r GetTripletAt_c Module Procedures private pure subroutine GetTripletAt_r(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer, intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. private pure subroutine GetTripletAt_c(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer, intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value.","tags":"","loc":"interface/gettripletat.html"},{"title":"SortTripletList – NTPoly","text":"public interface SortTripletList Contents Module Procedures SortTripletList_r SortTripletList_c Module Procedures private pure subroutine SortTripletList_r(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\nImplementation is based on bucket sort. This is why it needs the number of\nmatrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you do not need the final bubble sort. private pure subroutine SortTripletList_c(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\nImplementation is based on bucket sort. This is why it needs the number of\nmatrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you do not need the final bubble sort.","tags":"","loc":"interface/sorttripletlist.html"},{"title":"SymmetrizeTripletList – NTPoly","text":"public interface SymmetrizeTripletList Contents Module Procedures SymmetrizeTripletList_r SymmetrizeTripletList_c Module Procedures private  subroutine SymmetrizeTripletList_r(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\nsymmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. private  subroutine SymmetrizeTripletList_c(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\nsymmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry.","tags":"","loc":"interface/symmetrizetripletlist.html"},{"title":"GetTripletListSize – NTPoly","text":"public interface GetTripletListSize Contents Module Procedures GetTripletListSize_r GetTripletListSize_c Module Procedures private pure function GetTripletListSize_r(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. private pure function GetTripletListSize_c(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list.","tags":"","loc":"interface/gettripletlistsize.html"},{"title":"RedistributeTripletLists – NTPoly","text":"public interface RedistributeTripletLists Contents Module Procedures RedistributeTripletLists_r RedistributeTripletLists_c Module Procedures private  subroutine RedistributeTripletLists_r(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\nTakes in a list of triplet lists, one list for each processor. Then the\nall to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. private  subroutine RedistributeTripletLists_c(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\nTakes in a list of triplet lists, one list for each processor. Then the\nall to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list.","tags":"","loc":"interface/redistributetripletlists.html"},{"title":"ShiftTripletList – NTPoly","text":"public interface ShiftTripletList Contents Module Procedures ShiftTripletList_r ShiftTripletList_c Module Procedures private pure subroutine ShiftTripletList_r(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\nFrequently, we have a triplet list that comes from the global matrix which\nwe would like to shift into a local matrix. In that case, just pass\nthe negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. private pure subroutine ShiftTripletList_c(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\nFrequently, we have a triplet list that comes from the global matrix which\nwe would like to shift into a local matrix. In that case, just pass\nthe negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by.","tags":"","loc":"interface/shifttripletlist.html"},{"title":"ConvertTripletListType – NTPoly","text":"public interface ConvertTripletListType Contents Module Procedures ConvertTripletListToReal ConvertTripletListToComplex Module Procedures private  subroutine ConvertTripletListToReal(cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. private  subroutine ConvertTripletListToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list.","tags":"","loc":"interface/converttripletlisttype.html"},{"title":"ConstructSolverParameters – NTPoly","text":"public  subroutine ConstructSolverParameters(this, converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in, step_thresh_in) Construct a data type which stores iterative solver parameters. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameters to construct. real(kind=NTREAL), intent(in), optional :: converge_diff_in Converge_diff_in the difference between iterations to consider\na calculation converged. real(kind=NTREAL), intent(in), optional :: threshold_in The zero threshold integer, intent(in), optional :: max_iterations_in The maximum number of iterations to perform logical, intent(in), optional :: be_verbose_in Whether to print during the calculation (default = False) type( Permutation_t ), intent(in), optional :: BalancePermutation_in For load balancing real(kind=NTREAL), intent(in), optional :: step_thresh_in Step size for differential equation solvers. Contents","tags":"","loc":"proc/constructsolverparameters.html"},{"title":"CopySolverParameters – NTPoly","text":"public  subroutine CopySolverParameters(paramA, paramB) Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: paramA Parameters to copy type( SolverParameters_t ), intent(inout) :: paramB paramB = paramA Contents","tags":"","loc":"proc/copysolverparameters.html"},{"title":"SetParametersConvergeDiff – NTPoly","text":"public pure subroutine SetParametersConvergeDiff(this, new_value) Set the value of the convergence difference. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersconvergediff.html"},{"title":"SetParametersMaxIterations – NTPoly","text":"public pure subroutine SetParametersMaxIterations(this, new_value) Set the value of the max iterations. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. integer, intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersmaxiterations.html"},{"title":"SetParametersThreshold – NTPoly","text":"public pure subroutine SetParametersThreshold(this, new_value) Set the value of the threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersthreshold.html"},{"title":"SetParametersBeVerbose – NTPoly","text":"public pure subroutine SetParametersBeVerbose(this, new_value) Set the value of the verbosity. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. logical, intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersbeverbose.html"},{"title":"SetParametersLoadBalance – NTPoly","text":"public pure subroutine SetParametersLoadBalance(this, new_value) Set the value of the load balance. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. type( Permutation_t ), intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersloadbalance.html"},{"title":"SetParametersStepThreshold – NTPoly","text":"public pure subroutine SetParametersStepThreshold(this, new_value) Set the value of the step threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. Contents","tags":"","loc":"proc/setparametersstepthreshold.html"},{"title":"PrintParameters – NTPoly","text":"public  subroutine PrintParameters(this) Print out the iterative solver parameter values. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: this The parameter object. Contents","tags":"","loc":"proc/printparameters.html"},{"title":"DestructSolverParameters – NTPoly","text":"public pure subroutine DestructSolverParameters(this) Cleanup the solver parameters datastructure. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. Contents","tags":"","loc":"proc/destructsolverparameters.html"},{"title":"MapMatrix_psr – NTPoly","text":"public  subroutine MapMatrix_psr(inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (real). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. Contents","tags":"","loc":"proc/mapmatrix_psr.html"},{"title":"MapMatrix_psc – NTPoly","text":"public  subroutine MapMatrix_psc(inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (complex). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. Contents","tags":"","loc":"proc/mapmatrix_psc.html"},{"title":"MapTripletList – NTPoly","text":"public interface MapTripletList Contents Module Procedures MapTripletList_r MapTripletList_c MapTripletListArrayDouble_r MapTripletListArrayDouble_c MapTripletListArrayInt_r MapTripletListArrayInt_c Module Procedures private  subroutine MapTripletList_r(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletList_c(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayDouble_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (real) triplet list, apply this procedure to each element with Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. real(kind=NTREAL), intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayDouble_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (complex) triplet list, apply this procedure to each element Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. complex(kind=NTCOMPLEX), intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayInt_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (real) triplet list, apply this procedure to each element with Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. integer, intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. integer, intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayInt_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (complex) triplet list, apply this procedure to each element Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. integer, intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. integer, intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0).","tags":"","loc":"interface/maptripletlist.html"},{"title":"RegisterTimer – NTPoly","text":"public  subroutine RegisterTimer(timer_name) Register a timer with the timer module.  Call this before using that timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Contents","tags":"","loc":"proc/registertimer.html"},{"title":"StartTimer – NTPoly","text":"public  subroutine StartTimer(timer_name) Start the clock running for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents","tags":"","loc":"proc/starttimer.html"},{"title":"StopTimer – NTPoly","text":"public  subroutine StopTimer(timer_name) Stop the clock for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents","tags":"","loc":"proc/stoptimer.html"},{"title":"PrintTimer – NTPoly","text":"public  subroutine PrintTimer(timer_name) Print out the elapsed time for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. Contents","tags":"","loc":"proc/printtimer.html"},{"title":"PrintAllTimers – NTPoly","text":"public  subroutine PrintAllTimers() Print out the elapsed time for each timer on this process. Arguments None Contents None","tags":"","loc":"proc/printalltimers.html"},{"title":"PrintAllTimersDistributed – NTPoly","text":"public  subroutine PrintAllTimersDistributed() Print out the elapsed time for each timer based on the max value across\nprocesses. Arguments None Contents None","tags":"","loc":"proc/printalltimersdistributed.html"},{"title":"PermuteMatrix – NTPoly","text":"public  subroutine PermuteMatrix(mat, mat_out, permutation, memorypool_in) Apply a permutation to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat The matrix to permute. type( Matrix_ps ), intent(inout) :: mat_out The permuted matrix. type( Permutation_t ), intent(in) :: permutation The permutation to apply. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use Contents","tags":"","loc":"proc/permutematrix.html"},{"title":"UndoPermuteMatrix – NTPoly","text":"public  subroutine UndoPermuteMatrix(mat, mat_out, permutation, memorypool_in) Undo a permutation applied to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat Matrix to undo permutation of. type( Matrix_ps ), intent(inout) :: mat_out Unpermuted matrix. type( Permutation_t ), intent(in) :: permutation Permutation to remove. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use. Contents","tags":"","loc":"proc/undopermutematrix.html"},{"title":"ConstructMatrixMemoryPool – NTPoly","text":"public interface ConstructMatrixMemoryPool Contents Module Procedures ConstructMatrixMemoryPoolSub_lr ConstructMatrixMemoryPoolSub_lc Module Procedures private  subroutine ConstructMatrixMemoryPoolSub_lr(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), TARGET :: this The matrix to construct. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). private  subroutine ConstructMatrixMemoryPoolSub_lc(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), TARGET :: this The matrix to construct. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional).","tags":"","loc":"interface/constructmatrixmemorypool~2.html"},{"title":"DestructMatrixMemoryPool – NTPoly","text":"public interface DestructMatrixMemoryPool Contents Module Procedures DestructMatrixMemoryPool_lr DestructMatrixMemoryPool_lc Module Procedures private pure subroutine DestructMatrixMemoryPool_lr(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout) :: this The matrix being destructed. private pure subroutine DestructMatrixMemoryPool_lc(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout) :: this The matrix being destructed.","tags":"","loc":"interface/destructmatrixmemorypool~2.html"},{"title":"CheckMemoryPoolValidity – NTPoly","text":"public interface CheckMemoryPoolValidity Contents Module Procedures CheckMemoryPoolValidity_lr CheckMemoryPoolValidity_lc Module Procedures private pure function CheckMemoryPoolValidity_lr(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\nthe given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. private pure function CheckMemoryPoolValidity_lc(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\nChecks if a given memory pool has been validly allocated to handle\nthe given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid.","tags":"","loc":"interface/checkmemorypoolvalidity~2.html"},{"title":"SetPoolSparsity – NTPoly","text":"public interface SetPoolSparsity Contents Module Procedures SetPoolSparsity_lr SetPoolSparsity_lc Module Procedures private  subroutine SetPoolSparsity_lr(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. private  subroutine SetPoolSparsity_lc(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value.","tags":"","loc":"interface/setpoolsparsity.html"},{"title":"PM – NTPoly","text":"public  subroutine PM(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the PM method.\nBased on the PM algorithm presented in \\cite palser1998canonical Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/pm.html"},{"title":"TRS2 – NTPoly","text":"public  subroutine TRS2(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS2 method.\nBased on the TRS2 algorithm presented in \\cite niklasson2002. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/trs2.html"},{"title":"TRS4 – NTPoly","text":"public  subroutine TRS4(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS4 method.\nBased on the TRS4 algorithm presented in \\cite niklasson2002 Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/trs4.html"},{"title":"HPCP – NTPoly","text":"public  subroutine HPCP(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the HPCP method.\nBased on the algorithm presented in \\cite truflandier2016communication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/hpcp.html"},{"title":"ScaleAndFold – NTPoly","text":"public  subroutine ScaleAndFold(H, ISQ, trace, K, homo, lumo, energy_value_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the Scale and Fold\nmethod. Based on the method of \\cite rubensson2011nonmonotonic .\nNote that for this method, you must provide the value of the homo and\nlumo gap. It is not necessary for these to be accurate, but give a\nconservative value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: homo A conservative estimate of the highest occupied eigenvalue. real(kind=NTREAL), intent(in) :: lumo A conservative estimate of the lowest unoccupied eigenvalue. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/scaleandfold.html"},{"title":"DenseDensity – NTPoly","text":"public  subroutine DenseDensity(H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix using a dense routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/densedensity.html"},{"title":"EnergyDensityMatrix – NTPoly","text":"public  subroutine EnergyDensityMatrix(H, D, ED, threshold_in) Compute the energy-weighted density matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute from. type( Matrix_ps ), intent(in) :: D The density matrix. type( Matrix_ps ), intent(inout) :: ED The energy-weighted density matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0). Contents","tags":"","loc":"proc/energydensitymatrix.html"},{"title":"McWeenyStep – NTPoly","text":"public  subroutine McWeenyStep(D, DOut, S_in, threshold_in) Take one McWeeny Step DOut = 3 DSD - 2 DSDSD Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: D The density matrix. type( Matrix_ps ), intent(inout) :: DOut The resulting purified matrix. type( Matrix_ps ), intent(in), optional :: S_in The overlap matrix (optional) real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0). Contents","tags":"","loc":"proc/mcweenystep.html"},{"title":"ComputeDenseFOE – NTPoly","text":"public  subroutine ComputeDenseFOE(H, ISQ, trace, K, inv_temp_in, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix using a dense routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in), optional :: inv_temp_in The inverse temperature for smearing in a.u. (optional). real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/computedensefoe.html"},{"title":"WOM_GC – NTPoly","text":"public  subroutine WOM_GC(H, ISQ, K, chemical_potential, inv_temp, energy_value_out, solver_parameters_in) Compute the density matrix according to the wave operator minization Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: chemical_potential The chemical potential. real(kind=NTREAL), intent(in) :: inv_temp The inverse temperature for smearing in a.u. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/wom_gc.html"},{"title":"WOM_C – NTPoly","text":"public  subroutine WOM_C(H, ISQ, K, trace, inv_temp, energy_value_out, solver_parameters_in) Compute the density matrix according to the wave operator minization Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: trace The target trace. real(kind=NTREAL), intent(in) :: inv_temp The inverse temperature for smearing in a.u. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). Contents","tags":"","loc":"proc/wom_c.html"},{"title":"TestReduceSizeRequest – NTPoly","text":"public  function TestReduceSizeRequest(helper) result(request_completed) Test if a request for the size of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents","tags":"","loc":"proc/testreducesizerequest.html"},{"title":"TestReduceInnerRequest – NTPoly","text":"public  function TestReduceInnerRequest(helper) result(request_completed) Test if a request for the inner indices of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents","tags":"","loc":"proc/testreduceinnerrequest.html"},{"title":"TestReduceDataRequest – NTPoly","text":"public  function TestReduceDataRequest(helper) result(request_completed) Test if a request for the data of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. Contents","tags":"","loc":"proc/testreducedatarequest.html"},{"title":"ReduceAndComposeMatrixSizes – NTPoly","text":"public interface ReduceAndComposeMatrixSizes Contents Module Procedures ReduceAndComposeMatrixSizes_lsr ReduceAndComposeMatrixSizes_lsc Module Procedures private  subroutine ReduceAndComposeMatrixSizes_lsr(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private  subroutine ReduceAndComposeMatrixSizes_lsc(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: comm type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper","tags":"","loc":"interface/reduceandcomposematrixsizes.html"},{"title":"ReduceAndComposeMatrixData – NTPoly","text":"public interface ReduceAndComposeMatrixData Contents Module Procedures ReduceAndComposeMatrixData_lsr ReduceAndComposeMatrixData_lsc Module Procedures private  subroutine ReduceAndComposeMatrixData_lsr(matrix, comm, gathered_matrix, helper) Second function to call, will gather the data and align one matrix\nnext to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private  subroutine ReduceAndComposeMatrixData_lsc(matrix, comm, gathered_matrix, helper) Second function to call, will gather the data and align one matrix\nnext to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandcomposematrixdata.html"},{"title":"ReduceAndComposeMatrixCleanup – NTPoly","text":"public interface ReduceAndComposeMatrixCleanup Contents Module Procedures ReduceAndComposeMatrixCleanup_lsr ReduceAndComposeMatrixCleanup_lsc Module Procedures private pure subroutine ReduceAndComposeMatrixCleanup_lsr(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private pure subroutine ReduceAndComposeMatrixCleanup_lsc(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandcomposematrixcleanup.html"},{"title":"ReduceAndComposeMatrix – NTPoly","text":"public interface ReduceAndComposeMatrix Contents Module Procedures ReduceAndComposeMatrix_lsr ReduceAndComposeMatrix_lsc Module Procedures private  subroutine ReduceAndComposeMatrix_lsr(matrix, comm, gathered_matrix) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. private  subroutine ReduceAndComposeMatrix_lsc(matrix, comm, gathered_matrix) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering.","tags":"","loc":"interface/reduceandcomposematrix.html"},{"title":"ReduceAndSumMatrixSizes – NTPoly","text":"public interface ReduceAndSumMatrixSizes Contents Module Procedures ReduceAndSumMatrixSizes_lsr ReduceAndSumMatrixSizes_lsc Module Procedures private  subroutine ReduceAndSumMatrixSizes_lsr(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private  subroutine ReduceAndSumMatrixSizes_lsc(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandsummatrixsizes.html"},{"title":"ReduceAndSumMatrixData – NTPoly","text":"public interface ReduceAndSumMatrixData Contents Module Procedures ReduceAndSumMatrixData_lsr ReduceAndSumMatrixData_lsc Module Procedures private  subroutine ReduceAndSumMatrixData_lsr(matrix, comm, gathered_matrix, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private  subroutine ReduceAndSumMatrixData_lsc(matrix, comm, gathered_matrix, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandsummatrixdata.html"},{"title":"ReduceAndSumMatrixCleanup – NTPoly","text":"public interface ReduceAndSumMatrixCleanup Contents Module Procedures ReduceAndSumMatrixCleanup_lsr ReduceAndSumMatrixCleanup_lsc Module Procedures private pure subroutine ReduceAndSumMatrixCleanup_lsr(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private pure subroutine ReduceAndSumMatrixCleanup_lsc(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather.","tags":"","loc":"interface/reduceandsummatrixcleanup.html"},{"title":"ReduceAndSumMatrix – NTPoly","text":"public interface ReduceAndSumMatrix Contents Module Procedures ReduceAndSumMatrix_lsr ReduceAndSumMatrix_lsc Module Procedures private  subroutine ReduceAndSumMatrix_lsr(matrix, comm, gathered_matrix, threshold) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. private  subroutine ReduceAndSumMatrix_lsc(matrix, comm, gathered_matrix, threshold) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values.","tags":"","loc":"interface/reduceandsummatrix.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrixSub_lsr ConstructEmptyMatrixSub_lsc Module Procedures private pure subroutine ConstructEmptyMatrixSub_lsr(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. private pure subroutine ConstructEmptyMatrixSub_lsc(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero.","tags":"","loc":"interface/constructemptymatrix.html"},{"title":"ConstructMatrixFromFile – NTPoly","text":"public interface ConstructMatrixFromFile Contents Module Procedures ConstructMatrixFromFileSub_lsr ConstructMatrixFromFileSub_lsc Module Procedures private  subroutine ConstructMatrixFromFileSub_lsr(this, file_name) Subroutine wrapper for the construct from file function. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. private  subroutine ConstructMatrixFromFileSub_lsc(this, file_name) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file.","tags":"","loc":"interface/constructmatrixfromfile.html"},{"title":"ConstructMatrixFromTripletList – NTPoly","text":"public interface ConstructMatrixFromTripletList Contents Module Procedures ConstructMatrixFromTripletListSub_lsr ConstructMatrixFromTripletListSub_lsc Module Procedures private pure subroutine ConstructMatrixFromTripletListSub_lsr(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns private pure subroutine ConstructMatrixFromTripletListSub_lsc(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns","tags":"","loc":"interface/constructmatrixfromtripletlist.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_lsr DestructMatrix_lsc Module Procedures private pure subroutine DestructMatrix_lsr(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to free up. private pure subroutine DestructMatrix_lsc(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to free up.","tags":"","loc":"interface/destructmatrix.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_lsr CopyMatrix_lsc Module Procedures private pure subroutine CopyMatrix_lsr(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix to copy type( Matrix_lsr ), intent(inout) :: matB matB = matA private pure subroutine CopyMatrix_lsc(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix to copy type( Matrix_lsc ), intent(inout) :: matB matB = matA","tags":"","loc":"interface/copymatrix.html"},{"title":"GetMatrixRows – NTPoly","text":"public interface GetMatrixRows Contents Module Procedures GetMatrixRows_lsr GetMatrixRows_lsc Module Procedures private pure function GetMatrixRows_lsr(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix. Return Value integer The number of rows. private pure function GetMatrixRows_lsc(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix. Return Value integer The number of rows.","tags":"","loc":"interface/getmatrixrows.html"},{"title":"GetMatrixColumns – NTPoly","text":"public interface GetMatrixColumns Contents Module Procedures GetMatrixColumns_lsr GetMatrixColumns_lsc Module Procedures private pure function GetMatrixColumns_lsr(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this Return Value integer The number of columns. private pure function GetMatrixColumns_lsc(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this Return Value integer The number of columns.","tags":"","loc":"interface/getmatrixcolumns.html"},{"title":"ExtractMatrixRow – NTPoly","text":"public interface ExtractMatrixRow Contents Module Procedures ExtractMatrixRow_lsr ExtractMatrixRow_lsc Module Procedures private pure subroutine ExtractMatrixRow_lsr(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsr ), intent(inout) :: row_out The matrix representing that row. private pure subroutine ExtractMatrixRow_lsc(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsc ), intent(inout) :: row_out The matrix representing that row.","tags":"","loc":"interface/extractmatrixrow.html"},{"title":"ExtractMatrixColumn – NTPoly","text":"public interface ExtractMatrixColumn Contents Module Procedures ExtractMatrixColumn_lsr ExtractMatrixColumn_lsc Module Procedures private pure subroutine ExtractMatrixColumn_lsr(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsr ), intent(inout) :: column_out The column representing that row. private pure subroutine ExtractMatrixColumn_lsc(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsc ), intent(inout) :: column_out The column representing that row.","tags":"","loc":"interface/extractmatrixcolumn.html"},{"title":"SplitMatrix – NTPoly","text":"public interface SplitMatrix Contents Module Procedures SplitMatrix_lsr SplitMatrix_lsc Module Procedures private pure subroutine SplitMatrix_lsr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsr ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private pure subroutine SplitMatrix_lsc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns.","tags":"","loc":"interface/splitmatrix.html"},{"title":"SplitMatrixColumns – NTPoly","text":"public interface SplitMatrixColumns Contents Module Procedures SplitMatrixColumns_lsr SplitMatrixColumns_lsc Module Procedures private pure subroutine SplitMatrixColumns_lsr(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsr ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. private pure subroutine SplitMatrixColumns_lsc(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsc ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks.","tags":"","loc":"interface/splitmatrixcolumns.html"},{"title":"ComposeMatrix – NTPoly","text":"public interface ComposeMatrix Contents Module Procedures ComposeMatrix_lsr ComposeMatrix_lsc Module Procedures private pure subroutine ComposeMatrix_lsr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:, :) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsr ), intent(inout) :: out_matrix The composed matrix. private pure subroutine ComposeMatrix_lsc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:, :) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsc ), intent(inout) :: out_matrix The composed matrix.","tags":"","loc":"interface/composematrix.html"},{"title":"ComposeMatrixColumns – NTPoly","text":"public interface ComposeMatrixColumns Contents Module Procedures ComposeMatrixColumns_lsr ComposeMatrixColumns_lsc Module Procedures private pure subroutine ComposeMatrixColumns_lsr(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\nthe first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsr ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. private pure subroutine ComposeMatrixColumns_lsc(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\nthe first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsc ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...].","tags":"","loc":"interface/composematrixcolumns.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_lsr TransposeMatrix_lsc Module Procedures private pure subroutine TransposeMatrix_lsr(this, matT) Transpose a sparse matrix and return it in a separate matrix.\nThe current implementation has you go from matrix to triplet list,\ntriplet list to transposed triplet list. The triplet list must then be\nsorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be transposed. type( Matrix_lsr ), intent(inout) :: matT The input matrix transposed. private pure subroutine TransposeMatrix_lsc(this, matT) Transpose a sparse matrix and return it in a separate matrix.\nThe current implementation has you go from matrix to triplet list,\ntriplet list to transposed triplet list. The triplet list must then be\nsorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be transposed. type( Matrix_lsc ), intent(inout) :: matT The input matrix transposed.","tags":"","loc":"interface/transposematrix.html"},{"title":"ConjugateMatrix – NTPoly","text":"public interface ConjugateMatrix Contents Module Procedures ConjugateMatrix_lsc Module Procedures private pure subroutine ConjugateMatrix_lsc(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to compute the complex conjugate of.","tags":"","loc":"interface/conjugatematrix.html"},{"title":"PrintMatrix – NTPoly","text":"public interface PrintMatrix Contents Module Procedures PrintMatrix_lsr PrintMatrix_lsc Module Procedures private  subroutine PrintMatrix_lsr(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. private  subroutine PrintMatrix_lsc(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to.","tags":"","loc":"interface/printmatrix.html"},{"title":"MatrixToTripletList – NTPoly","text":"public interface MatrixToTripletList Contents Module Procedures MatrixToTripletList_lsr MatrixToTripletList_lsc Module Procedures private pure subroutine MatrixToTripletList_lsr(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_r ), intent(inout) :: triplet_list The triplet list we created. private pure subroutine MatrixToTripletList_lsc(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_c ), intent(inout) :: triplet_list The triplet list we created.","tags":"","loc":"interface/matrixtotripletlist.html"},{"title":"ConvertMatrixType – NTPoly","text":"public interface ConvertMatrixType Contents Module Procedures ConvertMatrixType_lsrtolsc ConvertMatrixType_lsctolsr Module Procedures private  subroutine ConvertMatrixType_lsrtolsc(cin, rout) Convert a complex matrix to a real matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: cin The starting matrix. type( Matrix_lsr ), intent(inout) :: rout Real valued matrix. private  subroutine ConvertMatrixType_lsctolsr(rin, cout) Convert a real matrix to a complex matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: rin The starting matrix. type( Matrix_lsc ), intent(inout) :: cout The complex valued matrix.","tags":"","loc":"interface/convertmatrixtype.html"},{"title":"ComputeExponential – NTPoly","text":"public  subroutine ComputeExponential(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computeexponential.html"},{"title":"ComputeExponentialPade – NTPoly","text":"public  subroutine ComputeExponentialPade(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a pade approximation.\nBe warned, the pade method can result in a lot of intermediate fill. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computeexponentialpade.html"},{"title":"ComputeExponentialTaylor – NTPoly","text":"public  subroutine ComputeExponentialTaylor(InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a taylor series expansion.\nThis is only really useful if you have a very small spectrum, because\nquite a bit of scaling is required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computeexponentialtaylor.html"},{"title":"ComputeDenseExponential – NTPoly","text":"public  subroutine ComputeDenseExponential(InputMat, OutputMat, solver_parameters_in) Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computedenseexponential.html"},{"title":"ComputeLogarithm – NTPoly","text":"public  subroutine ComputeLogarithm(InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computelogarithm.html"},{"title":"ComputeLogarithmTaylor – NTPoly","text":"public  subroutine ComputeLogarithmTaylor(InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix using a taylor series expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computelogarithmtaylor.html"},{"title":"ComputeDenseLogarithm – NTPoly","text":"public  subroutine ComputeDenseLogarithm(InputMat, OutputMat, solver_parameters_in) Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/computedenselogarithm.html"},{"title":"ConstructDefaultPermutation – NTPoly","text":"public  subroutine ConstructDefaultPermutation(this, matrix_dimension) Constructs a permutation that preserves the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: matrix_dimension The dimension of the matrix. Contents","tags":"","loc":"proc/constructdefaultpermutation.html"},{"title":"ConstructReversePermutation – NTPoly","text":"public  subroutine ConstructReversePermutation(this, matrix_dimension) Constructs a permutation that reverses the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. Contents","tags":"","loc":"proc/constructreversepermutation.html"},{"title":"ConstructRandomPermutation – NTPoly","text":"public  subroutine ConstructRandomPermutation(this, matrix_dimension, process_grid_in) Constructs a permutation that has a random order.\nImplements Knuth shuffle. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\nThis is to synchronize random number across processes. Contents","tags":"","loc":"proc/constructrandompermutation.html"},{"title":"ConstructLimitedRandomPermutation – NTPoly","text":"public  subroutine ConstructLimitedRandomPermutation(this, actual_matrix_dimension, logical_matrix_dimension, process_grid_in) Constructs a permutation that has a random order, but there is no\npermutation from beyond the actual matrix dimension. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: actual_matrix_dimension Actual size of the matrix. integer, intent(in) :: logical_matrix_dimension Padded size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\nThis is to synchronize random number across processes. Contents","tags":"","loc":"proc/constructlimitedrandompermutation.html"},{"title":"CopyPermutation – NTPoly","text":"public  subroutine CopyPermutation(permA, permB) Copy one permutation to another in a safe way. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(in) :: permA Permutation to copy type( Permutation_t ), intent(inout) :: permB permB = permA Contents","tags":"","loc":"proc/copypermutation.html"},{"title":"DestructPermutation – NTPoly","text":"public pure subroutine DestructPermutation(this) Destruct a permutation object. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to destruct. Contents","tags":"","loc":"proc/destructpermutation.html"},{"title":"CGSolver – NTPoly","text":"public  subroutine CGSolver(AMat, XMat, BMat, solver_parameters_in) Solve the matrix equation AX = B using the conjugate gradient method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: XMat The solved for matrix X. type( Matrix_ps ), intent(in) :: BMat The right hand side. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/cgsolver.html"},{"title":"CholeskyDecomposition – NTPoly","text":"public  subroutine CholeskyDecomposition(AMat, LMat, solver_parameters_in) Compute The Cholesky Decomposition of a Hermitian Positive Definite matrix.\nThis is a really naive implementation, that might be worth revisiting. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: LMat The lower diagonal matrix computed. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/choleskydecomposition.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_horner Module Procedures private pure subroutine ConstructPolynomial_horner(this, degree) Construct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial.","tags":"","loc":"interface/constructpolynomial~2.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_horner Module Procedures private pure subroutine DestructPolynomial_horner(this) Destruct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial~2.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_horner Module Procedures private  subroutine SetCoefficient_horner(this, degree, coefficient) Set a coefficient of a Hermite polynomial. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree The degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value to set.","tags":"","loc":"interface/setcoefficient~2.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_horner Module Procedures private  subroutine Compute_horner(InputMat, OutputMat, poly, solver_parameters_in) Compute The Hermite Polynomial of the matrix.\nThis method uses the standard Hermite Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix. type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( HermitePolynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"interface/compute~2.html"},{"title":"ConstructRankLookup – NTPoly","text":"public  subroutine ConstructRankLookup(AMat, process_grid, col_root_lookup) Construct a lookup for columns Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat Matrix we are computing. type( ProcessGrid_t ), intent(inout) :: process_grid Grid we are computing along. integer, intent(inout), DIMENSION(:) :: col_root_lookup The lookup we are computing. Contents","tags":"","loc":"proc/constructranklookup.html"},{"title":"AppendToVector – NTPoly","text":"public interface AppendToVector Contents Module Procedures AppendToVector_r Module Procedures private pure subroutine AppendToVector_r(values_per, indices, values, insert_row, insert_value) A helper routine to insert a value into a sparse vector. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: values_per Values per row. integer, intent(inout), DIMENSION(:) :: indices Indices associated with each value. real(kind=NTREAL), intent(inout), DIMENSION(:) :: values Values. integer, intent(in) :: insert_row Row to insert into. real(kind=NTREAL), intent(in) :: insert_value Value to insert.","tags":"","loc":"interface/appendtovector.html"},{"title":"BroadcastVector – NTPoly","text":"public interface BroadcastVector Contents Module Procedures BroadcastVector_r Module Procedures private  subroutine BroadcastVector_r(num_values, indices, values, root, comm) A helper routine to broadcast a sparse vector Arguments Type Intent Optional Attributes Name integer, intent(inout) :: num_values Number of values we are broadcasting. integer, intent(inout), DIMENSION(:) :: indices Indices to broadcast. real(kind=NTREAL), intent(inout), DIMENSION(:) :: values Values to broadcast. integer, intent(in) :: root Root from which we broadcast. integer, intent(inout) :: comm Communicator to broadcast along.","tags":"","loc":"interface/broadcastvector.html"},{"title":"ConstructDiag – NTPoly","text":"public interface ConstructDiag Contents Module Procedures ConstructDiag_r Module Procedures private  subroutine ConstructDiag_r(AMat, process_grid, dense_a, diag) Construct the vector holding the accumulated diagonal values Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat AMat the matrix we are working on (for meta data). type( ProcessGrid_t ), intent(inout) :: process_grid The process grid we are operating on. type( Matrix_ldr ), intent(in) :: dense_a A dense representation of the values. real(kind=NTREAL), intent(inout), DIMENSION(:) :: diag Diagonal values computed.","tags":"","loc":"interface/constructdiag.html"},{"title":"DotAllHelper – NTPoly","text":"public interface DotAllHelper Contents Module Procedures DotAllHelper_r Module Procedures private  subroutine DotAllHelper_r(num_values_i, indices_i, values_i, num_values_j, indices_j, values_j, out_values, comm) Helper routine which computes sparse dot products across processors.\nComputes the dot product of one vector with several others. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_values_i The length of vector i. integer, intent(in), DIMENSION(:) :: indices_i The index value of the sparse vector i. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_i The values of the sparse vector i. integer, intent(in), DIMENSION(:) :: num_values_j Tn array with the length of vectors j. integer, intent(in), DIMENSION(:,:) :: indices_j The indices of the vectors j. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values_j The values of the vectors j. real(kind=NTREAL), intent(out), DIMENSION(:) :: out_values The dot product values for each vector j. integer, intent(inout) :: comm The communicator to reduce along.","tags":"","loc":"interface/dotallhelper.html"},{"title":"DotAllPivoted – NTPoly","text":"public interface DotAllPivoted Contents Module Procedures DotAllPivoted_r Module Procedures private  subroutine DotAllPivoted_r(num_values_i, indices_i, values_i, num_values_j, indices_j, values_j, pivot_vector, num_local_pivots, out_values, comm) Helper routine which computes sparse dot products across processors.\nComputes the dot product of one vector with several others.\nThe pivoted version has the number of local pivots to work on as a\nparameter. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_values_i The length of vector i. integer, intent(in), DIMENSION(:) :: indices_i The index value of the sparse vector i. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_i The values of the sparse vector i. integer, intent(in), DIMENSION(:) :: num_values_j Tn array with the length of vectors j. integer, intent(in), DIMENSION(:,:) :: indices_j The indices of the vectors j. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values_j The values of the vectors j. integer, intent(in), DIMENSION(:) :: pivot_vector Vector storing the pivot values. integer, intent(in) :: num_local_pivots Number of pivots. real(kind=NTREAL), intent(out), DIMENSION(:) :: out_values The dot product values for each vector j. integer, intent(inout) :: comm The communicator to reduce along.","tags":"","loc":"interface/dotallpivoted.html"},{"title":"GatherMatrixColumn – NTPoly","text":"public interface GatherMatrixColumn Contents Module Procedures GatherMatrixColumn_r Module Procedures private  subroutine GatherMatrixColumn_r(local_matrix, column_matrix, process_grid) A helper routine that gathers the matrices in the same column into one. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: local_matrix The local matrix on each process. type( Matrix_lsr ), intent(inout) :: column_matrix The final result. type( ProcessGrid_t ), intent(inout) :: process_grid The process grid to operate on.","tags":"","loc":"interface/gathermatrixcolumn.html"},{"title":"GetPivot – NTPoly","text":"public interface GetPivot Contents Module Procedures GetPivot_r Module Procedures private  subroutine GetPivot_r(AMat, process_grid, start_index, pivot_vector, diag, index, VALUE, local_pivots, num_local_pivots) Compute the pivot vector. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix we are working on. type( ProcessGrid_t ), intent(inout) :: process_grid The process grid to compute on. integer, intent(in) :: start_index The start index to look integer, intent(inout), DIMENSION(:) :: pivot_vector The current pivot vector. real(kind=NTREAL), intent(in), DIMENSION(:) :: diag The diagonal values. integer, intent(out) :: index The pivot index selected. real(kind=NTREAL), intent(out) :: VALUE The pivot value. integer, intent(inout), DIMENSION(:) :: local_pivots The local pivot values to modify. integer, intent(out) :: num_local_pivots Number of pivots stored locally.","tags":"","loc":"interface/getpivot.html"},{"title":"UnpackCholesky – NTPoly","text":"public interface UnpackCholesky Contents Module Procedures UnpackCholesky_r Module Procedures private  subroutine UnpackCholesky_r(values_per_column, index, values, LMat) Unpack to a global matrix. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: values_per_column The number of values in a column. integer, intent(in), DIMENSION(:,:) :: index Index values. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values Actual values. type( Matrix_ps ), intent(inout) :: LMat Matrix to unpack into.","tags":"","loc":"interface/unpackcholesky.html"},{"title":"EigenDecomposition – NTPoly","text":"public  subroutine EigenDecomposition(this, eigenvalues, eigenvectors_in, nvals_in, solver_parameters_in) Compute the eigendecomposition of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to decompose. type( Matrix_ps ), intent(inout) :: eigenvalues Diagonal matrix of eigenvalues. type( Matrix_ps ), intent(inout), optional :: eigenvectors_in The eigenvectors of a matrix. integer, intent(in), optional :: nvals_in The number of desired eigenvalues. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for computing Contents","tags":"","loc":"proc/eigendecomposition.html"},{"title":"DenseMatrixFunction – NTPoly","text":"public  subroutine DenseMatrixFunction(this, ResultMat, func, solver_parameters_in) Apply an arbitrary matrix function defined by a matrix map as a Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to apply the function to. type( Matrix_ps ), intent(inout) :: ResultMat The transformed matrix private  function func(val) result(outval) The procedure to apply to each eigenvalue. Arguments Type Intent Optional Attributes Name real(kind=NTREAL), intent(in) :: val The actual value of an element. Return Value real(kind=NTREAL) The transformed value. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for computing Contents","tags":"","loc":"proc/densematrixfunction.html"},{"title":"ScaleMatrix – NTPoly","text":"public interface ScaleMatrix Contents Module Procedures ScaleMatrix_lsr ScaleMatrix_lsc ScaleMatrix_lsc_c Module Procedures private pure subroutine ScaleMatrix_lsr(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private pure subroutine ScaleMatrix_lsc(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private pure subroutine ScaleMatrix_lsc_c(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. complex(kind=NTCOMPLEX), intent(in) :: constant Constant scale factor.","tags":"","loc":"interface/scalematrix.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_lsr IncrementMatrix_lsc Module Procedures private pure subroutine IncrementMatrix_lsr(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\nThis will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0). private pure subroutine IncrementMatrix_lsc(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\nThis will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0).","tags":"","loc":"interface/incrementmatrix.html"},{"title":"DotMatrix – NTPoly","text":"public interface DotMatrix Contents Module Procedures DotMatrix_lsr DotMatrix_lsc Module Procedures private pure subroutine DotMatrix_lsr(matA, matB, product) Product = sum(MatA[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product Dot product. private pure subroutine DotMatrix_lsc(matA, matB, product) Product = sum(MatA&#94;H[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product Dot product.","tags":"","loc":"interface/dotmatrix.html"},{"title":"PairwiseMultiplyMatrix – NTPoly","text":"public interface PairwiseMultiplyMatrix Contents Module Procedures PairwiseMultiplyMatrix_lsr PairwiseMultiplyMatrix_lsc Module Procedures private pure subroutine PairwiseMultiplyMatrix_lsr(matA, matB, matC) Pairwise Multiply two matrices.\nThis will utilize the sparse vector pairwise multiply routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = MatA mult MatB. private pure subroutine PairwiseMultiplyMatrix_lsc(matA, matB, matC) Pairwise Multiply two matrices.\nThis will utilize the sparse vector pairwise routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = MatA mult MatB.","tags":"","loc":"interface/pairwisemultiplymatrix.html"},{"title":"MatrixMultiply – NTPoly","text":"public interface MatrixMultiply Contents Module Procedures GemmMatrix_lsr GemmMatrix_lsc Module Procedures private  subroutine GemmMatrix_lsr(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lr ), intent(inout), optional, TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. private  subroutine GemmMatrix_lsc(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lc ), intent(inout), optional, TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation.","tags":"","loc":"interface/matrixmultiply.html"},{"title":"MatrixColumnNorm – NTPoly","text":"public interface MatrixColumnNorm Contents Module Procedures MatrixColumnNorm_lsr MatrixColumnNorm_lsc Module Procedures private pure subroutine MatrixColumnNorm_lsr(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. private pure subroutine MatrixColumnNorm_lsc(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix.","tags":"","loc":"interface/matrixcolumnnorm.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_lsr MatrixNorm_lsc Module Procedures private pure function MatrixNorm_lsr(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private pure function MatrixNorm_lsc(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix.","tags":"","loc":"interface/matrixnorm.html"},{"title":"MatrixGrandSum – NTPoly","text":"public interface MatrixGrandSum Contents Module Procedures MatrixGrandSum_lsr MatrixGrandSum_lsc Module Procedures private pure subroutine MatrixGrandSum_lsr(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to sum real(kind=NTREAL), intent(out) :: sum_value The sum of the matrix elements private pure subroutine MatrixGrandSum_lsc(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to sum complex(kind=NTCOMPLEX), intent(out) :: sum_value The sum of the matrix elements","tags":"","loc":"interface/matrixgrandsum.html"},{"title":"GershgorinBounds – NTPoly","text":"public  subroutine GershgorinBounds(this, min_value, max_value) Compute a bounds on the minimum and maximum eigenvalue of a matrix.\nUses the Gershgorin theorem. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: min_value A lower bound on the eigenspectrum. real(kind=NTREAL), intent(out) :: max_value An uppder bound on the eigenspectrum. Contents","tags":"","loc":"proc/gershgorinbounds.html"},{"title":"PowerBounds – NTPoly","text":"public  subroutine PowerBounds(this, max_value, solver_parameters_in) Compute a bounds on the maximum eigenvalue of a matrix.\nUses The Power Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: max_value An upper bound on the eigenspectrum. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The parameters for this calculation. Contents","tags":"","loc":"proc/powerbounds.html"},{"title":"ConstructPolynomial – NTPoly","text":"public interface ConstructPolynomial Contents Module Procedures ConstructPolynomial_stand Module Procedures private pure subroutine ConstructPolynomial_stand(this, degree) Construct a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial.","tags":"","loc":"interface/constructpolynomial~3.html"},{"title":"DestructPolynomial – NTPoly","text":"public interface DestructPolynomial Contents Module Procedures DestructPolynomial_stand Module Procedures private pure subroutine DestructPolynomial_stand(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to destruct.","tags":"","loc":"interface/destructpolynomial~3.html"},{"title":"SetCoefficient – NTPoly","text":"public interface SetCoefficient Contents Module Procedures SetCoefficient_stand Module Procedures private  subroutine SetCoefficient_stand(this, degree, coefficient) Set coefficient of a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value.","tags":"","loc":"interface/setcoefficient~3.html"},{"title":"Compute – NTPoly","text":"public interface Compute Contents Module Procedures Compute_stand Module Procedures private  subroutine Compute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using the method of Horner. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/compute~3.html"},{"title":"FactorizedCompute – NTPoly","text":"public interface FactorizedCompute Contents Module Procedures FactorizedCompute_stand Module Procedures private  subroutine FactorizedCompute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using The Paterson and Stockmeyer method.\nThis method first factors the polynomial to reduce the number of\nmatrix multiplies required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly The polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"interface/factorizedcompute~2.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrixSup_ldr ConstructEmptyMatrixSup_ldc Module Procedures private pure subroutine ConstructEmptyMatrixSup_ldr(this, rows, columns) A subroutine wrapper for the empty constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to construct integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix private pure subroutine ConstructEmptyMatrixSup_ldc(this, rows, columns) A subroutine style wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of rows of the matrix. integer, intent(in) :: columns The number of columns o the matrix.","tags":"","loc":"interface/constructemptymatrix~2.html"},{"title":"ConstructMatrixDFromS – NTPoly","text":"public interface ConstructMatrixDFromS Contents Module Procedures ConstructMatrixDFromS_ldr ConstructMatrixDFromS_ldc Module Procedures private pure subroutine ConstructMatrixDFromS_ldr(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldr ), intent(inout) :: dense_matrix Output. Must be preallocated. private pure subroutine ConstructMatrixDFromS_ldc(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldc ), intent(inout) :: dense_matrix Dense matrix output. Must be preallocated.","tags":"","loc":"interface/constructmatrixdfroms.html"},{"title":"ConstructMatrixSFromD – NTPoly","text":"public interface ConstructMatrixSFromD Contents Module Procedures ConstructMatrixSFromD_ldr ConstructMatrixSFromD_ldc Module Procedures private pure subroutine ConstructMatrixSFromD_ldr(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: dense_matrix Matrix to convert. type( Matrix_lsr ), intent(inout) :: sparse_matrix Output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. private pure subroutine ConstructMatrixSFromD_ldc(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: dense_matrix The matrix to convert. type( Matrix_lsc ), intent(inout) :: sparse_matrix The sparse output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero.","tags":"","loc":"interface/constructmatrixsfromd.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_ldr CopyMatrix_ldc Module Procedures private pure subroutine CopyMatrix_ldr(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA The matrix to copy. type( Matrix_ldr ), intent(inout) :: matB matB = matA private pure subroutine CopyMatrix_ldc(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to copy. type( Matrix_ldc ), intent(inout) :: matB matB = matA","tags":"","loc":"interface/copymatrix~2.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_ldr DestructMatrix_ldc Module Procedures private pure subroutine DestructMatrix_ldr(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to delete. private pure subroutine DestructMatrix_ldc(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this This the matrix to delete.","tags":"","loc":"interface/destructmatrix~2.html"},{"title":"SplitMatrix – NTPoly","text":"public interface SplitMatrix Contents Module Procedures SplitMatrix_ldr SplitMatrix_ldc Module Procedures private pure subroutine SplitMatrix_ldr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldr ), intent(inout), DIMENSION(:,:) :: split_array A block_columns x block_rows array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private pure subroutine SplitMatrix_ldc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns.","tags":"","loc":"interface/splitmatrix~2.html"},{"title":"ComposeMatrix – NTPoly","text":"public interface ComposeMatrix Contents Module Procedures ComposeMatrix_ldr ComposeMatrix_ldc Module Procedures private pure subroutine ComposeMatrix_ldr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldr ), intent(inout) :: out_matrix The composed matrix. private pure subroutine ComposeMatrix_ldc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldc ), intent(inout) :: out_matrix The composed matrix.","tags":"","loc":"interface/composematrix~2.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_ldr MatrixNorm_ldc Module Procedures private  function MatrixNorm_ldr(this) result(norm) Compute the norm of a dense matrix.\nComputes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private  function MatrixNorm_ldc(this) result(norm) Compute the norm of a dense matrix.\nComputes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix.","tags":"","loc":"interface/matrixnorm~2.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_ldr IncrementMatrix_ldc Module Procedures private pure subroutine IncrementMatrix_ldr(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA is added type( Matrix_ldr ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. private pure subroutine IncrementMatrix_ldc(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA MatA is added type( Matrix_ldc ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter.","tags":"","loc":"interface/incrementmatrix~2.html"},{"title":"MultiplyMatrix – NTPoly","text":"public interface MultiplyMatrix Contents Module Procedures MultiplyMatrix_ldr MultiplyMatrix_ldc Module Procedures private  subroutine MultiplyMatrix_ldr(MatA, MatB, MatC, IsATransposed_in, IsBTransposed_in) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA The first matrix. type( Matrix_ldr ), intent(in) :: MatB The second matrix. type( Matrix_ldr ), intent(inout) :: MatC MatC = MatA*MatB. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. private  subroutine MultiplyMatrix_ldc(MatA, MatB, MatC, IsATransposed_in, IsBTransposed_in) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The first matrix. type( Matrix_ldc ), intent(in) :: MatB The second matrix. type( Matrix_ldc ), intent(inout) :: MatC MatC = MatA*MatB. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed.","tags":"","loc":"interface/multiplymatrix.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_ldr TransposeMatrix_ldc Module Procedures private pure subroutine TransposeMatrix_ldr(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA matA the matrix to transpose. type( Matrix_ldr ), intent(inout) :: matAT matAT = matA&#94;T. private pure subroutine TransposeMatrix_ldc(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to transpose. type( Matrix_ldc ), intent(inout) :: matAT matAT = matA&#94;T.","tags":"","loc":"interface/transposematrix~2.html"},{"title":"EigenDecomposition – NTPoly","text":"public interface EigenDecomposition Contents Module Procedures EigenDecomposition_ldr EigenDecomposition_ldc Module Procedures private  subroutine EigenDecomposition_ldr(MatA, MatV, MatW) Compute the eigenvectors of a dense matrix.\nWraps a standard dense linear algebra routine. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA the matrix to decompose. type( Matrix_ldr ), intent(inout) :: MatV The eigenvectors. type( Matrix_ldr ), intent(inout), optional :: MatW The eigenvalues. private  subroutine EigenDecomposition_ldc(MatA, MatV, MatW) Compute the eigenvectors of a dense matrix.\nWraps a standard dense linear algebra routine. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The matrix to decompose. type( Matrix_ldc ), intent(inout) :: MatV The eigenvectors. type( Matrix_ldc ), intent(inout), optional :: MatW The eigenvalues.","tags":"","loc":"interface/eigendecomposition.html"},{"title":"ParseMMHeader – NTPoly","text":"public  function ParseMMHeader(line, sparsity_type, data_type, pattern_type) result(no_error) Parse a matrix market header. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line String to parse. integer, intent(out) :: sparsity_type If coordinate or array type. integer, intent(out) :: data_type If real, integer, complex, pattern. integer, intent(out) :: pattern_type If general, symmetric, skew_symmetric, hermitian. Return Value logical True if no errors. Contents","tags":"","loc":"proc/parsemmheader.html"},{"title":"WriteMMSize – NTPoly","text":"public pure subroutine WriteMMSize(outstring, rows, columns, values_in) Write the line describing the size of the matrix Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: rows The number of rows of the matrix integer, intent(in) :: columns The number of columns of the matrix integer(kind=NTLONG), intent(in), optional :: values_in The total number of non zero values in the matrix (for sparse format). Contents","tags":"","loc":"proc/writemmsize.html"},{"title":"WriteMMLine_ii – NTPoly","text":"public pure subroutine WriteMMLine_ii(outstring, row, column, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Contents","tags":"","loc":"proc/writemmline_ii.html"},{"title":"WriteMMLine_iif – NTPoly","text":"public pure subroutine WriteMMLine_iif(outstring, row, column, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Contents","tags":"","loc":"proc/writemmline_iif.html"},{"title":"WriteMMLine_iiff – NTPoly","text":"public pure subroutine WriteMMLine_iiff(outstring, row, column, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at the coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Contents","tags":"","loc":"proc/writemmline_iiff.html"},{"title":"WriteMMLine_f – NTPoly","text":"public pure subroutine WriteMMLine_f(outstring, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Contents","tags":"","loc":"proc/writemmline_f.html"},{"title":"WriteMMLine_ff – NTPoly","text":"public pure subroutine WriteMMLine_ff(outstring, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Contents","tags":"","loc":"proc/writemmline_ff.html"},{"title":"WriteMMLine – NTPoly","text":"public interface WriteMMLine Contents Module Procedures WriteMMLine_ii WriteMMLine_iif WriteMMLine_iiff WriteMMLine_f WriteMMLine_ff Module Procedures public pure subroutine WriteMMLine_ii (outstring, row, column, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iif (outstring, row, column, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iiff (outstring, row, column, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at the coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_f (outstring, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_ff (outstring, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.)","tags":"","loc":"interface/writemmline.html"},{"title":"SnapMatrixToSparsityPattern – NTPoly","text":"public  subroutine SnapMatrixToSparsityPattern(mat, pattern) Some codes use a fixed sparsity pattern for a matrix instead of filtering\nsmall values. Using this routine, the matrix is filled to have the same\npattern as the second matrix argument. Zeros of the sparsity pattern are\nleft in, whereas values outside the sparsity are removed. This can \nfaciliate conversion between formats. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: mat The matrix to modify. type( Matrix_ps ), intent(in) :: pattern The matrix which defines the sparsity pattern. Contents","tags":"","loc":"proc/snapmatrixtosparsitypattern.html"},{"title":"IsIdentity – NTPoly","text":"public  function IsIdentity(this) result(is_identity) Determine if this is the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix being filled. Return Value logical Result stored here. Contents","tags":"","loc":"proc/isidentity.html"},{"title":"SetMatrixProcessGrid – NTPoly","text":"public  subroutine SetMatrixProcessGrid(this, grid) When you want to change the process grid of a matrix, you can call\nthis routine with the new process grid value. Data will be automatically\nredistributed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to set the grid of. type( ProcessGrid_t ), intent(in) :: grid The grid to set it to. Contents","tags":"","loc":"proc/setmatrixprocessgrid.html"},{"title":"GetMatrixSlice – NTPoly","text":"public  subroutine GetMatrixSlice(this, submatrix, start_row, end_row, start_column, end_column) Copy an arbitrary slice from a matrix into a new smaller matrix.\nNTPoly only works with square matrices, so if the number of rows and\ncolumns is different the matrix is resized to the maximum size. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( Matrix_ps ), intent(inout) :: submatrix The slice to fill. integer, intent(in) :: start_row The starting row to include in this matrix. integer, intent(in) :: end_row The ending row to include in this matrix. integer, intent(in) :: start_column The starting column to include in this matrix. integer, intent(in) :: end_column The last column to include in this matrix. Contents","tags":"","loc":"proc/getmatrixslice.html"},{"title":"ConvertMatrixToReal – NTPoly","text":"public  subroutine ConvertMatrixToReal(in, out) Converts the current matrix to a real type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Real version of the matrix. Contents","tags":"","loc":"proc/convertmatrixtoreal.html"},{"title":"ConvertMatrixToComplex – NTPoly","text":"public  subroutine ConvertMatrixToComplex(in, out) Converts the current matrix to a complex type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Complex version of the matrix. Contents","tags":"","loc":"proc/convertmatrixtocomplex.html"},{"title":"ResizeMatrix – NTPoly","text":"public  subroutine ResizeMatrix(this, new_size) Change the size of a matrix.\nIf the new size is smaller, then values outside that range are deleted.\nIF the new size is bigger, zero padding is applied.\nWarning: this requires a full data redistribution. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to resize. integer, intent(in) :: new_size The new size of the matrix. Contents","tags":"","loc":"proc/resizematrix.html"},{"title":"ConstructEmptyMatrix – NTPoly","text":"public interface ConstructEmptyMatrix Contents Module Procedures ConstructEmptyMatrix_ps ConstructEmptyMatrix_ps_cp Module Procedures private  subroutine ConstructEmptyMatrix_ps(this, matrix_dim, process_grid_in, is_complex_in) Construct an empty sparse, distributed, matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. integer, intent(in) :: matrix_dim The dimension of the full matrix. type( ProcessGrid_t ), intent(in), optional, TARGET :: process_grid_in A process grid to host the matrix. logical, intent(in), optional :: is_complex_in True if you want to use complex numbers. private  subroutine ConstructEmptyMatrix_ps_cp(this, reference_matrix) Construct an empty sparse, distributed, matrix using another matrix\nto determine the parameters. Note that no data is copied, the matrix\nwill be empty. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. type( Matrix_ps ), intent(in) :: reference_matrix The reference matrix to take parameters from.","tags":"","loc":"interface/constructemptymatrix~3.html"},{"title":"DestructMatrix – NTPoly","text":"public interface DestructMatrix Contents Module Procedures DestructMatrix_ps Module Procedures private pure subroutine DestructMatrix_ps(this) Destruct a distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to destruct.","tags":"","loc":"interface/destructmatrix~3.html"},{"title":"CopyMatrix – NTPoly","text":"public interface CopyMatrix Contents Module Procedures CopyMatrix_ps Module Procedures private  subroutine CopyMatrix_ps(matA, matB) Copy a distributed sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA The matrix to copy. type( Matrix_ps ), intent(inout) :: matB matB = matA.","tags":"","loc":"interface/copymatrix~3.html"},{"title":"ConstructMatrixFromMatrixMarket – NTPoly","text":"public interface ConstructMatrixFromMatrixMarket Contents Module Procedures ConstructMatrixFromMatrixMarket_ps Module Procedures private recursive subroutine ConstructMatrixFromMatrixMarket_ps(this, file_name, process_grid_in) Construct distributed sparse matrix from a matrix market file in parallel.\nRead \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on.","tags":"","loc":"interface/constructmatrixfrommatrixmarket.html"},{"title":"ConstructMatrixFromBinary – NTPoly","text":"public interface ConstructMatrixFromBinary Contents Module Procedures ConstructMatrixFromBinary_ps Module Procedures private recursive subroutine ConstructMatrixFromBinary_ps(this, file_name, process_grid_in) Construct a distributed sparse matrix from a binary file in parallel.\nFaster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on.","tags":"","loc":"interface/constructmatrixfrombinary.html"},{"title":"WriteMatrixToMatrixMarket – NTPoly","text":"public interface WriteMatrixToMatrixMarket Contents Module Procedures WriteMatrixToMatrixMarket_ps Module Procedures private  subroutine WriteMatrixToMatrixMarket_ps(this, file_name) Write a distributed sparse matrix to a matrix market file.\nRead \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to.","tags":"","loc":"interface/writematrixtomatrixmarket.html"},{"title":"WriteMatrixToBinary – NTPoly","text":"public interface WriteMatrixToBinary Contents Module Procedures WriteMatrixToBinary_ps Module Procedures private  subroutine WriteMatrixToBinary_ps(this, file_name) Save a distributed sparse matrix to a binary file.\nFaster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to.","tags":"","loc":"interface/writematrixtobinary.html"},{"title":"FillMatrixFromTripletList – NTPoly","text":"public interface FillMatrixFromTripletList Contents Module Procedures FillMatrixFromTripletList_psr FillMatrixFromTripletList_psc Module Procedures private  subroutine FillMatrixFromTripletList_psr(this, triplet_list, preduplicated_in, prepartitioned_in) This routine fills in a matrix based on local triplet lists. Each process\nshould pass in triplet lists with global coordinates. It does not matter\nwhere each triplet is stored, as long as global coordinates are given.\nHowever, if you explicitly set prepartitioned_in to True, all data must be\non the correct process. In that case, there is no communication required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to fill. type( TripletList_r ), intent(in) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. logical, intent(in), optional :: prepartitioned_in If all lists only contain local matrix elements set this to true. private  subroutine FillMatrixFromTripletList_psc(this, triplet_list, preduplicated_in, prepartitioned_in) This routine fills in a matrix based on local triplet lists. Each process\nshould pass in triplet lists with global coordinates. It does not matter\nwhere each triplet is stored, as long as global coordinates are given.\nHowever, if you explicitly set prepartitioned_in to True, all data must be\non the correct process. In that case, there is no communication required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to fill. type( TripletList_c ), intent(in) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. logical, intent(in), optional :: prepartitioned_in If all lists only contain local matrix elements set this to true.","tags":"","loc":"interface/fillmatrixfromtripletlist.html"},{"title":"FillMatrixIdentity – NTPoly","text":"public interface FillMatrixIdentity Contents Module Procedures FillMatrixIdentity_ps Module Procedures private  subroutine FillMatrixIdentity_ps(this) Fill in the values of a distributed matrix with the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled.","tags":"","loc":"interface/fillmatrixidentity.html"},{"title":"FillMatrixPermutation – NTPoly","text":"public interface FillMatrixPermutation Contents Module Procedures FillMatrixPermutation_ps Module Procedures private  subroutine FillMatrixPermutation_ps(this, permutation_vector, permute_rows_in) Fill in the values of a distributed matrix with a permutation.\nIf you do not specify permuterows, will default to permuting rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. integer, intent(in), DIMENSION(:) :: permutation_vector Describes for each row/column, where it goes. logical, intent(in), optional :: permute_rows_in If true permute rows, false permute columns.","tags":"","loc":"interface/fillmatrixpermutation.html"},{"title":"FillMatrixDense – NTPoly","text":"public interface FillMatrixDense Contents Module Procedures FillMatrixDense_ps Module Procedures private  subroutine FillMatrixDense_ps(this) This routine will fill a dense matrix so that every element has a given Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled.","tags":"","loc":"interface/fillmatrixdense.html"},{"title":"GetMatrixActualDimension – NTPoly","text":"public interface GetMatrixActualDimension Contents Module Procedures GetMatrixActualDimension_ps Module Procedures private pure function GetMatrixActualDimension_ps(this) result(DIMENSION) Get the actual dimension of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix","tags":"","loc":"interface/getmatrixactualdimension.html"},{"title":"GetMatrixLogicalDimension – NTPoly","text":"public interface GetMatrixLogicalDimension Contents Module Procedures GetMatrixLogicalDimension_ps Module Procedures private pure function GetMatrixLogicalDimension_ps(this) result(DIMENSION) Get the logical dimension of the matrix.\nIncludes padding. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix","tags":"","loc":"interface/getmatrixlogicaldimension.html"},{"title":"GetMatrixTripletList – NTPoly","text":"public interface GetMatrixTripletList Contents Module Procedures GetMatrixTripletList_psr GetMatrixTripletList_psc Module Procedures private  subroutine GetMatrixTripletList_psr(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. private  subroutine GetMatrixTripletList_psc(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill.","tags":"","loc":"interface/getmatrixtripletlist.html"},{"title":"GetMatrixBlock – NTPoly","text":"public interface GetMatrixBlock Contents Module Procedures GetMatrixBlock_psr GetMatrixBlock_psc Module Procedures private  subroutine GetMatrixBlock_psr(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\ndefined by the row/column start/end values.\nThis is slower than GetMatrixTripletList, because communication is required\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. integer, intent(in) :: start_row The starting row for data to store on this process. integer, intent(in) :: end_row The ending row for data to store on this process. integer, intent(in) :: start_column The starting col for data to store on this process integer, intent(in) :: end_column The ending col for data to store on this process private  subroutine GetMatrixBlock_psc(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\ndefined by the row/column start/end values.\nThis is slower than GetMatrixTripletList, because communication is required\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. integer, intent(in) :: start_row The starting row for data to store on this process. integer, intent(in) :: end_row The ending row for data to store on this process. integer, intent(in) :: start_column The starting col for data to store on this process integer, intent(in) :: end_column The ending col for data to store on this process","tags":"","loc":"interface/getmatrixblock.html"},{"title":"PrintMatrix – NTPoly","text":"public interface PrintMatrix Contents Module Procedures PrintMatrix_ps Module Procedures private  subroutine PrintMatrix_ps(this, file_name_in) Print out a distributed sparse matrix.\nThis is a serial print routine, and should probably only be used for debug\npurposes. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to print. character(len=*), intent(in), optional :: file_name_in Optionally, you can pass a file to print to instead of the console.","tags":"","loc":"interface/printmatrix~2.html"},{"title":"PrintMatrixInformation – NTPoly","text":"public interface PrintMatrixInformation Contents Module Procedures PrintMatrixInformation_ps Module Procedures private  subroutine PrintMatrixInformation_ps(this) Print out information about a distributed sparse matrix.\nSparsity, and load balancing information. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this This the matrix to print information about.","tags":"","loc":"interface/printmatrixinformation.html"},{"title":"GetMatrixLoadBalance – NTPoly","text":"public interface GetMatrixLoadBalance Contents Module Procedures GetMatrixLoadBalance_ps Module Procedures private  subroutine GetMatrixLoadBalance_ps(this, min_size, max_size) Get a measure of how load balanced this matrix is. For each process, the\nnumber of non-zero entries is calculated. Then, this function returns\nthe max and min of those values. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the measure on. integer, intent(out) :: min_size The minimum entries contained on a single process. integer, intent(out) :: max_size The maximum entries contained on a single process.","tags":"","loc":"interface/getmatrixloadbalance.html"},{"title":"GetMatrixSize – NTPoly","text":"public interface GetMatrixSize Contents Module Procedures GetMatrixSize_ps Module Procedures private  function GetMatrixSize_ps(this) result(total_size) Get the total number of non-zero entries in the distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to calculate the number of non-zero entries of. Return Value integer(kind=NTLONG) The number of non-zero entries in the matrix.","tags":"","loc":"interface/getmatrixsize.html"},{"title":"FilterMatrix – NTPoly","text":"public interface FilterMatrix Contents Module Procedures FilterMatrix_ps Module Procedures private  subroutine FilterMatrix_ps(this, threshold) A utility routine that filters a sparse matrix.\nAll (absolute) values below the threshold are set to zero. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to filter. real(kind=NTREAL), intent(in) :: threshold Threshold (absolute) values below this are filtered","tags":"","loc":"interface/filtermatrix.html"},{"title":"MergeMatrixLocalBlocks – NTPoly","text":"public interface MergeMatrixLocalBlocks Contents Module Procedures MergeMatrixLocalBlocks_psr MergeMatrixLocalBlocks_psc Module Procedures private pure subroutine MergeMatrixLocalBlocks_psr(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsr ), intent(inout) :: merged_matrix The merged matrix. private pure subroutine MergeMatrixLocalBlocks_psc(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsc ), intent(inout) :: merged_matrix The merged matrix.","tags":"","loc":"interface/mergematrixlocalblocks.html"},{"title":"SplitMatrixToLocalBlocks – NTPoly","text":"public interface SplitMatrixToLocalBlocks Contents Module Procedures SplitMatrixToLocalBlocks_psr SplitMatrixToLocalBlocks_psc Module Procedures private pure subroutine SplitMatrixToLocalBlocks_psr(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsr ), intent(in) :: matrix_to_split The matrix to split up. private pure subroutine SplitMatrixToLocalBlocks_psc(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsc ), intent(in) :: matrix_to_split The matrix to split up.","tags":"","loc":"interface/splitmatrixtolocalblocks.html"},{"title":"TransposeMatrix – NTPoly","text":"public interface TransposeMatrix Contents Module Procedures TransposeMatrix_ps Module Procedures private  subroutine TransposeMatrix_ps(AMat, TransMat) Transpose a sparse matrix. Note that this is a pure transpose, there is\nno complex conjugate performed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix to transpose. type( Matrix_ps ), intent(inout) :: TransMat TransMat = A&#94;T .","tags":"","loc":"interface/transposematrix~3.html"},{"title":"ConjugateMatrix – NTPoly","text":"public interface ConjugateMatrix Contents Module Procedures ConjugateMatrix_ps Module Procedures private pure subroutine ConjugateMatrix_ps(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to compute the complex conjugate of.","tags":"","loc":"interface/conjugatematrix~2.html"},{"title":"CommSplitMatrix – NTPoly","text":"public interface CommSplitMatrix Contents Module Procedures CommSplitMatrix_ps Module Procedures private  subroutine CommSplitMatrix_ps(this, split_mat, my_color, split_slice) Split the current communicator, and give each group a complete copy of this Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to split. type( Matrix_ps ), intent(inout) :: split_mat A copy of the matrix hosted on a small process grid. integer, intent(out) :: my_color Distinguishes between the two groups. logical, intent(out) :: split_slice If we split along the slice direction, this is True","tags":"","loc":"interface/commsplitmatrix.html"},{"title":"GatherMatrixToProcess – NTPoly","text":"public interface GatherMatrixToProcess Contents Module Procedures GatherMatrixToProcess_psr_id GatherMatrixToProcess_psr_all GatherMatrixToProcess_psc_id GatherMatrixToProcess_psc_all Module Procedures private  subroutine GatherMatrixToProcess_psr_id(this, local_mat, within_slice_id) This subroutine gathers the entire matrix into a local matrix on the\ngiven process. The process id is a within_slice id, so the data will\nstill be replicated across slices. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: within_slice_id Which process to gather on. private  subroutine GatherMatrixToProcess_psr_all(this, local_mat) This subroutine gathers the entire matrix into a local matrix on to\nevery process. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. private  subroutine GatherMatrixToProcess_psc_id(this, local_mat, within_slice_id) This subroutine gathers the entire matrix into a local matrix on the\ngiven process. The process id is a within_slice id, so the data will\nstill be replicated across slices. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: within_slice_id Which process to gather on. private  subroutine GatherMatrixToProcess_psc_all(this, local_mat) This subroutine gathers the entire matrix into a local matrix on to\nevery process. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix.","tags":"","loc":"interface/gathermatrixtoprocess.html"},{"title":"SignFunction – NTPoly","text":"public  subroutine SignFunction(InMat, OutMat, solver_parameters_in) Computes the matrix sign function. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The input matrix. type( Matrix_ps ), intent(inout) :: OutMat The sign of Mat. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents","tags":"","loc":"proc/signfunction.html"},{"title":"DenseSignFunction – NTPoly","text":"public  subroutine DenseSignFunction(InMat, OutputMat, solver_parameters_in) Computes the matrix sign function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The matrix to compute the sign of. type( Matrix_ps ), intent(inout) :: OutputMat The sign of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/densesignfunction.html"},{"title":"PolarDecomposition – NTPoly","text":"public  subroutine PolarDecomposition(InMat, Umat, Hmat, solver_parameters_in) Computes the polar decomposition of a matrix Mat = U*H. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The input matrix. type( Matrix_ps ), intent(inout) :: Umat The unitary polar factor. type( Matrix_ps ), intent(inout), optional :: Hmat The hermitian matrix factor. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Contents","tags":"","loc":"proc/polardecomposition.html"},{"title":"PurificationExtrapolate – NTPoly","text":"public  subroutine PurificationExtrapolate(PreviousDensity, Overlap, trace, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\nBased on the purification algorithm in \\cite niklasson2010trace . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity Previous density to extrapolate from. type( Matrix_ps ), intent(in) :: Overlap The overlap matrix of the new geometry. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons). type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/purificationextrapolate.html"},{"title":"LowdinExtrapolate – NTPoly","text":"public  subroutine LowdinExtrapolate(PreviousDensity, OldOverlap, NewOverlap, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\nBased on the lowdin algorithm in \\cite exner2002comparison . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity THe previous density to extrapolate from. type( Matrix_ps ), intent(in) :: OldOverlap The old overlap matrix from the previous geometry. type( Matrix_ps ), intent(in) :: NewOverlap The new overlap matrix from the current geometry. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/lowdinextrapolate.html"},{"title":"IsRoot – NTPoly","text":"public  function IsRoot(grid_in) result(is_root) Check if the current process is the root process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid_in The process grid. Return Value logical True if the current process is root. Contents","tags":"","loc":"proc/isroot.html"},{"title":"GetMySlice – NTPoly","text":"public  function GetMySlice(grid) result(return_val) Get the slice of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer Slice number of the current process. Contents","tags":"","loc":"proc/getmyslice.html"},{"title":"GetMyColumn – NTPoly","text":"public  function GetMyColumn(grid) result(return_val) Get the column of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The column number of the current process. Contents","tags":"","loc":"proc/getmycolumn.html"},{"title":"GetMyRow – NTPoly","text":"public  function GetMyRow(grid) result(return_val) Get the row of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The row number of the current process. Contents","tags":"","loc":"proc/getmyrow.html"},{"title":"CopyProcessGrid – NTPoly","text":"public  subroutine CopyProcessGrid(old_grid, new_grid) Copy a process grid.\nNote that this makes a complete and independent copy of the process grid.\nWhich of course means that whatever is currently stored in new_grid will\nbe destroyed, so do not leave any matrices pointing to it. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: old_grid The grid to copy. type( ProcessGrid_t ), intent(inout) :: new_grid New_grid = old_grid Contents","tags":"","loc":"proc/copyprocessgrid.html"},{"title":"DestructProcessGrid – NTPoly","text":"public recursive subroutine DestructProcessGrid(grid_in) Destruct a process grid.\nBe careful about doing this. Matrices have pointers to process grids. If\nyou destruct a process grid without destructing the matrices pointing to\nit, they will become unusable. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout), optional :: grid_in The grid to destruct. If none specified this destroys the global grid. Contents","tags":"","loc":"proc/destructprocessgrid.html"},{"title":"SplitProcessGrid – NTPoly","text":"public  subroutine SplitProcessGrid(old_grid, new_grid, my_color, split_slice, between_grid_comm) Given a process grid, this splits it into two grids of even size Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: old_grid The old grid to split type( ProcessGrid_t ), intent(inout) :: new_grid The new grid that we are creating integer, intent(out) :: my_color A color value indicating which set this process was split into logical, intent(out) :: split_slice True if we were able to split along slices. integer, intent(out) :: between_grid_comm A communicator for sending messages between groups. Contents","tags":"","loc":"proc/splitprocessgrid.html"},{"title":"ComputeGridSize – NTPoly","text":"public  subroutine ComputeGridSize(total_processors, set_slices, rows, columns) Sometimes we only want to specify for a process grid the number of slices\nand then automatically compute the right number of rows and columns. Arguments Type Intent Optional Attributes Name integer, intent(in) :: total_processors Total processors in the grid integer, intent(in) :: set_slices Desired number of slices integer, intent(out) :: rows Computed number of rows integer, intent(out) :: columns Computed number of columns Contents","tags":"","loc":"proc/computegridsize.html"},{"title":"WriteProcessGridInfo – NTPoly","text":"public recursive subroutine WriteProcessGridInfo(this) Write out some basic information about this process grid to the log. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: this The grid to print about. If not specified, global information printed. Contents","tags":"","loc":"proc/writeprocessgridinfo.html"},{"title":"ConstructProcessGrid – NTPoly","text":"public interface ConstructProcessGrid Contents Module Procedures ConstructProcessGrid_full ConstructProcessGrid_onlyslice Module Procedures private  subroutine ConstructProcessGrid_full(world_comm, process_rows, process_columns, process_slices, be_verbose_in) Setup the default process grid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in) :: process_rows The number of grid rows. integer, intent(in) :: process_columns The number of grid columns. integer, intent(in) :: process_slices The number of grid slices. logical, intent(in), optional :: be_verbose_in Set true to print process grid info. private  subroutine ConstructProcessGrid_onlyslice(world_comm, process_slices_in, be_verbose_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in), optional :: process_slices_in The number of grid slices. logical, intent(in), optional :: be_verbose_in Set true to print process grid info.","tags":"","loc":"interface/constructprocessgrid.html"},{"title":"ConstructNewProcessGrid – NTPoly","text":"public interface ConstructNewProcessGrid Contents Module Procedures ConstructNewProcessGrid_full ConstructNewProcessGrid_onlyslice Module Procedures private  subroutine ConstructNewProcessGrid_full(grid, world_comm, process_rows, process_columns, process_slices) Construct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in) :: process_rows The number of grid rows. integer, intent(in) :: process_columns The number of grid columns. integer, intent(in) :: process_slices The number of grid slices. private  subroutine ConstructNewProcessGrid_onlyslice(grid, world_comm, process_slices_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in), optional :: process_slices_in The number of grid slices.","tags":"","loc":"interface/constructnewprocessgrid.html"},{"title":"GetMPITripletType_r – NTPoly","text":"public  function GetMPITripletType_r() result(mpi_triplet_type) Returns an MPI derived data type for a triplet (Real).\nWe statically store this derived type so that we do not have to recreate\nit every time this function is called. Thus this functional call should\nadd very little overhead. Arguments None Return Value integer MPI Derived Type Contents None","tags":"","loc":"proc/getmpitriplettype_r.html"},{"title":"GetMPITripletType_c – NTPoly","text":"public  function GetMPITripletType_c() result(mpi_triplet_type) Returns an MPI derived data type for a triplet (complex).\nWe statically store this derived type so that we do not have to recreate\nit every time this function is called. Thus this functional call should\nadd very little overhead. Arguments None Return Value integer MPI Derived Type Contents None","tags":"","loc":"proc/getmpitriplettype_c.html"},{"title":"SetTriplet – NTPoly","text":"public interface SetTriplet Contents Module Procedures SetTriplet_r SetTriplet_c Module Procedures private pure subroutine SetTriplet_r(this, index_column, index_row, point_value) Set the values of a triplet (real). Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. real(kind=NTREAL), intent(in) :: point_value The value at that point. private pure subroutine SetTriplet_c(this, index_column, index_row, point_value) Set the values of a triplet (complex). Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. complex(kind=NTCOMPLEX), intent(in) :: point_value The value at that point.","tags":"","loc":"interface/settriplet.html"},{"title":"GetTripletValues – NTPoly","text":"public interface GetTripletValues Contents Module Procedures GetTripletValues_r GetTripletValues_c Module Procedures private pure subroutine GetTripletValues_r(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. real(kind=NTREAL), intent(out) :: point_value Actual stored value. private pure subroutine GetTripletValues_c(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. complex(kind=NTCOMPLEX), intent(out) :: point_value Actual stored value.","tags":"","loc":"interface/gettripletvalues.html"},{"title":"CompareTriplets – NTPoly","text":"public interface CompareTriplets Contents Module Procedures CompareTriplets_r CompareTriplets_c Module Procedures private pure function CompareTriplets_r(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\nsecond by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: tripA First triplet. type( Triplet_r ), intent(in) :: tripB Second triplet. Return Value logical A < B. private pure function CompareTriplets_c(tripA, tripB) result(islessthan) Compare two triplets based on their index values (complex), first by\ncolumn and second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: tripA First triplet. type( Triplet_c ), intent(in) :: tripB Second triplet. Return Value logical A < B.","tags":"","loc":"interface/comparetriplets.html"},{"title":"ConvertTripletType – NTPoly","text":"public interface ConvertTripletType Contents Module Procedures ConvertTripletToReal ConvertTripletToComplex Module Procedures private  subroutine ConvertTripletToReal(cin_triplet, rout_triplet) Convert a complex triplet to a real triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: cin_triplet The starting triplet type( Triplet_r ), intent(inout) :: rout_triplet Real valued triplet. private  subroutine ConvertTripletToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: rin_triplet The starting triplet. type( Triplet_c ), intent(inout) :: cout_triplet Complex valued triplet.","tags":"","loc":"interface/converttriplettype.html"},{"title":"IsLoggerActive – NTPoly","text":"public  function IsLoggerActive() result(active) Check if the logger is currently active Arguments None Return Value logical Contents None","tags":"","loc":"proc/isloggeractive.html"},{"title":"GetLoggerLevel – NTPoly","text":"public  function GetLoggerLevel() result(level) Get the current logging level Arguments None Return Value integer Contents None","tags":"","loc":"proc/getloggerlevel.html"},{"title":"ActivateLogger – NTPoly","text":"public  subroutine ActivateLogger(start_document_in, file_name_in, unit_in) Activate the logger. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: start_document_in If this is a new document we can write the start document marker. character(len=*), intent(in), optional :: file_name_in An optional file name for writing to. integer, intent(in), optional :: unit_in An optional fortran i/o unit override. Contents","tags":"","loc":"proc/activatelogger.html"},{"title":"DeactivateLogger – NTPoly","text":"public  subroutine DeactivateLogger() Deactivate the logger. Arguments None Contents None","tags":"","loc":"proc/deactivatelogger.html"},{"title":"EnterSubLog – NTPoly","text":"public  subroutine EnterSubLog() Call this subroutine when you enter into a section with verbose output Arguments None Contents None","tags":"","loc":"proc/entersublog.html"},{"title":"ExitSubLog – NTPoly","text":"public  subroutine ExitSubLog() Call this subroutine when you exit a section with verbose output Arguments None Contents None","tags":"","loc":"proc/exitsublog.html"},{"title":"SetInitialOffset – NTPoly","text":"public  subroutine SetInitialOffset(offset) Set a manual initial offset spacing. Arguments Type Intent Optional Attributes Name integer, intent(in) :: offset Number of spaces to offset Contents","tags":"","loc":"proc/setinitialoffset.html"},{"title":"WriteHeader – NTPoly","text":"public  subroutine WriteHeader(header_value) Write out a header to the log. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_value The text of the header. Contents","tags":"","loc":"proc/writeheader.html"},{"title":"SetLoggerLevel – NTPoly","text":"public  subroutine SetLoggerLevel(level) Set the logging level manually Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Contents","tags":"","loc":"proc/setloggerlevel.html"},{"title":"WriteListElement – NTPoly","text":"public interface WriteListElement Contents Module Procedures WriteListElement_bool WriteListElement_float WriteListElement_int WriteListElement_string Module Procedures private  subroutine WriteListElement_bool(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: VALUE A bool value to write. private  subroutine WriteListElement_float(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: VALUE A float value to write. private  subroutine WriteListElement_int(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: VALUE An integer value to write. private  subroutine WriteListElement_string(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: VALUE A text value to write.","tags":"","loc":"interface/writelistelement.html"},{"title":"WriteElement – NTPoly","text":"public interface WriteElement Contents Module Procedures WriteElement_bool WriteElement_float WriteElement_int WriteElement_string Module Procedures private  subroutine WriteElement_bool(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: VALUE An integer value to write. private  subroutine WriteElement_float(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: VALUE A float value to write. private  subroutine WriteElement_int(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: VALUE An integer value to write. private  subroutine WriteElement_string(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: VALUE A text value to write.","tags":"","loc":"interface/writeelement.html"},{"title":"SimilarityTransform – NTPoly","text":"public  subroutine SimilarityTransform(A, P, PInv, ResMat, pool_in, threshold_in) Transform a matrix B = P * A * P&#94;-1 Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: A The matrix to transform type( Matrix_ps ), intent(in) :: P The left matrix. type( Matrix_ps ), intent(in) :: PInv The right matrix. type( Matrix_ps ), intent(inout) :: ResMat The computed matrix P * A * P&#94;-1 type( MatrixMemoryPool_p ), intent(inout), optional :: pool_in A matrix memory pool. real(kind=NTREAL), intent(in), optional :: threshold_in The threshold for removing small elements. Contents","tags":"","loc":"proc/similaritytransform.html"},{"title":"MatrixSigma – NTPoly","text":"public interface MatrixSigma Contents Module Procedures MatrixSigma_ps Module Procedures private  subroutine MatrixSigma_ps(this, sigma_value) Compute sigma for the inversion method.\nSee \\cite ozaki2001efficient for details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the sigma value of. real(kind=NTREAL), intent(out) :: sigma_value Sigma","tags":"","loc":"interface/matrixsigma.html"},{"title":"MatrixMultiply – NTPoly","text":"public interface MatrixMultiply Contents Module Procedures MatrixMultiply_ps Module Procedures private  subroutine MatrixMultiply_ps(matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA matB+ beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = alpha matA matB + beta*matC real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. type( MatrixMemoryPool_p ), intent(inout), optional :: memory_pool_in A memory pool for the calculation.","tags":"","loc":"interface/matrixmultiply~2.html"},{"title":"MatrixGrandSum – NTPoly","text":"public interface MatrixGrandSum Contents Module Procedures MatrixGrandSum_psr MatrixGrandSum_psc Module Procedures private  subroutine MatrixGrandSum_psr(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. real(kind=NTREAL), intent(out) :: sum The sum of all elements. private  subroutine MatrixGrandSum_psc(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. complex(kind=NTCOMPLEX), intent(out) :: sum The sum of all elements.","tags":"","loc":"interface/matrixgrandsum~2.html"},{"title":"PairwiseMultiplyMatrix – NTPoly","text":"public interface PairwiseMultiplyMatrix Contents Module Procedures PairwiseMultiplyMatrix_ps Module Procedures private recursive subroutine PairwiseMultiplyMatrix_ps(matA, matB, matC) Elementwise multiplication. C_ij = A_ij * B_ij.\nAlso known as a Hadamard product. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = MatA mult MatB.","tags":"","loc":"interface/pairwisemultiplymatrix~2.html"},{"title":"MatrixNorm – NTPoly","text":"public interface MatrixNorm Contents Module Procedures MatrixNorm_ps Module Procedures private  function MatrixNorm_ps(this) result(norm_value) Compute the norm of a distributed sparse matrix along the rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm value of the full distributed sparse matrix.","tags":"","loc":"interface/matrixnorm~3.html"},{"title":"DotMatrix – NTPoly","text":"public interface DotMatrix Contents Module Procedures DotMatrix_psr DotMatrix_psc Module Procedures private  subroutine DotMatrix_psr(matA, matB, product) product = dot(Matrix A,Matrix B)\nNote that a dot product is the sum of elementwise multiplication, not\ntraditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product The dot product. private  subroutine DotMatrix_psc(matA, matB, product) product = dot(Matrix A,Matrix B)\nNote that a dot product is the sum of elementwise multiplication, not\ntraditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product The dot product.","tags":"","loc":"interface/dotmatrix~2.html"},{"title":"IncrementMatrix – NTPoly","text":"public interface IncrementMatrix Contents Module Procedures IncrementMatrix_ps Module Procedures private recursive subroutine IncrementMatrix_ps(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY)\nThis will utilize the sparse vector increment routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0).","tags":"","loc":"interface/incrementmatrix~3.html"},{"title":"ScaleMatrix – NTPoly","text":"public interface ScaleMatrix Contents Module Procedures ScaleMatrix_psr ScaleMatrix_psc Module Procedures private  subroutine ScaleMatrix_psr(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. real(kind=NTREAL), intent(in) :: constant A constant scale factor. private recursive subroutine ScaleMatrix_psc(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. complex(kind=NTCOMPLEX), intent(in) :: constant A constant scale factor.","tags":"","loc":"interface/scalematrix~2.html"},{"title":"MatrixTrace – NTPoly","text":"public interface MatrixTrace Contents Module Procedures MatrixTrace_psr Module Procedures private  subroutine MatrixTrace_psr(this, trace_value) Compute the trace of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the trace of. real(kind=NTREAL), intent(out) :: trace_value The trace value of the full distributed sparse matrix.","tags":"","loc":"interface/matrixtrace.html"},{"title":"CheckMPIError – NTPoly","text":"public  function CheckMPIError(this, error_description, mpi_error, immediate_cleanup_in) result(error_occurred) Routine to call to check if an MPI error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: mpi_error The error variable produced by mpi. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. Contents","tags":"","loc":"proc/checkmpierror.html"},{"title":"CheckAllocError – NTPoly","text":"public  function CheckAllocError(this, error_description, alloc_error, immediate_cleanup_in) result(error_occurred) Routine to call if an alloc error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this This the error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: alloc_error The error variable produced by alloc. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. Contents","tags":"","loc":"proc/checkallocerror.html"},{"title":"ErrorOccurred – NTPoly","text":"public  function ErrorOccurred(this) result(occurred) Check if an error has occurred or not. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error variable to check. Return Value logical True if an error has occurred, false otherwise. Contents","tags":"","loc":"proc/erroroccurred.html"},{"title":"ConstructError – NTPoly","text":"public  subroutine ConstructError(this) Default constructor for an error type. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The newly constructed error type Contents","tags":"","loc":"proc/constructerror.html"},{"title":"SetGenericError – NTPoly","text":"public  subroutine SetGenericError(this, error_description, immediate_cleanup_in) Routine to call if a generic error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Contents","tags":"","loc":"proc/setgenericerror.html"},{"title":"SetCustomError – NTPoly","text":"public  subroutine SetCustomError(this, error_code, error_description, immediate_cleanup_in) Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this integer, intent(in) :: error_code character(len=*), intent(in) :: error_description logical, intent(in), optional :: immediate_cleanup_in Contents","tags":"","loc":"proc/setcustomerror.html"},{"title":"PrintError – NTPoly","text":"public  subroutine PrintError(this) Print out that an error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error to print out. Contents","tags":"","loc":"proc/printerror.html"},{"title":"Cleanup – NTPoly","text":"public  subroutine Cleanup(this) As a last case resort, this will print an error message and quit. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error which has caused the need to cleanup the program. Contents","tags":"","loc":"proc/cleanup.html"},{"title":"SquareRoot – NTPoly","text":"public  subroutine SquareRoot(InputMat, OutputMat, solver_parameters_in, order_in) Compute the square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). Contents","tags":"","loc":"proc/squareroot.html"},{"title":"DenseSquareRoot – NTPoly","text":"public  subroutine DenseSquareRoot(Mat, OutputMat, solver_parameters_in) Computes the matrix square root function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the square root of. type( Matrix_ps ), intent(inout) :: OutputMat The computed matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/densesquareroot.html"},{"title":"InverseSquareRoot – NTPoly","text":"public  subroutine InverseSquareRoot(InputMat, OutputMat, solver_parameters_in, order_in) Compute the inverse square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). Contents","tags":"","loc":"proc/inversesquareroot.html"},{"title":"DenseInverseSquareRoot – NTPoly","text":"public  subroutine DenseInverseSquareRoot(Mat, OutputMat, solver_parameters_in) Computes the matrix inverse square root function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the inverse square root of. type( Matrix_ps ), intent(inout) :: OutputMat The computed matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/denseinversesquareroot.html"},{"title":"AddSparseVectors – NTPoly","text":"public interface AddSparseVectors Contents Module Procedures AddSparseVectors_r AddSparseVectors_c Module Procedures private pure subroutine AddSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\nThe values that are returned for C are only valid in the range\n(1:total_values_c). We do not do an automatic shrinking of the array\nto keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. private pure subroutine AddSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\nThe values that are returned for C are only valid in the range\n(1:total_values_c). We do not do an automatic shrinking of the array\nto keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0.","tags":"","loc":"interface/addsparsevectors.html"},{"title":"DotSparseVectors – NTPoly","text":"public interface DotSparseVectors Contents Module Procedures DotSparseVectors_r DotSparseVectors_c Module Procedures private pure function DotSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value real(kind=NTREAL) Dot product. private pure function DotSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value complex(kind=NTCOMPLEX) Dot product.","tags":"","loc":"interface/dotsparsevectors.html"},{"title":"PairwiseMultiplyVectors – NTPoly","text":"public interface PairwiseMultiplyVectors Contents Module Procedures PairwiseMultiplyVectors_r PairwiseMultiplyVectors_c Module Procedures private pure subroutine PairwiseMultiplyVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c This is the total number of values in C. private pure subroutine PairwiseMultiplyVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c This is the total number of values in C. integer, intent(out) :: total_values_c This is the total number of values in C.","tags":"","loc":"interface/pairwisemultiplyvectors.html"},{"title":"Invert – NTPoly","text":"public  subroutine Invert(InputMat, OutputMat, solver_parameters_in) Compute the inverse of a matrix.\nAn implementation of the method of Hotelling \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to invert. type( Matrix_ps ), intent(inout) :: OutputMat The inverse of that matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/invert.html"},{"title":"DenseInvert – NTPoly","text":"public  subroutine DenseInvert(InputMat, OutputMat, solver_parameters_in) Compute the inverse of a matrix using the eigendecomposition. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: OutputMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/denseinvert.html"},{"title":"PseudoInverse – NTPoly","text":"public  subroutine PseudoInverse(InputMat, OutputMat, solver_parameters_in) Compute the pseudoinverse of a matrix.\nAn implementation of the method of Hotelling \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: OutputMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Contents","tags":"","loc":"proc/pseudoinverse.html"},{"title":"RootSolversModule – NTPoly","text":"A Module For Computing General Matrix Roots. Uses InverseSolversModule PSMatrixAlgebraModule LoggingModule PolynomialSolversModule SolverParametersModule PSMatrixModule DataTypesModule SquareRootSolversModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines ComputeRoot ComputeInverseRoot Subroutines public recursive subroutine ComputeRoot (InputMat, OutputMat, root, solver_parameters_in) Compute a general matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public recursive subroutine ComputeInverseRoot (InputMat, OutputMat, root, solver_parameters_in) Compute a general inverse matrix root. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = InputMat&#94;-1/root. integer, intent(in) :: root Which root to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"module/rootsolversmodule.html"},{"title":"SingularValueSolversModule – NTPoly","text":"A module for computing the singular values of a matrix. Uses EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule SignSolversModule PSMatrixModule Contents Subroutines SingularValueDecomposition Subroutines public  subroutine SingularValueDecomposition (this, left_vectors, right_vectors, singularvalues, solver_parameters_in) Compute the singular values and singular vectors of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to decompose. type( Matrix_ps ), intent(inout) :: left_vectors A matrix containing the left singular vectors. type( Matrix_ps ), intent(inout) :: right_vectors A matrix containing the right singular vectors. type( Matrix_ps ), intent(inout) :: singularvalues A diagonal matrix containing the singularvalues. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/singularvaluesolversmodule.html"},{"title":"AnalysisModule – NTPoly","text":"Methods for analyzing the results of electronic structure calculations. Uses PSMatrixAlgebraModule SMatrixModule LoggingModule CholeskyModule SolverParametersModule DMatrixModule PSMatrixModule DataTypesModule DensityMatrixSolversModule Contents Subroutines PivotedCholeskyDecomposition ReduceDimension Subroutines public  subroutine PivotedCholeskyDecomposition (AMat, LMat, rank_in, solver_parameters_in) Compute The Pivoted Cholesky Decomposition of a Hermitian Semi-Definite\nmatrix. This is one way to generate localized orbitals. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive semi-definite. type( Matrix_ps ), intent(inout) :: LMat The matrix computed. integer, intent(in) :: rank_in The target rank of the matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Tarameters for the solver public  subroutine ReduceDimension (this, dim, ReducedMat, solver_parameters_in) When we want to only compute the first n eigenvalues of a matrix, this\nroutine will project out the higher eigenvalues. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The starting matrix. integer, intent(in) :: dim The number of eigenvalues ot keep. type( Matrix_ps ), intent(inout) :: ReducedMat a dimxdim matrix with the same first n eigenvalues as the first. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The solver parameters.","tags":"","loc":"module/analysismodule.html"},{"title":"ChebyshevSolversModule – NTPoly","text":"A Module For Computing Matrix functions based on Chebyshev polynomials. Uses PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute FactorizedCompute Derived Types ChebyshevPolynomial_t Interfaces public        interface ConstructPolynomial private pure subroutine ConstructPolynomial_cheby(this, degree) Construct a Chebyshev polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree Degree of the polynomial. public        interface DestructPolynomial private pure subroutine DestructPolynomial_cheby(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to destruct. public        interface SetCoefficient private  subroutine SetCoefficient_cheby(this, degree, coefficient) Set a coefficient of a Chebyshev polynomial. Arguments Type Intent Optional Attributes Name type( ChebyshevPolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value. public        interface Compute private  subroutine Compute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\nThis method uses the standard Chebyshev Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public        interface FactorizedCompute private  subroutine FactorizedCompute_cheby(InputMat, OutputMat, poly, solver_parameters_in) Compute The Chebyshev Polynomial of the matrix.\nThis version first factors the Chebyshev Polynomial and computes the\nfunction using a divide and conquer algorithm. Based on a simplified\nversion of the first method in \\cite liang2003improved . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( ChebyshevPolynomial_t ), intent(in) :: poly The Chebyshev polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Derived Types type, public :: ChebyshevPolynomial_t A datatype that represents a Chebyshev polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/chebyshevsolversmodule.html"},{"title":"NTMPIModule – NTPoly","text":"This module wraps the MPI include statement because on certain platforms\njust writing \"USE MPI\" does not work. Uses mpi Contents None","tags":"","loc":"module/ntmpimodule.html"},{"title":"TrigonometrySolversModule – NTPoly","text":"A Module For Computing Trigonometric functions of a Matrix. Uses EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines Sine DenseSine Cosine DenseCosine ScaleSquareTrigonometryTaylor Subroutines public  subroutine Sine (InputMat, OutputMat, solver_parameters_in) Compute the sine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public  subroutine DenseSine (Mat, OutputMat, solver_parameters_in) Compute the sine of a matrix. (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The sine of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine Cosine (InputMat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public  subroutine DenseCosine (Mat, OutputMat, solver_parameters_in) Compute the cosine of a matrix. (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The cosine of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ScaleSquareTrigonometryTaylor (InputMat, OutputMat, params) Compute trigonometric functions of a matrix using a taylor series. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in) :: params Parameters for the solver.","tags":"","loc":"module/trigonometrysolversmodule.html"},{"title":"PMatrixMemoryPoolModule – NTPoly","text":"A module for handling scratch memory for distributed matrix multiplication. Uses MatrixMemoryPoolModule PSMatrixModule Contents Interfaces ConstructMatrixMemoryPool DestructMatrixMemoryPool CheckMemoryPoolValidity Derived Types MatrixMemoryPool_p Interfaces public        interface ConstructMatrixMemoryPool private pure subroutine ConstructMatrixMemoryPool_p(this, matrix) Construct Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this A constructed Matrix Memory Pool object. type( Matrix_ps ), intent(in) :: matrix The associated distributed sparse matrix. public        interface DestructMatrixMemoryPool private pure subroutine DestructMatrixMemoryPool_p(this) Destruct a Distributed Matrix Memory Pool object. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(inout) :: this Distributed Matrix Memory Pool object to destroy. public        interface CheckMemoryPoolValidity private pure function CheckMemoryPoolValidity_p(this, matrix) result(isvalid) Checks if a given distributed memory pool has been validly allocated to\nhandle the given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_p ), intent(in) :: this The memory pool to check. type( Matrix_ps ), intent(in) :: matrix The associated matrix to check against. Return Value logical True if the memory pool is valid. Derived Types type, public :: MatrixMemoryPool_p A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial type( MatrixMemoryPool_lr ), public, DIMENSION(:,:), ALLOCATABLE :: grid_r Grid of local pools. type( MatrixMemoryPool_lc ), public, DIMENSION(:,:), ALLOCATABLE :: grid_c Grid of local pools (complex).","tags":"","loc":"module/pmatrixmemorypoolmodule.html"},{"title":"TripletListModule – NTPoly","text":"A Module For Storing Lists of Triplets. Uses TripletModule NTMPIModule MatrixMarketModule DataTypesModule Contents Interfaces ConstructTripletList CopyTripletList DestructTripletList ResizeTripletList AppendToTripletList SetTripletAt GetTripletAt SortTripletList SymmetrizeTripletList GetTripletListSize RedistributeTripletLists ShiftTripletList ConvertTripletListType Derived Types TripletList_r TripletList_c Interfaces public        interface ConstructTripletList private pure subroutine ConstructTripletListSup_r(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to construct. integer, intent(in), optional :: size_in The length of the triplet list (default = 0). private pure subroutine ConstructTripletListSup_c(this, size_in) Subroutine wrapper for constructing a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to construct. integer, intent(in), optional :: size_in The length of the triplet list (default = 0). public        interface CopyTripletList private  subroutine CopyTripletList_r(tripA, tripB) Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: tripA The triplet list to copy. type( TripletList_r ), intent(inout) :: tripB tripB = tripA private  subroutine CopyTripletList_c(tripA, tripB) Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: tripA The triplet list to copy. type( TripletList_c ), intent(inout) :: tripB tripB = tripA public        interface DestructTripletList private pure subroutine DestructTripletList_r(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to destruct. private pure subroutine DestructTripletList_c(this) Destructs a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to destruct. public        interface ResizeTripletList private pure subroutine ResizeTripletList_r(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to resize. integer, intent(in) :: size Size to resize to. private pure subroutine ResizeTripletList_c(this, size) Increase the size of a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to resize. integer, intent(in) :: size Size to resize to. public        interface AppendToTripletList private pure subroutine AppendToTripletList_r(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this This the triplet list to append to. type( Triplet_r ), intent(in) :: triplet_value The value to append. private pure subroutine AppendToTripletList_c(this, triplet_value) Add a value to the end of the triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this This the triplet list to append to. type( Triplet_c ), intent(in) :: triplet_value The value to append. public        interface SetTripletAt private pure subroutine SetTripletAt_r(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: this The triplet list to set. integer, intent(in) :: index The index at which to set the triplet. type( Triplet_r ), intent(in) :: triplet_value The value of the triplet to set. private pure subroutine SetTripletAt_c(this, index, triplet_value) Set the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: this The triplet list to set. integer, intent(in) :: index The index at which to set the triplet. type( Triplet_c ), intent(in) :: triplet_value The value of the triplet to set. public        interface GetTripletAt private pure subroutine GetTripletAt_r(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: this The triplet list to get the value from. integer, intent(in) :: index The index from which to get the triplet. type( Triplet_r ), intent(out) :: triplet_value The extracted triplet value. private pure subroutine GetTripletAt_c(this, index, triplet_value) Get the value of a triplet at a particular index. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: this The triplet list to get the value from. integer, intent(in) :: index The index from which to get the triplet. type( Triplet_c ), intent(out) :: triplet_value The extracted triplet value. public        interface SortTripletList private pure subroutine SortTripletList_r(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\nImplementation is based on bucket sort. This is why it needs the number of\nmatrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_r ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you do not need the final bubble sort. private pure subroutine SortTripletList_c(input_list, matrix_columns, matrix_rows, sorted_list, bubble_in) Sorts a triplet list by index values.\nImplementation is based on bucket sort. This is why it needs the number of\nmatrix columns. Bubble sort is used within a bucket. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: input_list List to be sorted. integer, intent(in) :: matrix_columns This is the highest column value in the list. integer, intent(in) :: matrix_rows This is the highest row value in the list. type( TripletList_c ), intent(out) :: sorted_list A now sorted version of the list. This routine will allocate it. logical, intent(in), optional :: bubble_in False if you do not need the final bubble sort. public        interface SymmetrizeTripletList private  subroutine SymmetrizeTripletList_r(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\nsymmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. private  subroutine SymmetrizeTripletList_c(triplet_list, pattern_type) Symmetrizes an unsymmetric triplet list according to the specified\nsymmetry type. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list List to be symmetrized. integer, intent(in) :: pattern_type Type of symmetry. public        interface GetTripletListSize private pure function GetTripletListSize_r(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. private pure function GetTripletListSize_c(triplet_list) result(list_size) Get the number of entries in a triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: triplet_list List to get the size of. Return Value integer The number of entries in the triplet list. public        interface RedistributeTripletLists private  subroutine RedistributeTripletLists_r(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\nTakes in a list of triplet lists, one list for each processor. Then the\nall to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_r ), intent(inout) :: local_data_out The resulting local triplet list. private  subroutine RedistributeTripletLists_c(triplet_lists, comm, local_data_out) Redistribute some triplet lists amongst a set of processors.\nTakes in a list of triplet lists, one list for each processor. Then the\nall to all redistribution is performed along the given communicator. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in), DIMENSION(:) :: triplet_lists A list of triplet lists, one for each process. integer, intent(inout) :: comm The mpi communicator to redistribute along. type( TripletList_c ), intent(inout) :: local_data_out The resulting local triplet list. public        interface ShiftTripletList private pure subroutine ShiftTripletList_r(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\nFrequently, we have a triplet list that comes from the global matrix which\nwe would like to shift into a local matrix. In that case, just pass\nthe negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. private pure subroutine ShiftTripletList_c(triplet_list, row_shift, column_shift) Shift the rows and columns of a triplet list by set values.\nFrequently, we have a triplet list that comes from the global matrix which\nwe would like to shift into a local matrix. In that case, just pass\nthe negative of the starting row and column (plus 1) to this routine. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(inout) :: triplet_list The triplet list to shift. integer, intent(in) :: row_shift The row offset to shift by. integer, intent(in) :: column_shift The column offset to shift by. public        interface ConvertTripletListType private  subroutine ConvertTripletListToReal(cin_triplet, rout_triplet) Convert a complex triplet list to a real triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: cin_triplet The starting triplet list. type( TripletList_r ), intent(inout) :: rout_triplet Real valued triplet list. private  subroutine ConvertTripletListToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet list. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: rin_triplet The starting triplet list. type( TripletList_c ), intent(inout) :: cout_triplet Complex valued triplet list. Derived Types type, public :: TripletList_r A data type for a list of triplets. Components Type Visibility Attributes Name Initial type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list type, public :: TripletList_c A data type for a list of triplets. Components Type Visibility Attributes Name Initial type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: DATA Internal representation of the data. integer, public :: CurrentSize Current number of elements in the triplet list","tags":"","loc":"module/tripletlistmodule.html"},{"title":"SolverParametersModule – NTPoly","text":"A Module For Storing The Parameters For Iterative Solvers. Uses PermutationModule DataTypesModule LoggingModule Contents Variables CONVERGENCE_DIFF_CONST MAX_ITERATIONS_CONST Derived Types SolverParameters_t Subroutines ConstructSolverParameters CopySolverParameters SetParametersConvergeDiff SetParametersMaxIterations SetParametersThreshold SetParametersBeVerbose SetParametersLoadBalance SetParametersStepThreshold PrintParameters DestructSolverParameters Variables Type Visibility Attributes Name Initial real(kind=NTREAL), public, parameter :: CONVERGENCE_DIFF_CONST = 1e-6_NTREAL The default convergence difference. integer, public, parameter :: MAX_ITERATIONS_CONST = 1000 The default maximum number of iterations. Derived Types type, public :: SolverParameters_t A class for passing parameters to an iterative solver. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public :: converge_diff When do we consider a calculation converged. integer, public :: max_iterations Maximum number of iterations of a solver before termination. real(kind=NTREAL), public :: threshold Threshold for sparse multiplication and addition. logical, public :: be_verbose If true, the sparse solver prints out information each loop iteration. logical, public :: do_load_balancing If true, the sparse solver will try and load balance before calculation. type( Permutation_t ), public :: BalancePermutation The permutation used for load balancing. real(kind=NTREAL), public :: step_thresh Thresholds for step size searches. Subroutines public  subroutine ConstructSolverParameters (this, converge_diff_in, threshold_in, max_iterations_in, be_verbose_in, BalancePermutation_in, step_thresh_in) Construct a data type which stores iterative solver parameters. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameters to construct. real(kind=NTREAL), intent(in), optional :: converge_diff_in Converge_diff_in the difference between iterations to consider\na calculation converged. real(kind=NTREAL), intent(in), optional :: threshold_in The zero threshold integer, intent(in), optional :: max_iterations_in The maximum number of iterations to perform logical, intent(in), optional :: be_verbose_in Whether to print during the calculation (default = False) type( Permutation_t ), intent(in), optional :: BalancePermutation_in For load balancing real(kind=NTREAL), intent(in), optional :: step_thresh_in Step size for differential equation solvers. public  subroutine CopySolverParameters (paramA, paramB) Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: paramA Parameters to copy type( SolverParameters_t ), intent(inout) :: paramB paramB = paramA public pure subroutine SetParametersConvergeDiff (this, new_value) Set the value of the convergence difference. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. public pure subroutine SetParametersMaxIterations (this, new_value) Set the value of the max iterations. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. integer, intent(in) :: new_value Value to set it to. public pure subroutine SetParametersThreshold (this, new_value) Set the value of the threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. public pure subroutine SetParametersBeVerbose (this, new_value) Set the value of the verbosity. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. logical, intent(in) :: new_value Value to set it to. public pure subroutine SetParametersLoadBalance (this, new_value) Set the value of the load balance. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. type( Permutation_t ), intent(in) :: new_value Value to set it to. public pure subroutine SetParametersStepThreshold (this, new_value) Set the value of the step threshold. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object. real(kind=NTREAL), intent(in) :: new_value Value to set it to. public  subroutine PrintParameters (this) Print out the iterative solver parameter values. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(in) :: this The parameter object. public pure subroutine DestructSolverParameters (this) Cleanup the solver parameters datastructure. Arguments Type Intent Optional Attributes Name type( SolverParameters_t ), intent(inout) :: this The parameter object.","tags":"","loc":"module/solverparametersmodule.html"},{"title":"MatrixMapsModule – NTPoly","text":"A Module For Simplfiying Per Element Operations on Matrices. Uses TripletModule PSMatrixModule DataTypesModule TripletListModule Contents Interfaces MapTripletList Subroutines MapMatrix_psr MapMatrix_psc Interfaces public        interface MapTripletList private  subroutine MapTripletList_r(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletList_c(inlist, outlist, proc, num_slices_in, my_slice_in) Given a triplet list, apply this procedure to each element. Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayDouble_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (real) triplet list, apply this procedure to each element with Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. real(kind=NTREAL), intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. real(kind=NTREAL), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayDouble_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (complex) triplet list, apply this procedure to each element Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. complex(kind=NTCOMPLEX), intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayInt_r(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (real) triplet list, apply this procedure to each element with Arguments Type Intent Optional Attributes Name type( TripletList_r ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_r ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. integer, intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. integer, intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). private  subroutine MapTripletListArrayInt_c(inlist, outlist, proc, supp_in, num_slices_in, my_slice_in) Given a (complex) triplet list, apply this procedure to each element Arguments Type Intent Optional Attributes Name type( TripletList_c ), intent(in) :: inlist The matrix to apply the procedure to. type( TripletList_c ), intent(inout) :: outlist The matrix where each element has had proc called on it. private  function proc(row, column, val, supp_in) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. integer, intent(in), optional, DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. Return Value logical Set this to false to filter an element. integer, intent(in), DIMENSION(:) :: supp_in Any supplementary data you need to pass the map can packed here. integer, intent(in), optional :: num_slices_in How many process slices to do this mapping on (default is 1) integer, intent(in), optional :: my_slice_in What process slice this process should compute (default is 0). Subroutines public  subroutine MapMatrix_psr (inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (real). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. real(kind=NTREAL), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element. public  subroutine MapMatrix_psc (inmat, outmat, proc) Given a distributed matrix, apply this procedure to each element (complex). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: inmat The matrix to apply the procedure to. type( Matrix_ps ), intent(inout) :: outmat The matrix where each element has had proc called on it. private  function proc(row, column, val) result(valid) The procedure to apply to each element. Arguments Type Intent Optional Attributes Name integer, intent(inout), optional :: row The row value of an element. integer, intent(inout), optional :: column The column value of an element. complex(kind=NTCOMPLEX), intent(inout), optional :: val The actual value of an element. Return Value logical Set this to false to filter an element.","tags":"","loc":"module/matrixmapsmodule.html"},{"title":"TimerModule – NTPoly","text":"A module to do timings. Uses ProcessGridModule NTMPIModule DataTypesModule LoggingModule Contents Subroutines RegisterTimer StartTimer StopTimer PrintTimer PrintAllTimers PrintAllTimersDistributed Subroutines public  subroutine RegisterTimer (timer_name) Register a timer with the timer module.  Call this before using that timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. public  subroutine StartTimer (timer_name) Start the clock running for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public  subroutine StopTimer (timer_name) Stop the clock for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public  subroutine PrintTimer (timer_name) Print out the elapsed time for a given timer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: timer_name Name of the timer. Must be registered. public  subroutine PrintAllTimers () Print out the elapsed time for each timer on this process. Arguments None public  subroutine PrintAllTimersDistributed () Print out the elapsed time for each timer based on the max value across\nprocesses. Arguments None","tags":"","loc":"module/timermodule.html"},{"title":"LoadBalancerModule – NTPoly","text":"Module for load balancing the matrix multiplication calculation. Uses PermutationModule PMatrixMemoryPoolModule PSMatrixModule PSMatrixAlgebraModule Contents Subroutines PermuteMatrix UndoPermuteMatrix Subroutines public  subroutine PermuteMatrix (mat, mat_out, permutation, memorypool_in) Apply a permutation to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat The matrix to permute. type( Matrix_ps ), intent(inout) :: mat_out The permuted matrix. type( Permutation_t ), intent(in) :: permutation The permutation to apply. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use public  subroutine UndoPermuteMatrix (mat, mat_out, permutation, memorypool_in) Undo a permutation applied to a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: mat Matrix to undo permutation of. type( Matrix_ps ), intent(inout) :: mat_out Unpermuted matrix. type( Permutation_t ), intent(in) :: permutation Permutation to remove. type( MatrixMemoryPool_p ), intent(inout), optional :: memorypool_in Memory pool to use.","tags":"","loc":"module/loadbalancermodule.html"},{"title":"GemmTasksModule – NTPoly","text":"This module contains some enumerators which name the tasks for Gemm. Contents Enumerations unnamed unnamed unnamed Enumerations enum, bind(c) Enumerators enumerator :: TaskRunningA = 0 Something is in progress enumerator :: LocalGatherA = 1 First we gather the blocks of A and send the size. enumerator :: SendSizeA = 2 After the local gather, we then send the size to the other tasks. enumerator :: ComposeA = 3 Next we compose those blocks of A into one big send buffer and send. enumerator :: WaitOuterA = 4 Wait for the outer index values to be gathered. enumerator :: WaitInnerA = 5 Wait for the inner index values to be gathered. enumerator :: WaitDataA = 6 Wait for the data values to be gathered, enumerator :: AdjustIndicesA = 7 Need to adjusts indices, transpose the values of A. enumerator :: CleanupA = 8 Just waiting on that last task. enumerator :: FinishedA = 9 No more work to do. enum, bind(c) Enumerators enumerator :: TaskRunningB = 0 Something is in progress enumerator :: LocalGatherB = 1 First we gather the blocks of B and send the size. enumerator :: LocalComposeB = 2 Next we compose those blocks of B into one big send buffer and send. enumerator :: SendSizeB = 3 After the local gather, we then send the size to the other tasks. enumerator :: WaitOuterB = 4 Wait for the outer index values to be gathered. enumerator :: WaitInnerB = 5 Wait for the inner index values to be gathered. enumerator :: WaitDataB = 6 Wait for the data values to be gathered, and then adjusts the indices. enumerator :: AdjustIndicesB = 7 Need to adjusts indices of B. enumerator :: CleanupB = 8 Just waiting on that last task. enumerator :: FinishedB = 9 No more work to do. enum, bind(c) Enumerators enumerator :: TaskRunningAB = 0 Something is in progress. enumerator :: AwaitingAB = 1 A and B matrix both missing, so it cannot do gemm. enumerator :: GemmAB = 2 Actually call gemm and compute a block, and send its size. enumerator :: SendSizeAB = 3 After the local Gemm, we then send the size to the other tasks. enumerator :: GatherAndSumAB = 4 Start sending the data for summing. enumerator :: WaitOuterAB = 5 Wait for the outer index values to be gathered. enumerator :: WaitInnerAB = 6 Wait for the inner index values to be gathered. enumerator :: WaitDataAB = 7 Wait for the data values to be gathered. Once receive, we increment. enumerator :: LocalSumAB = 8 Sum up the gathered matrices. enumerator :: CleanupAB = 9 Just waiting on that last task. enumerator :: FinishedAB = 10 No more work to do.","tags":"","loc":"module/gemmtasksmodule.html"},{"title":"MatrixMemoryPoolModule – NTPoly","text":"A module for handling scratch memory for matrix multiplication.\nThe purpose of this module is to avoid having to allocate memory on the\nheap during a matrix multiply, and to manage the underlying hash table. Uses TripletModule DataTypesModule Contents Interfaces ConstructMatrixMemoryPool DestructMatrixMemoryPool CheckMemoryPoolValidity SetPoolSparsity Derived Types MatrixMemoryPool_lr MatrixMemoryPool_lc Interfaces public        interface ConstructMatrixMemoryPool private  subroutine ConstructMatrixMemoryPoolSub_lr(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), TARGET :: this The matrix to construct. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). private  subroutine ConstructMatrixMemoryPoolSub_lc(this, columns, rows, sparsity_in) Subroutine wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), TARGET :: this The matrix to construct. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. real(kind=NTREAL), intent(in), optional :: sparsity_in Estimated sparsity (optional). public        interface DestructMatrixMemoryPool private pure subroutine DestructMatrixMemoryPool_lr(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout) :: this The matrix being destructed. private pure subroutine DestructMatrixMemoryPool_lc(this) A destructor for a matrix memory pool Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout) :: this The matrix being destructed. public        interface CheckMemoryPoolValidity private pure function CheckMemoryPoolValidity_lr(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\nthe given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. private pure function CheckMemoryPoolValidity_lc(this, columns, rows) result(isvalid) Checks if a given memory pool has been validly allocated to handle\nChecks if a given memory pool has been validly allocated to handle\nthe given parameters. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(in) :: this The memory pool to check. integer, intent(in) :: columns Number of columns in the matrix. integer, intent(in) :: rows Number of rows in the matrix. Return Value logical true if the memory pool is valid. public        interface SetPoolSparsity private  subroutine SetPoolSparsity_lr(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lr ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. private  subroutine SetPoolSparsity_lc(this, sparsity) Sets the expected sparsity of the matrix, which helps with hashing. Arguments Type Intent Optional Attributes Name type( MatrixMemoryPool_lc ), intent(inout), TARGET :: this The memory pool to set the sparsity of. real(kind=NTREAL), intent(in) :: sparsity The sparsity value. Derived Types type, public :: MatrixMemoryPool_lr A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_r ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets. type, public :: MatrixMemoryPool_lc A memory pool datatype that can be reused for matrix matrix multiplication.\nthis is to prevent excessive alloc/dealloc. Components Type Visibility Attributes Name Initial integer, public :: columns Shape of matrix: columns integer, public :: rows Shape of matrix: rows type( Triplet_c ), public, DIMENSION(:), ALLOCATABLE :: pruned_list storage for actual values added to the matrix. complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: value_array storage for potential values added to the matrix. logical, public, DIMENSION(:,:), ALLOCATABLE :: dirty_array true if an element has been pushed to this part of the matrix. integer, public, DIMENSION(:,:), ALLOCATABLE :: hash_index Storage space for indices, hashed. integer, public, DIMENSION(:,:), ALLOCATABLE :: inserted_per_bucket Internal storage space for amount of items added to a bucket. integer, public :: hash_size Size of the buckets.","tags":"","loc":"module/matrixmemorypoolmodule.html"},{"title":"DensityMatrixSolversModule – NTPoly","text":"A Module For Solving Quantum Chemistry Systems using Purification. Uses NTMPIModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule FermiOperatorModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines PM TRS2 TRS4 HPCP ScaleAndFold DenseDensity EnergyDensityMatrix McWeenyStep Subroutines public  subroutine PM (H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the PM method.\nBased on the PM algorithm presented in \\cite palser1998canonical Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine TRS2 (H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS2 method.\nBased on the TRS2 algorithm presented in \\cite niklasson2002. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine TRS4 (H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the TRS4 method.\nBased on the TRS4 algorithm presented in \\cite niklasson2002 Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine HPCP (H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the HPCP method.\nBased on the algorithm presented in \\cite truflandier2016communication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine ScaleAndFold (H, ISQ, trace, K, homo, lumo, energy_value_out, solver_parameters_in) Compute the density matrix from a Hamiltonian using the Scale and Fold\nmethod. Based on the method of \\cite rubensson2011nonmonotonic .\nNote that for this method, you must provide the value of the homo and\nlumo gap. It is not necessary for these to be accurate, but give a\nconservative value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: homo A conservative estimate of the highest occupied eigenvalue. real(kind=NTREAL), intent(in) :: lumo A conservative estimate of the lowest unoccupied eigenvalue. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine DenseDensity (H, ISQ, trace, K, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix using a dense routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine EnergyDensityMatrix (H, D, ED, threshold_in) Compute the energy-weighted density matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute from. type( Matrix_ps ), intent(in) :: D The density matrix. type( Matrix_ps ), intent(inout) :: ED The energy-weighted density matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0). public  subroutine McWeenyStep (D, DOut, S_in, threshold_in) Take one McWeeny Step DOut = 3 DSD - 2 DSDSD Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: D The density matrix. type( Matrix_ps ), intent(inout) :: DOut The resulting purified matrix. type( Matrix_ps ), intent(in), optional :: S_in The overlap matrix (optional) real(kind=NTREAL), intent(in), optional :: threshold_in Threshold for flushing small values (default = 0).","tags":"","loc":"module/densitymatrixsolversmodule.html"},{"title":"FermiOperatorModule – NTPoly","text":"A Module For Computing The Density Matrix Using the Fermi Operator Expansion Uses EigenSolversModule PSMatrixAlgebraModule NTMPIModule LoggingModule TripletListModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Subroutines ComputeDenseFOE WOM_GC WOM_C Subroutines public  subroutine ComputeDenseFOE (H, ISQ, trace, K, inv_temp_in, energy_value_out, chemical_potential_out, solver_parameters_in) Compute the density matrix using a dense routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons) type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in), optional :: inv_temp_in The inverse temperature for smearing in a.u. (optional). real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). real(kind=NTREAL), intent(out), optional :: chemical_potential_out The chemical potential (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine WOM_GC (H, ISQ, K, chemical_potential, inv_temp, energy_value_out, solver_parameters_in) Compute the density matrix according to the wave operator minization Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: chemical_potential The chemical potential. real(kind=NTREAL), intent(in) :: inv_temp The inverse temperature for smearing in a.u. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional). public  subroutine WOM_C (H, ISQ, K, trace, inv_temp, energy_value_out, solver_parameters_in) Compute the density matrix according to the wave operator minization Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: H The matrix to compute the corresponding density from. type( Matrix_ps ), intent(in) :: ISQ The inverse square root of the overlap matrix. type( Matrix_ps ), intent(inout) :: K The density matrix computed by this routine. real(kind=NTREAL), intent(in) :: trace The target trace. real(kind=NTREAL), intent(in) :: inv_temp The inverse temperature for smearing in a.u. real(kind=NTREAL), intent(out), optional :: energy_value_out The energy of the system (optional). type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver (optional).","tags":"","loc":"module/fermioperatormodule.html"},{"title":"MatrixReduceModule – NTPoly","text":"Module for reducing matrices across processes. Uses SMatrixModule NTMPIModule SMatrixAlgebraModule DataTypesModule Contents Interfaces ReduceAndComposeMatrixSizes ReduceAndComposeMatrixData ReduceAndComposeMatrixCleanup ReduceAndComposeMatrix ReduceAndSumMatrixSizes ReduceAndSumMatrixData ReduceAndSumMatrixCleanup ReduceAndSumMatrix Derived Types ReduceHelper_t Functions TestReduceSizeRequest TestReduceInnerRequest TestReduceDataRequest Interfaces public        interface ReduceAndComposeMatrixSizes private  subroutine ReduceAndComposeMatrixSizes_lsr(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private  subroutine ReduceAndComposeMatrixSizes_lsc(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix integer, intent(inout) :: comm type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper public        interface ReduceAndComposeMatrixData private  subroutine ReduceAndComposeMatrixData_lsr(matrix, comm, gathered_matrix, helper) Second function to call, will gather the data and align one matrix\nnext to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private  subroutine ReduceAndComposeMatrixData_lsc(matrix, comm, gathered_matrix, helper) Second function to call, will gather the data and align one matrix\nnext to another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public        interface ReduceAndComposeMatrixCleanup private pure subroutine ReduceAndComposeMatrixCleanup_lsr(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private pure subroutine ReduceAndComposeMatrixCleanup_lsc(matrix, gathered_matrix, helper) Third function to call, finishes setting up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public        interface ReduceAndComposeMatrix private  subroutine ReduceAndComposeMatrix_lsr(matrix, comm, gathered_matrix) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. private  subroutine ReduceAndComposeMatrix_lsc(matrix, comm, gathered_matrix) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. public        interface ReduceAndSumMatrixSizes private  subroutine ReduceAndSumMatrixSizes_lsr(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The  helper associated with this gather. private  subroutine ReduceAndSumMatrixSizes_lsc(matrix, comm, gathered_matrix, helper) The first routine to call, gathers the sizes of the data to be sent. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public        interface ReduceAndSumMatrixData private  subroutine ReduceAndSumMatrixData_lsr(matrix, comm, gathered_matrix, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private  subroutine ReduceAndSumMatrixData_lsc(matrix, comm, gathered_matrix, helper) Second routine to call for gathering and summing up the data. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The matrix we are gathering. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public        interface ReduceAndSumMatrixCleanup private pure subroutine ReduceAndSumMatrixCleanup_lsr(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. private pure subroutine ReduceAndSumMatrixCleanup_lsc(matrix, gathered_matrix, threshold, helper) Finally routine to sum up the matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. type( ReduceHelper_t ), intent(inout) :: helper The helper associated with this gather. public        interface ReduceAndSumMatrix private  subroutine ReduceAndSumMatrix_lsr(matrix, comm, gathered_matrix, threshold) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsr ), intent(inout) :: gathered_matrix The gathered_matrix the matrix being gathered. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. private  subroutine ReduceAndSumMatrix_lsc(matrix, comm, gathered_matrix, threshold) Reduce and sum the matrices in one step. If you use this method, you\nlose the opportunity for overlapping communication. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matrix The matrix to send. integer, intent(inout) :: comm The communicator to send along. type( Matrix_lsc ), intent(inout) :: gathered_matrix The threshold the threshold for flushing values. real(kind=NTREAL), intent(in) :: threshold The threshold the threshold for flushing values. Derived Types type, public :: ReduceHelper_t A data structure to stores internal information about a reduce call. Components Type Visibility Attributes Name Initial integer, public :: comm_size Number of processors involved in this gather. integer, public :: outer_request A request object for gathering outer indices. integer, public :: inner_request A request object for gathering inner indices. integer, public :: data_request A request object for gathering data. integer, public :: error_code The error code after an MPI call. integer, public, DIMENSION(:), ALLOCATABLE :: values_per_process Number of values to gather from each process. integer, public, DIMENSION(:), ALLOCATABLE :: displacement The displacements for where those gathered values should go. Functions public  function TestReduceSizeRequest (helper) result(request_completed) Test if a request for the size of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. public  function TestReduceInnerRequest (helper) result(request_completed) Test if a request for the inner indices of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished. public  function TestReduceDataRequest (helper) result(request_completed) Test if a request for the data of the matrices is complete. Arguments Type Intent Optional Attributes Name type( ReduceHelper_t ), intent(inout) :: helper The gatherer helper structure. Return Value logical True if the request is finished.","tags":"","loc":"module/matrixreducemodule.html"},{"title":"SMatrixModule – NTPoly","text":"A module for handling locally stored CSR matrices. Uses TripletModule MatrixMarketModule DataTypesModule TripletListModule Contents Interfaces ConstructEmptyMatrix ConstructMatrixFromFile ConstructMatrixFromTripletList DestructMatrix CopyMatrix GetMatrixRows GetMatrixColumns ExtractMatrixRow ExtractMatrixColumn SplitMatrix SplitMatrixColumns ComposeMatrix ComposeMatrixColumns TransposeMatrix ConjugateMatrix PrintMatrix MatrixToTripletList ConvertMatrixType Derived Types Matrix_lsr Matrix_lsc Interfaces public        interface ConstructEmptyMatrix private pure subroutine ConstructEmptyMatrixSub_lsr(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. private pure subroutine ConstructEmptyMatrixSub_lsc(this, rows, columns, zero_in) A subroutine type wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of matrix rows. integer, intent(in) :: columns The number of matrix columns. logical, intent(in), optional :: zero_in Whether to set the matrix to zero. public        interface ConstructMatrixFromFile private  subroutine ConstructMatrixFromFileSub_lsr(this, file_name) Subroutine wrapper for the construct from file function. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. private  subroutine ConstructMatrixFromFileSub_lsc(this, file_name) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed. character(len=*), intent(in) :: file_name Name of the file. public        interface ConstructMatrixFromTripletList private pure subroutine ConstructMatrixFromTripletListSub_lsr(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix being constructed type( TripletList_r ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns private pure subroutine ConstructMatrixFromTripletListSub_lsc(this, triplet_list, rows, columns) A subroutine wrapper for the triplet list based constructor. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix being constructed type( TripletList_c ), intent(in) :: triplet_list A list of triplet values. They must be sorted. integer, intent(in) :: rows Number of matrix rows integer, intent(in) :: columns Number of matrix columns public        interface DestructMatrix private pure subroutine DestructMatrix_lsr(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: this The matrix to free up. private pure subroutine DestructMatrix_lsc(this) Explicitly destruct a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to free up. public        interface CopyMatrix private pure subroutine CopyMatrix_lsr(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix to copy type( Matrix_lsr ), intent(inout) :: matB matB = matA private pure subroutine CopyMatrix_lsc(matA, matB) Copy a sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix to copy type( Matrix_lsc ), intent(inout) :: matB matB = matA public        interface GetMatrixRows private pure function GetMatrixRows_lsr(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix. Return Value integer The number of rows. private pure function GetMatrixRows_lsc(this) result(rows) Get the number of rows of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix. Return Value integer The number of rows. public        interface GetMatrixColumns private pure function GetMatrixColumns_lsr(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this Return Value integer The number of columns. private pure function GetMatrixColumns_lsc(this) result(columns) Get the number of columns of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this Return Value integer The number of columns. public        interface ExtractMatrixRow private pure subroutine ExtractMatrixRow_lsr(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsr ), intent(inout) :: row_out The matrix representing that row. private pure subroutine ExtractMatrixRow_lsc(this, row_number, row_out) Extract a row from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: row_number The row to extract. type( Matrix_lsc ), intent(inout) :: row_out The matrix representing that row. public        interface ExtractMatrixColumn private pure subroutine ExtractMatrixColumn_lsr(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsr ), intent(inout) :: column_out The column representing that row. private pure subroutine ExtractMatrixColumn_lsc(this, column_number, column_out) Extract a column from the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to extract from. integer, intent(in) :: column_number The column to extract. type( Matrix_lsc ), intent(inout) :: column_out The column representing that row. public        interface SplitMatrix private pure subroutine SplitMatrix_lsr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsr ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private pure subroutine SplitMatrix_lsc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_lsc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. public        interface SplitMatrixColumns private pure subroutine SplitMatrixColumns_lsr(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsr ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. private pure subroutine SplitMatrixColumns_lsc(this, num_blocks, block_sizes, split_list) Split a matrix into into small blocks based on the specified offsets. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this This matrix to perform this operation on. integer, intent(in) :: num_blocks Number of blocks to split into. integer, intent(in), DIMENSION(num_blocks) :: block_sizes The sizes used for splitting. type( Matrix_lsc ), intent(inout), DIMENSION(num_blocks) :: split_list 1D array of blocks. public        interface ComposeMatrix private pure subroutine ComposeMatrix_lsr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:, :) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsr ), intent(inout) :: out_matrix The composed matrix. private pure subroutine ComposeMatrix_lsc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:, :) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_lsc ), intent(inout) :: out_matrix The composed matrix. public        interface ComposeMatrixColumns private pure subroutine ComposeMatrixColumns_lsr(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\nthe first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsr ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. private pure subroutine ComposeMatrixColumns_lsc(mat_list, out_matrix) Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of\nthe first matrix are followed by the columns of the matrices in the list. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in), DIMENSION(:) :: mat_list A list of matrices to compose. type( Matrix_lsc ), intent(inout) :: out_matrix out_matrix = [Matrix 1 | Matrix 2, ...]. public        interface TransposeMatrix private pure subroutine TransposeMatrix_lsr(this, matT) Transpose a sparse matrix and return it in a separate matrix.\nThe current implementation has you go from matrix to triplet list,\ntriplet list to transposed triplet list. The triplet list must then be\nsorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be transposed. type( Matrix_lsr ), intent(inout) :: matT The input matrix transposed. private pure subroutine TransposeMatrix_lsc(this, matT) Transpose a sparse matrix and return it in a separate matrix.\nThe current implementation has you go from matrix to triplet list,\ntriplet list to transposed triplet list. The triplet list must then be\nsorted and then the return matrix is constructed. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be transposed. type( Matrix_lsc ), intent(inout) :: matT The input matrix transposed. public        interface ConjugateMatrix private pure subroutine ConjugateMatrix_lsc(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: this The matrix to compute the complex conjugate of. public        interface PrintMatrix private  subroutine PrintMatrix_lsr(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. private  subroutine PrintMatrix_lsc(this, file_name_in) Print out a sparse matrix to the console. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to be printed. character(len=*), intent(in), optional :: file_name_in Optionally you can pass a file to print to. public        interface MatrixToTripletList private pure subroutine MatrixToTripletList_lsr(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_r ), intent(inout) :: triplet_list The triplet list we created. private pure subroutine MatrixToTripletList_lsc(this, triplet_list) Construct a triplet list from a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to construct the triplet list from. type( TripletList_c ), intent(inout) :: triplet_list The triplet list we created. public        interface ConvertMatrixType private  subroutine ConvertMatrixType_lsrtolsc(cin, rout) Convert a complex matrix to a real matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: cin The starting matrix. type( Matrix_lsr ), intent(inout) :: rout Real valued matrix. private  subroutine ConvertMatrixType_lsctolsr(rin, cout) Convert a real matrix to a complex matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: rin The starting matrix. type( Matrix_lsc ), intent(inout) :: cout The complex valued matrix. Derived Types type, public :: Matrix_lsr A datatype for storing a local, real CSR matrix. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns type, public :: Matrix_lsc A datatype for storing a local, complex CSR matrix. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: outer_index Outer indices integer, public, DIMENSION(:), ALLOCATABLE :: inner_index Inner indices complex(kind=NTCOMPLEX), public, DIMENSION(:), ALLOCATABLE :: values Values integer, public :: rows Matrix dimension: rows integer, public :: columns Matrix dimension: columns","tags":"","loc":"module/smatrixmodule.html"},{"title":"DataTypesModule – NTPoly","text":"A module to store specifications for basic data types. Uses NTMPIModule iso_c_binding Contents Variables NTREAL MPINTREAL NTCOMPLEX MPINTCOMPLEX NTLONG MPINTINTEGER MPINTLONG Variables Type Visibility Attributes Name Initial integer, public, parameter :: NTREAL = C_DOUBLE The precision of floating point numbers we will use in this program. integer, public :: MPINTREAL = MPI_DOUBLE_PRECISION MPI floating point datatype with the precision we will use in this program. integer, public, parameter :: NTCOMPLEX = C_DOUBLE_COMPLEX The complex numbers we will use in this program. integer, public, parameter :: MPINTCOMPLEX = MPI_DOUBLE_COMPLEX MPI complex datatype with the precision we will use in this program. integer, public, parameter :: NTLONG = C_LONG A long integer type for when normal ints will not do integer, public, parameter :: MPINTINTEGER = MPI_INTEGER MPI Integer type we will use in this program. integer, public, parameter :: MPINTLONG = MPI_LONG MPI Integer type we will use in this program.","tags":"","loc":"module/datatypesmodule.html"},{"title":"ExponentialSolversModule – NTPoly","text":"A Module For Computing Matrix Exponentials and Logarithms. Uses LinearSolversModule EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule ChebyshevSolversModule RootSolversModule DataTypesModule SquareRootSolversModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines ComputeExponential ComputeExponentialPade ComputeExponentialTaylor ComputeDenseExponential ComputeLogarithm ComputeLogarithmTaylor ComputeDenseLogarithm Subroutines public  subroutine ComputeExponential (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeExponentialPade (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a pade approximation.\nBe warned, the pade method can result in a lot of intermediate fill. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeExponentialTaylor (InputMat, OutputMat, solver_parameters_in) Compute the exponential of a matrix using a taylor series expansion.\nThis is only really useful if you have a very small spectrum, because\nquite a bit of scaling is required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeDenseExponential (InputMat, OutputMat, solver_parameters_in) Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeLogarithm (InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeLogarithmTaylor (InputMat, OutputMat, solver_parameters_in) Compute the logarithm of a matrix using a taylor series expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine ComputeDenseLogarithm (InputMat, OutputMat, solver_parameters_in) Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = exp(InputMat) type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/exponentialsolversmodule.html"},{"title":"PermutationModule – NTPoly","text":"Module for load balancing the matrix multiplication calculation. Uses ProcessGridModule NTMPIModule DataTypesModule Contents Derived Types Permutation_t Subroutines ConstructDefaultPermutation ConstructReversePermutation ConstructRandomPermutation ConstructLimitedRandomPermutation CopyPermutation DestructPermutation Derived Types type, public :: Permutation_t A data structure for storing permutations. Components Type Visibility Attributes Name Initial integer, public, DIMENSION(:), ALLOCATABLE :: index_lookup For each row/column, what index does it correspond to in the\nunperturbed matrix. integer, public, DIMENSION(:), ALLOCATABLE :: reverse_index_lookup For each row/column in the unperturbed, what index does it correspond to\nin this matrix. Subroutines public  subroutine ConstructDefaultPermutation (this, matrix_dimension) Constructs a permutation that preserves the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: matrix_dimension The dimension of the matrix. public  subroutine ConstructReversePermutation (this, matrix_dimension) Constructs a permutation that reverses the original order. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. public  subroutine ConstructRandomPermutation (this, matrix_dimension, process_grid_in) Constructs a permutation that has a random order.\nImplements Knuth shuffle. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this A permutation that reverses the original order. integer, intent(in) :: matrix_dimension The size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\nThis is to synchronize random number across processes. public  subroutine ConstructLimitedRandomPermutation (this, actual_matrix_dimension, logical_matrix_dimension, process_grid_in) Constructs a permutation that has a random order, but there is no\npermutation from beyond the actual matrix dimension. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to construct. integer, intent(in) :: actual_matrix_dimension Actual size of the matrix. integer, intent(in) :: logical_matrix_dimension Padded size of the matrix. type( ProcessGrid_t ), intent(inout), optional :: process_grid_in A permutation should be shared amongst these processes.\nThis is to synchronize random number across processes. public  subroutine CopyPermutation (permA, permB) Copy one permutation to another in a safe way. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(in) :: permA Permutation to copy type( Permutation_t ), intent(inout) :: permB permB = permA public pure subroutine DestructPermutation (this) Destruct a permutation object. Arguments Type Intent Optional Attributes Name type( Permutation_t ), intent(inout) :: this The permutation to destruct.","tags":"","loc":"module/permutationmodule.html"},{"title":"LinearSolversModule – NTPoly","text":"Solve the matrix equation AX = B Uses PSMatrixAlgebraModule SMatrixModule NTMPIModule LoggingModule CholeskyModule SolverParametersModule DMatrixModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Subroutines CGSolver CholeskyDecomposition Subroutines public  subroutine CGSolver (AMat, XMat, BMat, solver_parameters_in) Solve the matrix equation AX = B using the conjugate gradient method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: XMat The solved for matrix X. type( Matrix_ps ), intent(in) :: BMat The right hand side. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine CholeskyDecomposition (AMat, LMat, solver_parameters_in) Compute The Cholesky Decomposition of a Hermitian Positive Definite matrix.\nThis is a really naive implementation, that might be worth revisiting. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix A, must be hermitian, positive definite. type( Matrix_ps ), intent(inout) :: LMat The lower diagonal matrix computed. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/linearsolversmodule.html"},{"title":"HermiteSolversModule – NTPoly","text":"A module for computing matrix functions based on Hermite polynomials. Uses PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute Derived Types HermitePolynomial_t Interfaces public        interface ConstructPolynomial private pure subroutine ConstructPolynomial_horner(this, degree) Construct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial. public        interface DestructPolynomial private pure subroutine DestructPolynomial_horner(this) Destruct a Hermite polynomial object. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to destruct. public        interface SetCoefficient private  subroutine SetCoefficient_horner(this, degree, coefficient) Set a coefficient of a Hermite polynomial. Arguments Type Intent Optional Attributes Name type( HermitePolynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree The degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value to set. public        interface Compute private  subroutine Compute_horner(InputMat, OutputMat, poly, solver_parameters_in) Compute The Hermite Polynomial of the matrix.\nThis method uses the standard Hermite Polynomial expansion. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix. type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( HermitePolynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver Derived Types type, public :: HermitePolynomial_t A datatype that represents a Hermite polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/hermitesolversmodule.html"},{"title":"CholeskyModule – NTPoly","text":"Helper Routines for Computing The Cholesky Decomposition Uses ProcessGridModule SMatrixModule NTMPIModule SVectorModule TripletListModule PSMatrixModule DMatrixModule DataTypesModule MatrixReduceModule TripletModule Contents Interfaces AppendToVector BroadcastVector ConstructDiag DotAllHelper DotAllPivoted GatherMatrixColumn GetPivot UnpackCholesky Subroutines ConstructRankLookup Interfaces public        interface AppendToVector private pure subroutine AppendToVector_r(values_per, indices, values, insert_row, insert_value) A helper routine to insert a value into a sparse vector. Arguments Type Intent Optional Attributes Name integer, intent(inout) :: values_per Values per row. integer, intent(inout), DIMENSION(:) :: indices Indices associated with each value. real(kind=NTREAL), intent(inout), DIMENSION(:) :: values Values. integer, intent(in) :: insert_row Row to insert into. real(kind=NTREAL), intent(in) :: insert_value Value to insert. public        interface BroadcastVector private  subroutine BroadcastVector_r(num_values, indices, values, root, comm) A helper routine to broadcast a sparse vector Arguments Type Intent Optional Attributes Name integer, intent(inout) :: num_values Number of values we are broadcasting. integer, intent(inout), DIMENSION(:) :: indices Indices to broadcast. real(kind=NTREAL), intent(inout), DIMENSION(:) :: values Values to broadcast. integer, intent(in) :: root Root from which we broadcast. integer, intent(inout) :: comm Communicator to broadcast along. public        interface ConstructDiag private  subroutine ConstructDiag_r(AMat, process_grid, dense_a, diag) Construct the vector holding the accumulated diagonal values Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat AMat the matrix we are working on (for meta data). type( ProcessGrid_t ), intent(inout) :: process_grid The process grid we are operating on. type( Matrix_ldr ), intent(in) :: dense_a A dense representation of the values. real(kind=NTREAL), intent(inout), DIMENSION(:) :: diag Diagonal values computed. public        interface DotAllHelper private  subroutine DotAllHelper_r(num_values_i, indices_i, values_i, num_values_j, indices_j, values_j, out_values, comm) Helper routine which computes sparse dot products across processors.\nComputes the dot product of one vector with several others. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_values_i The length of vector i. integer, intent(in), DIMENSION(:) :: indices_i The index value of the sparse vector i. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_i The values of the sparse vector i. integer, intent(in), DIMENSION(:) :: num_values_j Tn array with the length of vectors j. integer, intent(in), DIMENSION(:,:) :: indices_j The indices of the vectors j. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values_j The values of the vectors j. real(kind=NTREAL), intent(out), DIMENSION(:) :: out_values The dot product values for each vector j. integer, intent(inout) :: comm The communicator to reduce along. public        interface DotAllPivoted private  subroutine DotAllPivoted_r(num_values_i, indices_i, values_i, num_values_j, indices_j, values_j, pivot_vector, num_local_pivots, out_values, comm) Helper routine which computes sparse dot products across processors.\nComputes the dot product of one vector with several others.\nThe pivoted version has the number of local pivots to work on as a\nparameter. Arguments Type Intent Optional Attributes Name integer, intent(in) :: num_values_i The length of vector i. integer, intent(in), DIMENSION(:) :: indices_i The index value of the sparse vector i. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_i The values of the sparse vector i. integer, intent(in), DIMENSION(:) :: num_values_j Tn array with the length of vectors j. integer, intent(in), DIMENSION(:,:) :: indices_j The indices of the vectors j. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values_j The values of the vectors j. integer, intent(in), DIMENSION(:) :: pivot_vector Vector storing the pivot values. integer, intent(in) :: num_local_pivots Number of pivots. real(kind=NTREAL), intent(out), DIMENSION(:) :: out_values The dot product values for each vector j. integer, intent(inout) :: comm The communicator to reduce along. public        interface GatherMatrixColumn private  subroutine GatherMatrixColumn_r(local_matrix, column_matrix, process_grid) A helper routine that gathers the matrices in the same column into one. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: local_matrix The local matrix on each process. type( Matrix_lsr ), intent(inout) :: column_matrix The final result. type( ProcessGrid_t ), intent(inout) :: process_grid The process grid to operate on. public        interface GetPivot private  subroutine GetPivot_r(AMat, process_grid, start_index, pivot_vector, diag, index, VALUE, local_pivots, num_local_pivots) Compute the pivot vector. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix we are working on. type( ProcessGrid_t ), intent(inout) :: process_grid The process grid to compute on. integer, intent(in) :: start_index The start index to look integer, intent(inout), DIMENSION(:) :: pivot_vector The current pivot vector. real(kind=NTREAL), intent(in), DIMENSION(:) :: diag The diagonal values. integer, intent(out) :: index The pivot index selected. real(kind=NTREAL), intent(out) :: VALUE The pivot value. integer, intent(inout), DIMENSION(:) :: local_pivots The local pivot values to modify. integer, intent(out) :: num_local_pivots Number of pivots stored locally. public        interface UnpackCholesky private  subroutine UnpackCholesky_r(values_per_column, index, values, LMat) Unpack to a global matrix. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: values_per_column The number of values in a column. integer, intent(in), DIMENSION(:,:) :: index Index values. real(kind=NTREAL), intent(in), DIMENSION(:,:) :: values Actual values. type( Matrix_ps ), intent(inout) :: LMat Matrix to unpack into. Subroutines public  subroutine ConstructRankLookup (AMat, process_grid, col_root_lookup) Construct a lookup for columns Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat Matrix we are computing. type( ProcessGrid_t ), intent(inout) :: process_grid Grid we are computing along. integer, intent(inout), DIMENSION(:) :: col_root_lookup The lookup we are computing.","tags":"","loc":"module/choleskymodule.html"},{"title":"EigenSolversModule – NTPoly","text":"A module for computing the eigenvalues of a matrix. Uses PSMatrixAlgebraModule NTMPIModule LoggingModule TripletListModule SolverParametersModule PSMatrixModule DMatrixModule DataTypesModule SMatrixModule Contents Subroutines EigenDecomposition DenseMatrixFunction Subroutines public  subroutine EigenDecomposition (this, eigenvalues, eigenvectors_in, nvals_in, solver_parameters_in) Compute the eigendecomposition of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to decompose. type( Matrix_ps ), intent(inout) :: eigenvalues Diagonal matrix of eigenvalues. type( Matrix_ps ), intent(inout), optional :: eigenvectors_in The eigenvectors of a matrix. integer, intent(in), optional :: nvals_in The number of desired eigenvalues. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for computing public  subroutine DenseMatrixFunction (this, ResultMat, func, solver_parameters_in) Apply an arbitrary matrix function defined by a matrix map as a Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to apply the function to. type( Matrix_ps ), intent(inout) :: ResultMat The transformed matrix private  function func(val) result(outval) The procedure to apply to each eigenvalue. Arguments Type Intent Optional Attributes Name real(kind=NTREAL), intent(in) :: val The actual value of an element. Return Value real(kind=NTREAL) The transformed value. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for computing","tags":"","loc":"module/eigensolversmodule.html"},{"title":"SMatrixAlgebraModule – NTPoly","text":"A module for performing linear algebra using sparse matrices. Uses SVectorModule TripletListModule DMatrixModule DataTypesModule SMatrixModule MatrixMemoryPoolModule Contents Interfaces ScaleMatrix IncrementMatrix DotMatrix PairwiseMultiplyMatrix MatrixMultiply MatrixColumnNorm MatrixNorm MatrixGrandSum Interfaces public        interface ScaleMatrix private pure subroutine ScaleMatrix_lsr(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private pure subroutine ScaleMatrix_lsc(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. real(kind=NTREAL), intent(in) :: constant Constant scale factor. private pure subroutine ScaleMatrix_lsc_c(matA, constant) Will scale a sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(inout) :: matA Matrix A. complex(kind=NTCOMPLEX), intent(in) :: constant Constant scale factor. public        interface IncrementMatrix private pure subroutine IncrementMatrix_lsr(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\nThis will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0). private pure subroutine IncrementMatrix_lsc(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY).\nThis will utilize the sparse vector addition routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0). public        interface DotMatrix private pure subroutine DotMatrix_lsr(matA, matB, product) Product = sum(MatA[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product Dot product. private pure subroutine DotMatrix_lsc(matA, matB, product) Product = sum(MatA&#94;H[ij]*MatB[ij]) Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product Dot product. public        interface PairwiseMultiplyMatrix private pure subroutine PairwiseMultiplyMatrix_lsr(matA, matB, matC) Pairwise Multiply two matrices.\nThis will utilize the sparse vector pairwise multiply routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = MatA mult MatB. private pure subroutine PairwiseMultiplyMatrix_lsc(matA, matB, matC) Pairwise Multiply two matrices.\nThis will utilize the sparse vector pairwise routine. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = MatA mult MatB. public        interface MatrixMultiply private  subroutine GemmMatrix_lsr(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: matA Matrix A. type( Matrix_lsr ), intent(in) :: matB Matrix B. type( Matrix_lsr ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lr ), intent(inout), optional, TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. private  subroutine GemmMatrix_lsc(matA, matB, matC, IsATransposed_in, IsBTransposed_in, alpha_in, beta_in, threshold_in, blocked_memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA op( matB ) + beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: matA Matrix A. type( Matrix_lsc ), intent(in) :: matB Matrix B. type( Matrix_lsc ), intent(inout) :: matC matC = alpha matA op( matB ) + beta*matC. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication. real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. Default value is 0.0. type( MatrixMemoryPool_lc ), intent(inout), optional, TARGET :: blocked_memory_pool_in An optional memory pool for doing the calculation. public        interface MatrixColumnNorm private pure subroutine MatrixColumnNorm_lsr(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. private pure subroutine MatrixColumnNorm_lsc(this, norm_per_column) Compute the norm of a sparse matrix along the columns. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. real(kind=NTREAL), intent(out), DIMENSION(this%columns) :: norm_per_column The norm value for each column in this matrix. public        interface MatrixNorm private pure function MatrixNorm_lsr(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private pure function MatrixNorm_lsc(this) result(norm) Compute the 1 norm of a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. public        interface MatrixGrandSum private pure subroutine MatrixGrandSum_lsr(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: this The matrix to sum real(kind=NTREAL), intent(out) :: sum_value The sum of the matrix elements private pure subroutine MatrixGrandSum_lsc(this, sum_value) Sum the elements of a matrix Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: this The matrix to sum complex(kind=NTCOMPLEX), intent(out) :: sum_value The sum of the matrix elements","tags":"","loc":"module/smatrixalgebramodule.html"},{"title":"EigenBoundsModule – NTPoly","text":"A module for computing estimates of the bounds of the spectrum of a matrix. Uses PSMatrixAlgebraModule NTMPIModule LoggingModule TripletListModule SolverParametersModule PSMatrixModule DataTypesModule PMatrixMemoryPoolModule TripletModule Contents Subroutines GershgorinBounds PowerBounds Subroutines public  subroutine GershgorinBounds (this, min_value, max_value) Compute a bounds on the minimum and maximum eigenvalue of a matrix.\nUses the Gershgorin theorem. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: min_value A lower bound on the eigenspectrum. real(kind=NTREAL), intent(out) :: max_value An uppder bound on the eigenspectrum. public  subroutine PowerBounds (this, max_value, solver_parameters_in) Compute a bounds on the maximum eigenvalue of a matrix.\nUses The Power Method. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the min/max of. real(kind=NTREAL), intent(out) :: max_value An upper bound on the eigenspectrum. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in The parameters for this calculation.","tags":"","loc":"module/eigenboundsmodule.html"},{"title":"PolynomialSolversModule – NTPoly","text":"A Module For Computing General Matrix Polynomials. Uses PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Interfaces ConstructPolynomial DestructPolynomial SetCoefficient Compute FactorizedCompute Derived Types Polynomial_t Interfaces public        interface ConstructPolynomial private pure subroutine ConstructPolynomial_stand(this, degree) Construct a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to construct. integer, intent(in) :: degree The degree of the polynomial. public        interface DestructPolynomial private pure subroutine DestructPolynomial_stand(this) Destruct a polynomial object. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to destruct. public        interface SetCoefficient private  subroutine SetCoefficient_stand(this, degree, coefficient) Set coefficient of a polynomial. Arguments Type Intent Optional Attributes Name type( Polynomial_t ), intent(inout) :: this The polynomial to set. integer, intent(in) :: degree Degree for which to set the coefficient. real(kind=NTREAL), intent(in) :: coefficient Coefficient value. public        interface Compute private  subroutine Compute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using the method of Horner. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly Polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public        interface FactorizedCompute private  subroutine FactorizedCompute_stand(InputMat, OutputMat, poly, solver_parameters_in) Compute A Matrix Polynomial Using The Paterson and Stockmeyer method.\nThis method first factors the polynomial to reduce the number of\nmatrix multiplies required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The input matrix type( Matrix_ps ), intent(inout) :: OutputMat OutputMat = poly(InputMat) type( Polynomial_t ), intent(in) :: poly The polynomial to compute. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. Derived Types type, public :: Polynomial_t A datatype that represents a polynomial. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:), ALLOCATABLE :: coefficients Coefficients of the polynomial.","tags":"","loc":"module/polynomialsolversmodule.html"},{"title":"DMatrixModule – NTPoly","text":"This module allows one to convert a sparse matrix to a dense matrix. It also Uses TripletModule SMatrixModule DataTypesModule Contents Interfaces ConstructEmptyMatrix ConstructMatrixDFromS ConstructMatrixSFromD CopyMatrix DestructMatrix SplitMatrix ComposeMatrix MatrixNorm IncrementMatrix MultiplyMatrix TransposeMatrix EigenDecomposition Derived Types Matrix_ldr Matrix_ldc Interfaces public        interface ConstructEmptyMatrix private pure subroutine ConstructEmptyMatrixSup_ldr(this, rows, columns) A subroutine wrapper for the empty constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to construct integer, intent(in) :: rows Rows of the matrix integer, intent(in) :: columns Columns of the matrix private pure subroutine ConstructEmptyMatrixSup_ldc(this, rows, columns) A subroutine style wrapper for the constructor. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this The matrix to construct. integer, intent(in) :: rows The number of rows of the matrix. integer, intent(in) :: columns The number of columns o the matrix. public        interface ConstructMatrixDFromS private pure subroutine ConstructMatrixDFromS_ldr(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsr ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldr ), intent(inout) :: dense_matrix Output. Must be preallocated. private pure subroutine ConstructMatrixDFromS_ldc(sparse_matrix, dense_matrix) A function that converts a sparse matrix to a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_lsc ), intent(in) :: sparse_matrix The sparse matrix to convert. type( Matrix_ldc ), intent(inout) :: dense_matrix Dense matrix output. Must be preallocated. public        interface ConstructMatrixSFromD private pure subroutine ConstructMatrixSFromD_ldr(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: dense_matrix Matrix to convert. type( Matrix_lsr ), intent(inout) :: sparse_matrix Output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. private pure subroutine ConstructMatrixSFromD_ldc(dense_matrix, sparse_matrix, threshold_in) A function that converts a dense matrix to a sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: dense_matrix The matrix to convert. type( Matrix_lsc ), intent(inout) :: sparse_matrix The sparse output matrix. real(kind=NTREAL), intent(in), optional :: threshold_in Value for pruning values to zero. public        interface CopyMatrix private pure subroutine CopyMatrix_ldr(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA The matrix to copy. type( Matrix_ldr ), intent(inout) :: matB matB = matA private pure subroutine CopyMatrix_ldc(matA, matB) Copy the matrix A into the B. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to copy. type( Matrix_ldc ), intent(inout) :: matB matB = matA public        interface DestructMatrix private pure subroutine DestructMatrix_ldr(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(inout) :: this The matrix to delete. private pure subroutine DestructMatrix_ldc(this) Deallocate the memory associated with this matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(inout) :: this This the matrix to delete. public        interface SplitMatrix private pure subroutine SplitMatrix_ldr(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldr ), intent(inout), DIMENSION(:,:) :: split_array A block_columns x block_rows array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. private pure subroutine SplitMatrix_ldc(this, block_rows, block_columns, split_array, block_size_row_in, block_size_column_in) Split a sparse matrix into an array of sparse matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to split. integer, intent(in) :: block_rows Number of rows to split the matrix into. integer, intent(in) :: block_columns Number of columns to split the matrix into. type( Matrix_ldc ), intent(inout), DIMENSION(:,:) :: split_array A COLUMNxROW array for the output to go into. integer, intent(in), optional, DIMENSION(:) :: block_size_row_in Specifies the size of the  rows. integer, intent(in), optional, DIMENSION(:) :: block_size_column_in Specifies the size of the columns. public        interface ComposeMatrix private pure subroutine ComposeMatrix_ldr(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldr ), intent(inout) :: out_matrix The composed matrix. private pure subroutine ComposeMatrix_ldc(mat_array, block_rows, block_columns, out_matrix) Create a big matrix from an array of matrices by putting them one next\nto another. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in), DIMENSION(block_rows, block_columns) :: mat_array 2d array of matrices to compose. integer, intent(in) :: block_rows The number of rows of the array of blocks. integer, intent(in) :: block_columns The number of columns of the array of blocks. type( Matrix_ldc ), intent(inout) :: out_matrix The composed matrix. public        interface MatrixNorm private  function MatrixNorm_ldr(this) result(norm) Compute the norm of a dense matrix.\nComputes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. private  function MatrixNorm_ldc(this) result(norm) Compute the norm of a dense matrix.\nComputes the Frobenius norm. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm of the matrix. public        interface IncrementMatrix private pure subroutine IncrementMatrix_ldr(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA is added type( Matrix_ldr ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. private pure subroutine IncrementMatrix_ldc(MatA, MatB, alpha_in) AXPY for dense matrices. B = B + alpha*A Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA MatA is added type( Matrix_ldc ), intent(inout) :: MatB MatB is incremented. real(kind=NTREAL), intent(in), optional :: alpha_in A scaling parameter. public        interface MultiplyMatrix private  subroutine MultiplyMatrix_ldr(MatA, MatB, MatC, IsATransposed_in, IsBTransposed_in) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA The first matrix. type( Matrix_ldr ), intent(in) :: MatB The second matrix. type( Matrix_ldr ), intent(inout) :: MatC MatC = MatA*MatB. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. private  subroutine MultiplyMatrix_ldc(MatA, MatB, MatC, IsATransposed_in, IsBTransposed_in) A wrapper for multiplying two dense matrices. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The first matrix. type( Matrix_ldc ), intent(in) :: MatB The second matrix. type( Matrix_ldc ), intent(inout) :: MatC MatC = MatA*MatB. logical, intent(in), optional :: IsATransposed_in True if A is already transposed. logical, intent(in), optional :: IsBTransposed_in True if B is already transposed. public        interface TransposeMatrix private pure subroutine TransposeMatrix_ldr(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: matA matA the matrix to transpose. type( Matrix_ldr ), intent(inout) :: matAT matAT = matA&#94;T. private pure subroutine TransposeMatrix_ldc(matA, matAT) Transpose a dense matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: matA The matrix to transpose. type( Matrix_ldc ), intent(inout) :: matAT matAT = matA&#94;T. public        interface EigenDecomposition private  subroutine EigenDecomposition_ldr(MatA, MatV, MatW) Compute the eigenvectors of a dense matrix.\nWraps a standard dense linear algebra routine. Arguments Type Intent Optional Attributes Name type( Matrix_ldr ), intent(in) :: MatA MatA the matrix to decompose. type( Matrix_ldr ), intent(inout) :: MatV The eigenvectors. type( Matrix_ldr ), intent(inout), optional :: MatW The eigenvalues. private  subroutine EigenDecomposition_ldc(MatA, MatV, MatW) Compute the eigenvectors of a dense matrix.\nWraps a standard dense linear algebra routine. Arguments Type Intent Optional Attributes Name type( Matrix_ldc ), intent(in) :: MatA The matrix to decompose. type( Matrix_ldc ), intent(inout) :: MatV The eigenvectors. type( Matrix_ldc ), intent(inout), optional :: MatW The eigenvalues. Derived Types type, public :: Matrix_ldr A datatype for storing a dense matrix. Components Type Visibility Attributes Name Initial real(kind=NTREAL), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns. type, public :: Matrix_ldc A datatype for storing a dense matrix. Components Type Visibility Attributes Name Initial complex(kind=NTCOMPLEX), public, DIMENSION(:,:), ALLOCATABLE :: DATA values of the matrix. integer, public :: rows Matrix dimension: rows. integer, public :: columns Matrix dimension: columns.","tags":"","loc":"module/dmatrixmodule.html"},{"title":"MatrixMarketModule – NTPoly","text":"This module contains helpers for processing matrix market files. Uses DataTypesModule Contents Variables MAX_LINE_LENGTH Enumerations unnamed Interfaces WriteMMLine Functions ParseMMHeader Subroutines WriteMMSize WriteMMLine_ii WriteMMLine_iif WriteMMLine_iiff WriteMMLine_f WriteMMLine_ff Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_LINE_LENGTH = 1024 The longest line size possible according to the spec. Enumerations enum, bind(c) Enumerators enumerator :: MM_COORDINATE = 1 Sparse coordinate file. enumerator :: MM_ARRAY = 2 Dense array file. enumerator :: MM_REAL = 1 Real data being read in. enumerator :: MM_INTEGER = 2 Integer data being read in. enumerator :: MM_COMPLEX = 3 Complex numbers being read in. enumerator :: MM_PATTERN = 4 Just a pattern of non zeros. enumerator :: MM_GENERAL = 1 File lacks symmetry. enumerator :: MM_SYMMETRIC = 2 File is symmetric enumerator :: MM_SKEW_SYMMETRIC = 3 File is skew symmetric. enumerator :: MM_HERMITIAN = 4 File is hermitian. Interfaces public        interface WriteMMLine public pure subroutine WriteMMLine_ii (outstring, row, column, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iif (outstring, row, column, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iiff (outstring, row, column, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at the coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_f (outstring, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_ff (outstring, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) Functions public  function ParseMMHeader (line, sparsity_type, data_type, pattern_type) result(no_error) Parse a matrix market header. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line String to parse. integer, intent(out) :: sparsity_type If coordinate or array type. integer, intent(out) :: data_type If real, integer, complex, pattern. integer, intent(out) :: pattern_type If general, symmetric, skew_symmetric, hermitian. Return Value logical True if no errors. Subroutines public pure subroutine WriteMMSize (outstring, rows, columns, values_in) Write the line describing the size of the matrix Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: rows The number of rows of the matrix integer, intent(in) :: columns The number of columns of the matrix integer(kind=NTLONG), intent(in), optional :: values_in The total number of non zero values in the matrix (for sparse format). public pure subroutine WriteMMLine_ii (outstring, row, column, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iif (outstring, row, column, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_iiff (outstring, row, column, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. integer, intent(in) :: row The first coordinate value integer, intent(in) :: column The second coordinate value real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at the coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_f (outstring, val, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val The value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.) public pure subroutine WriteMMLine_ff (outstring, val1, val2, add_newline_in) Write a single line that would correspond to a matrix market entry. Arguments Type Intent Optional Attributes Name character(len=MAX_LINE_LENGTH), intent(inout) :: outstring The final string is written to this variable. real(kind=NTREAL), intent(in) :: val1 The value at that coordinate real(kind=NTREAL), intent(in) :: val2 The second value at that coordinate logical, intent(in), optional :: add_newline_in Whether to append a new line to the output (default = .false.)","tags":"","loc":"module/matrixmarketmodule.html"},{"title":"MatrixConversionModule – NTPoly","text":"This module contains helper routines for converting an NTPoly matrix\nto data structures used in other programs. Uses PSMatrixAlgebraModule SMatrixModule PSMatrixModule DataTypesModule Contents Subroutines SnapMatrixToSparsityPattern Subroutines public  subroutine SnapMatrixToSparsityPattern (mat, pattern) Some codes use a fixed sparsity pattern for a matrix instead of filtering\nsmall values. Using this routine, the matrix is filled to have the same\npattern as the second matrix argument. Zeros of the sparsity pattern are\nleft in, whereas values outside the sparsity are removed. This can \nfaciliate conversion between formats. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: mat The matrix to modify. type( Matrix_ps ), intent(in) :: pattern The matrix which defines the sparsity pattern.","tags":"","loc":"module/matrixconversionmodule.html"},{"title":"PSMatrixModule – NTPoly","text":"A Module For Performing Distributed Sparse Matrix Operations. Uses ProcessGridModule SMatrixModule NTMPIModule LoggingModule TripletListModule MatrixMarketModule PermutationModule TripletModule DataTypesModule MatrixReduceModule ErrorModule Contents Interfaces ConstructEmptyMatrix DestructMatrix CopyMatrix ConstructMatrixFromMatrixMarket ConstructMatrixFromBinary WriteMatrixToMatrixMarket WriteMatrixToBinary FillMatrixFromTripletList FillMatrixIdentity FillMatrixPermutation FillMatrixDense GetMatrixActualDimension GetMatrixLogicalDimension GetMatrixTripletList GetMatrixBlock PrintMatrix PrintMatrixInformation GetMatrixLoadBalance GetMatrixSize FilterMatrix MergeMatrixLocalBlocks SplitMatrixToLocalBlocks TransposeMatrix ConjugateMatrix CommSplitMatrix GatherMatrixToProcess Derived Types Matrix_ps Functions IsIdentity Subroutines SetMatrixProcessGrid GetMatrixSlice ConvertMatrixToReal ConvertMatrixToComplex ResizeMatrix Interfaces public        interface ConstructEmptyMatrix private  subroutine ConstructEmptyMatrix_ps(this, matrix_dim, process_grid_in, is_complex_in) Construct an empty sparse, distributed, matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. integer, intent(in) :: matrix_dim The dimension of the full matrix. type( ProcessGrid_t ), intent(in), optional, TARGET :: process_grid_in A process grid to host the matrix. logical, intent(in), optional :: is_complex_in True if you want to use complex numbers. private  subroutine ConstructEmptyMatrix_ps_cp(this, reference_matrix) Construct an empty sparse, distributed, matrix using another matrix\nto determine the parameters. Note that no data is copied, the matrix\nwill be empty. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to be constructed. type( Matrix_ps ), intent(in) :: reference_matrix The reference matrix to take parameters from. public        interface DestructMatrix private pure subroutine DestructMatrix_ps(this) Destruct a distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to destruct. public        interface CopyMatrix private  subroutine CopyMatrix_ps(matA, matB) Copy a distributed sparse matrix in a safe way. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA The matrix to copy. type( Matrix_ps ), intent(inout) :: matB matB = matA. public        interface ConstructMatrixFromMatrixMarket private recursive subroutine ConstructMatrixFromMatrixMarket_ps(this, file_name, process_grid_in) Construct distributed sparse matrix from a matrix market file in parallel.\nRead \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on. public        interface ConstructMatrixFromBinary private recursive subroutine ConstructMatrixFromBinary_ps(this, file_name, process_grid_in) Construct a distributed sparse matrix from a binary file in parallel.\nFaster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The file being constructed. character(len=*), intent(in) :: file_name The name of the file to read. type( ProcessGrid_t ), intent(in), optional :: process_grid_in Grid to distribute the matrix on. public        interface WriteMatrixToMatrixMarket private  subroutine WriteMatrixToMatrixMarket_ps(this, file_name) Write a distributed sparse matrix to a matrix market file.\nRead \\cite boisvert1996matrix for the details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to. public        interface WriteMatrixToBinary private  subroutine WriteMatrixToBinary_ps(this, file_name) Save a distributed sparse matrix to a binary file.\nFaster than text, so this is good for check pointing. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The Matrix to write. character(len=*), intent(in) :: file_name The name of the file to write to. public        interface FillMatrixFromTripletList private  subroutine FillMatrixFromTripletList_psr(this, triplet_list, preduplicated_in, prepartitioned_in) This routine fills in a matrix based on local triplet lists. Each process\nshould pass in triplet lists with global coordinates. It does not matter\nwhere each triplet is stored, as long as global coordinates are given.\nHowever, if you explicitly set prepartitioned_in to True, all data must be\non the correct process. In that case, there is no communication required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to fill. type( TripletList_r ), intent(in) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. logical, intent(in), optional :: prepartitioned_in If all lists only contain local matrix elements set this to true. private  subroutine FillMatrixFromTripletList_psc(this, triplet_list, preduplicated_in, prepartitioned_in) This routine fills in a matrix based on local triplet lists. Each process\nshould pass in triplet lists with global coordinates. It does not matter\nwhere each triplet is stored, as long as global coordinates are given.\nHowever, if you explicitly set prepartitioned_in to True, all data must be\non the correct process. In that case, there is no communication required. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to fill. type( TripletList_c ), intent(in) :: triplet_list The triplet list of values. logical, intent(in), optional :: preduplicated_in If lists are preduplicated across slices set this to true. logical, intent(in), optional :: prepartitioned_in If all lists only contain local matrix elements set this to true. public        interface FillMatrixIdentity private  subroutine FillMatrixIdentity_ps(this) Fill in the values of a distributed matrix with the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. public        interface FillMatrixPermutation private  subroutine FillMatrixPermutation_ps(this, permutation_vector, permute_rows_in) Fill in the values of a distributed matrix with a permutation.\nIf you do not specify permuterows, will default to permuting rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. integer, intent(in), DIMENSION(:) :: permutation_vector Describes for each row/column, where it goes. logical, intent(in), optional :: permute_rows_in If true permute rows, false permute columns. public        interface FillMatrixDense private  subroutine FillMatrixDense_ps(this) This routine will fill a dense matrix so that every element has a given Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix being filled. public        interface GetMatrixActualDimension private pure function GetMatrixActualDimension_ps(this) result(DIMENSION) Get the actual dimension of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix public        interface GetMatrixLogicalDimension private pure function GetMatrixLogicalDimension_ps(this) result(DIMENSION) Get the logical dimension of the matrix.\nIncludes padding. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix. Return Value integer Dimension of the matrix public        interface GetMatrixTripletList private  subroutine GetMatrixTripletList_psr(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. private  subroutine GetMatrixTripletList_psc(this, triplet_list) Extracts a triplet list of the data that is stored on this process.\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. public        interface GetMatrixBlock private  subroutine GetMatrixBlock_psr(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\ndefined by the row/column start/end values.\nThis is slower than GetMatrixTripletList, because communication is required\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_r ), intent(inout) :: triplet_list The list to fill. integer, intent(in) :: start_row The starting row for data to store on this process. integer, intent(in) :: end_row The ending row for data to store on this process. integer, intent(in) :: start_column The starting col for data to store on this process integer, intent(in) :: end_column The ending col for data to store on this process private  subroutine GetMatrixBlock_psc(this, triplet_list, start_row, end_row, start_column, end_column) Extract an arbitrary block of a matrix into a triplet list. Block is\ndefined by the row/column start/end values.\nThis is slower than GetMatrixTripletList, because communication is required\nData is returned with absolute coordinates. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( TripletList_c ), intent(inout) :: triplet_list The list to fill. integer, intent(in) :: start_row The starting row for data to store on this process. integer, intent(in) :: end_row The ending row for data to store on this process. integer, intent(in) :: start_column The starting col for data to store on this process integer, intent(in) :: end_column The ending col for data to store on this process public        interface PrintMatrix private  subroutine PrintMatrix_ps(this, file_name_in) Print out a distributed sparse matrix.\nThis is a serial print routine, and should probably only be used for debug\npurposes. Arguments Type Intent Optional Attributes Name type( Matrix_ps ) :: this The matrix to print. character(len=*), intent(in), optional :: file_name_in Optionally, you can pass a file to print to instead of the console. public        interface PrintMatrixInformation private  subroutine PrintMatrixInformation_ps(this) Print out information about a distributed sparse matrix.\nSparsity, and load balancing information. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this This the matrix to print information about. public        interface GetMatrixLoadBalance private  subroutine GetMatrixLoadBalance_ps(this, min_size, max_size) Get a measure of how load balanced this matrix is. For each process, the\nnumber of non-zero entries is calculated. Then, this function returns\nthe max and min of those values. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the measure on. integer, intent(out) :: min_size The minimum entries contained on a single process. integer, intent(out) :: max_size The maximum entries contained on a single process. public        interface GetMatrixSize private  function GetMatrixSize_ps(this) result(total_size) Get the total number of non-zero entries in the distributed sparse matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to calculate the number of non-zero entries of. Return Value integer(kind=NTLONG) The number of non-zero entries in the matrix. public        interface FilterMatrix private  subroutine FilterMatrix_ps(this, threshold) A utility routine that filters a sparse matrix.\nAll (absolute) values below the threshold are set to zero. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to filter. real(kind=NTREAL), intent(in) :: threshold Threshold (absolute) values below this are filtered public        interface MergeMatrixLocalBlocks private pure subroutine MergeMatrixLocalBlocks_psr(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsr ), intent(inout) :: merged_matrix The merged matrix. private pure subroutine MergeMatrixLocalBlocks_psc(this, merged_matrix) Merge together the local matrix blocks into one big matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix to merge from. type( Matrix_lsc ), intent(inout) :: merged_matrix The merged matrix. public        interface SplitMatrixToLocalBlocks private pure subroutine SplitMatrixToLocalBlocks_psr(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsr ), intent(in) :: matrix_to_split The matrix to split up. private pure subroutine SplitMatrixToLocalBlocks_psc(this, matrix_to_split) Take a local matrix, and use it to fill the local block matrix structure. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The distributed sparse matrix to split into. type( Matrix_lsc ), intent(in) :: matrix_to_split The matrix to split up. public        interface TransposeMatrix private  subroutine TransposeMatrix_ps(AMat, TransMat) Transpose a sparse matrix. Note that this is a pure transpose, there is\nno complex conjugate performed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: AMat The matrix to transpose. type( Matrix_ps ), intent(inout) :: TransMat TransMat = A&#94;T . public        interface ConjugateMatrix private pure subroutine ConjugateMatrix_ps(this) Every value in the matrix is changed into its complex conjugate. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to compute the complex conjugate of. public        interface CommSplitMatrix private  subroutine CommSplitMatrix_ps(this, split_mat, my_color, split_slice) Split the current communicator, and give each group a complete copy of this Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to split. type( Matrix_ps ), intent(inout) :: split_mat A copy of the matrix hosted on a small process grid. integer, intent(out) :: my_color Distinguishes between the two groups. logical, intent(out) :: split_slice If we split along the slice direction, this is True public        interface GatherMatrixToProcess private  subroutine GatherMatrixToProcess_psr_id(this, local_mat, within_slice_id) This subroutine gathers the entire matrix into a local matrix on the\ngiven process. The process id is a within_slice id, so the data will\nstill be replicated across slices. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: within_slice_id Which process to gather on. private  subroutine GatherMatrixToProcess_psr_all(this, local_mat) This subroutine gathers the entire matrix into a local matrix on to\nevery process. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsr ), intent(inout) :: local_mat The full matrix, stored in a local matrix. private  subroutine GatherMatrixToProcess_psc_id(this, local_mat, within_slice_id) This subroutine gathers the entire matrix into a local matrix on the\ngiven process. The process id is a within_slice id, so the data will\nstill be replicated across slices. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix. integer, intent(in) :: within_slice_id Which process to gather on. private  subroutine GatherMatrixToProcess_psc_all(this, local_mat) This subroutine gathers the entire matrix into a local matrix on to\nevery process. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to gather. type( Matrix_lsc ), intent(inout) :: local_mat The full matrix, stored in a local matrix. Derived Types type, public :: Matrix_ps A datatype for a distributed blocked CSR matrix. Components Type Visibility Attributes Name Initial integer, public :: logical_matrix_dimension Number of matrix rows/columns for full matrix, scaled for process grid. integer, public :: actual_matrix_dimension Number of matrix rows/columns for the full matrix, unscaled. type( Matrix_lsr ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_r A 2D array of local CSR matrices. type( Matrix_lsc ), public, DIMENSION(:,:), ALLOCATABLE :: local_data_c A 2D array of local CSC matrices. integer, public :: start_column first column stored locally. integer, public :: end_column last column stored locally  is less than this. integer, public :: start_row first row stored locally. integer, public :: end_row last row stored locally is less than this. integer, public :: local_columns number of local columns. integer, public :: local_rows number of local rows. type( ProcessGrid_t ), public, POINTER :: process_grid process grid to operate on logical, public :: is_complex true if the matrix data is true. Functions public  function IsIdentity (this) result(is_identity) Determine if this is the identity matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix being filled. Return Value logical Result stored here. Subroutines public  subroutine SetMatrixProcessGrid (this, grid) When you want to change the process grid of a matrix, you can call\nthis routine with the new process grid value. Data will be automatically\nredistributed. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to set the grid of. type( ProcessGrid_t ), intent(in) :: grid The grid to set it to. public  subroutine GetMatrixSlice (this, submatrix, start_row, end_row, start_column, end_column) Copy an arbitrary slice from a matrix into a new smaller matrix.\nNTPoly only works with square matrices, so if the number of rows and\ncolumns is different the matrix is resized to the maximum size. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The distributed sparse matrix. type( Matrix_ps ), intent(inout) :: submatrix The slice to fill. integer, intent(in) :: start_row The starting row to include in this matrix. integer, intent(in) :: end_row The ending row to include in this matrix. integer, intent(in) :: start_column The starting column to include in this matrix. integer, intent(in) :: end_column The last column to include in this matrix. public  subroutine ConvertMatrixToReal (in, out) Converts the current matrix to a real type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Real version of the matrix. public  subroutine ConvertMatrixToComplex (in, out) Converts the current matrix to a complex type matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: in The matrix to convert. type( Matrix_ps ), intent(inout) :: out Complex version of the matrix. public  subroutine ResizeMatrix (this, new_size) Change the size of a matrix.\nIf the new size is smaller, then values outside that range are deleted.\nIF the new size is bigger, zero padding is applied.\nWarning: this requires a full data redistribution. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this The matrix to resize. integer, intent(in) :: new_size The new size of the matrix.","tags":"","loc":"module/psmatrixmodule.html"},{"title":"EigenExaModule – NTPoly","text":"A module for calling eigenexa Contents None","tags":"","loc":"module/eigenexamodule.html"},{"title":"SignSolversModule – NTPoly","text":"A Module For Computing The Matrix Sign Function. Uses EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines SignFunction DenseSignFunction PolarDecomposition Subroutines public  subroutine SignFunction (InMat, OutMat, solver_parameters_in) Computes the matrix sign function. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The input matrix. type( Matrix_ps ), intent(inout) :: OutMat The sign of Mat. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. public  subroutine DenseSignFunction (InMat, OutputMat, solver_parameters_in) Computes the matrix sign function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The matrix to compute the sign of. type( Matrix_ps ), intent(inout) :: OutputMat The sign of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine PolarDecomposition (InMat, Umat, Hmat, solver_parameters_in) Computes the polar decomposition of a matrix Mat = U*H. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InMat The input matrix. type( Matrix_ps ), intent(inout) :: Umat The unitary polar factor. type( Matrix_ps ), intent(inout), optional :: Hmat The hermitian matrix factor. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver.","tags":"","loc":"module/signsolversmodule.html"},{"title":"GeometryOptimizationModule – NTPoly","text":"A Module For Geometry Optimization Uses PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule SquareRootSolversModule LoadBalancerModule PMatrixMemoryPoolModule Contents Subroutines PurificationExtrapolate LowdinExtrapolate Subroutines public  subroutine PurificationExtrapolate (PreviousDensity, Overlap, trace, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\nBased on the purification algorithm in \\cite niklasson2010trace . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity Previous density to extrapolate from. type( Matrix_ps ), intent(in) :: Overlap The overlap matrix of the new geometry. real(kind=NTREAL), intent(in) :: trace The trace of the density matrix (usually the number of electrons). type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine LowdinExtrapolate (PreviousDensity, OldOverlap, NewOverlap, NewDensity, solver_parameters_in) Create a new guess at the Density Matrix after updating the geometry.\nBased on the lowdin algorithm in \\cite exner2002comparison . Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: PreviousDensity THe previous density to extrapolate from. type( Matrix_ps ), intent(in) :: OldOverlap The old overlap matrix from the previous geometry. type( Matrix_ps ), intent(in) :: NewOverlap The new overlap matrix from the current geometry. type( Matrix_ps ), intent(inout) :: NewDensity The extrapolated density. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/geometryoptimizationmodule.html"},{"title":"ProcessGridModule – NTPoly","text":"A module to manage the process grid. Uses NTMPIModule ErrorModule LoggingModule Contents Variables global_grid Interfaces ConstructProcessGrid ConstructNewProcessGrid Derived Types ProcessGrid_t Functions IsRoot GetMySlice GetMyColumn GetMyRow Subroutines CopyProcessGrid DestructProcessGrid SplitProcessGrid ComputeGridSize WriteProcessGridInfo Variables Type Visibility Attributes Name Initial type( ProcessGrid_t ), public, TARGET, SAVE :: global_grid The default process grid. Interfaces public        interface ConstructProcessGrid private  subroutine ConstructProcessGrid_full(world_comm, process_rows, process_columns, process_slices, be_verbose_in) Setup the default process grid. Arguments Type Intent Optional Attributes Name integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in) :: process_rows The number of grid rows. integer, intent(in) :: process_columns The number of grid columns. integer, intent(in) :: process_slices The number of grid slices. logical, intent(in), optional :: be_verbose_in Set true to print process grid info. private  subroutine ConstructProcessGrid_onlyslice(world_comm, process_slices_in, be_verbose_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in), optional :: process_slices_in The number of grid slices. logical, intent(in), optional :: be_verbose_in Set true to print process grid info. public        interface ConstructNewProcessGrid private  subroutine ConstructNewProcessGrid_full(grid, world_comm, process_rows, process_columns, process_slices) Construct a process grid. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in) :: process_rows The number of grid rows. integer, intent(in) :: process_columns The number of grid columns. integer, intent(in) :: process_slices The number of grid slices. private  subroutine ConstructNewProcessGrid_onlyslice(grid, world_comm, process_slices_in) Setup a process grid specifying only the slices Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: grid The grid to construct integer, intent(in) :: world_comm A communicator that every process in the grid is a part of. integer, intent(in), optional :: process_slices_in The number of grid slices. Derived Types type, public :: ProcessGrid_t A datatype which stores a process grid and all its communicators. Components Type Visibility Attributes Name Initial integer, public :: total_processors total processors in the grid. integer, public :: num_process_rows number of rows in the grid. integer, public :: num_process_columns number of columns in the grid. integer, public :: num_process_slices number of 2D slices in the grid. integer, public :: slice_size the size of a 2D slice. integer, public :: my_slice which slice is the current process in. integer, public :: my_row which row is the current process in. integer, public :: my_column which column is the current process in. integer, public :: global_rank current process rank amongst processes. integer, public :: within_slice_rank rank for within slice communication. integer, public :: between_slice_rank rank for between slice communication. integer, public :: column_rank rank for within column communication. integer, public :: row_rank rank for within row communication. integer, public :: global_comm communicator with every other process. integer, public :: row_comm communicator within a row. integer, public :: column_comm communicator within a column. integer, public :: within_slice_comm communicator within a slice. integer, public :: between_slice_comm communicator between slices. integer, public :: grid_error stores errors from MPI calls. integer, public :: RootID = 0 Which rank is root? integer, public :: block_multiplier Block scaling factor. integer, public :: number_of_blocks_columns number of column blocks. integer, public :: number_of_blocks_rows number of row blocks. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_row_comm blocked communicator within a row. integer, public, DIMENSION(:), ALLOCATABLE :: blocked_column_comm blocked communicator within a column. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_within_slice_comm blocked communicator within a slice. integer, public, DIMENSION(:,:), ALLOCATABLE :: blocked_between_slice_comm blocked communicator between slices. integer, public :: omp_max_threads The maximum number of openmp threads. Functions public  function IsRoot (grid_in) result(is_root) Check if the current process is the root process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid_in The process grid. Return Value logical True if the current process is root. public  function GetMySlice (grid) result(return_val) Get the slice of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer Slice number of the current process. public  function GetMyColumn (grid) result(return_val) Get the column of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The column number of the current process. public  function GetMyRow (grid) result(return_val) Get the row of the current process. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: grid The process grid. Return Value integer The row number of the current process. Subroutines public  subroutine CopyProcessGrid (old_grid, new_grid) Copy a process grid.\nNote that this makes a complete and independent copy of the process grid.\nWhich of course means that whatever is currently stored in new_grid will\nbe destroyed, so do not leave any matrices pointing to it. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in) :: old_grid The grid to copy. type( ProcessGrid_t ), intent(inout) :: new_grid New_grid = old_grid public recursive subroutine DestructProcessGrid (grid_in) Destruct a process grid.\nBe careful about doing this. Matrices have pointers to process grids. If\nyou destruct a process grid without destructing the matrices pointing to\nit, they will become unusable. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout), optional :: grid_in The grid to destruct. If none specified this destroys the global grid. public  subroutine SplitProcessGrid (old_grid, new_grid, my_color, split_slice, between_grid_comm) Given a process grid, this splits it into two grids of even size Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(inout) :: old_grid The old grid to split type( ProcessGrid_t ), intent(inout) :: new_grid The new grid that we are creating integer, intent(out) :: my_color A color value indicating which set this process was split into logical, intent(out) :: split_slice True if we were able to split along slices. integer, intent(out) :: between_grid_comm A communicator for sending messages between groups. public  subroutine ComputeGridSize (total_processors, set_slices, rows, columns) Sometimes we only want to specify for a process grid the number of slices\nand then automatically compute the right number of rows and columns. Arguments Type Intent Optional Attributes Name integer, intent(in) :: total_processors Total processors in the grid integer, intent(in) :: set_slices Desired number of slices integer, intent(out) :: rows Computed number of rows integer, intent(out) :: columns Computed number of columns public recursive subroutine WriteProcessGridInfo (this) Write out some basic information about this process grid to the log. Arguments Type Intent Optional Attributes Name type( ProcessGrid_t ), intent(in), optional :: this The grid to print about. If not specified, global information printed.","tags":"","loc":"module/processgridmodule.html"},{"title":"TripletModule – NTPoly","text":"A module for the triplet data type. \nEach one stores two indices and a value. This is related to sparse matrices, \nthe referencing indices are usually rows and columns. Uses ErrorModule NTMPIModule DataTypesModule Contents Interfaces SetTriplet GetTripletValues CompareTriplets ConvertTripletType Derived Types Triplet_r Triplet_c Functions GetMPITripletType_r GetMPITripletType_c Interfaces public        interface SetTriplet private pure subroutine SetTriplet_r(this, index_column, index_row, point_value) Set the values of a triplet (real). Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. real(kind=NTREAL), intent(in) :: point_value The value at that point. private pure subroutine SetTriplet_c(this, index_column, index_row, point_value) Set the values of a triplet (complex). Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(inout) :: this The triplet to set the values of. integer, intent(in) :: index_column The column value. integer, intent(in) :: index_row The row value. complex(kind=NTCOMPLEX), intent(in) :: point_value The value at that point. public        interface GetTripletValues private pure subroutine GetTripletValues_r(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. real(kind=NTREAL), intent(out) :: point_value Actual stored value. private pure subroutine GetTripletValues_c(this, index_column, index_row, point_value) Get the values of a triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: this The triplet to extract the values of. integer, intent(out) :: index_column Column value. integer, intent(out) :: index_row Row value. complex(kind=NTCOMPLEX), intent(out) :: point_value Actual stored value. public        interface CompareTriplets private pure function CompareTriplets_r(tripA, tripB) result(islessthan) Compare two triplets based on their index values, first by column and\nsecond by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: tripA First triplet. type( Triplet_r ), intent(in) :: tripB Second triplet. Return Value logical A < B. private pure function CompareTriplets_c(tripA, tripB) result(islessthan) Compare two triplets based on their index values (complex), first by\ncolumn and second by row. Returns A < B. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: tripA First triplet. type( Triplet_c ), intent(in) :: tripB Second triplet. Return Value logical A < B. public        interface ConvertTripletType private  subroutine ConvertTripletToReal(cin_triplet, rout_triplet) Convert a complex triplet to a real triplet. Arguments Type Intent Optional Attributes Name type( Triplet_c ), intent(in) :: cin_triplet The starting triplet type( Triplet_r ), intent(inout) :: rout_triplet Real valued triplet. private  subroutine ConvertTripletToComplex(rin_triplet, cout_triplet) Convert a real triplet to a complex triplet. Arguments Type Intent Optional Attributes Name type( Triplet_r ), intent(in) :: rin_triplet The starting triplet. type( Triplet_c ), intent(inout) :: cout_triplet Complex valued triplet. Derived Types type, public :: Triplet_r A data type for a triplet of integer, integer, double. Components Type Visibility Attributes Name Initial integer, public :: index_column column value. integer, public :: index_row row value. real(kind=NTREAL), public :: point_value actual value at those indices. type, public :: Triplet_c A data type for a triplet of integer, integer, complex. Components Type Visibility Attributes Name Initial integer, public :: index_column column value. integer, public :: index_row row value. complex(kind=NTCOMPLEX), public :: point_value actual value at those indices. Functions public  function GetMPITripletType_r () result(mpi_triplet_type) Returns an MPI derived data type for a triplet (Real).\nWe statically store this derived type so that we do not have to recreate\nit every time this function is called. Thus this functional call should\nadd very little overhead. Arguments None Return Value integer MPI Derived Type public  function GetMPITripletType_c () result(mpi_triplet_type) Returns an MPI derived data type for a triplet (complex).\nWe statically store this derived type so that we do not have to recreate\nit every time this function is called. Thus this functional call should\nadd very little overhead. Arguments None Return Value integer MPI Derived Type","tags":"","loc":"module/tripletmodule.html"},{"title":"LoggingModule – NTPoly","text":"A module for writing data to the log file. Uses DataTypesModule Contents Interfaces WriteListElement WriteElement Functions IsLoggerActive GetLoggerLevel Subroutines ActivateLogger DeactivateLogger EnterSubLog ExitSubLog SetInitialOffset WriteHeader SetLoggerLevel Interfaces public        interface WriteListElement private  subroutine WriteListElement_bool(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: VALUE A bool value to write. private  subroutine WriteListElement_float(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: VALUE A float value to write. private  subroutine WriteListElement_int(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: VALUE An integer value to write. private  subroutine WriteListElement_string(key, VALUE) Write out a list element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: VALUE A text value to write. public        interface WriteElement private  subroutine WriteElement_bool(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. logical, intent(in) :: VALUE An integer value to write. private  subroutine WriteElement_float(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. real(kind=NTReal), intent(in) :: VALUE A float value to write. private  subroutine WriteElement_int(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. integer, intent(in) :: VALUE An integer value to write. private  subroutine WriteElement_string(key, VALUE) Write out a element. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Some text to write. character(len=*), intent(in), optional :: VALUE A text value to write. Functions public  function IsLoggerActive () result(active) Check if the logger is currently active Arguments None Return Value logical public  function GetLoggerLevel () result(level) Get the current logging level Arguments None Return Value integer Subroutines public  subroutine ActivateLogger (start_document_in, file_name_in, unit_in) Activate the logger. Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: start_document_in If this is a new document we can write the start document marker. character(len=*), intent(in), optional :: file_name_in An optional file name for writing to. integer, intent(in), optional :: unit_in An optional fortran i/o unit override. public  subroutine DeactivateLogger () Deactivate the logger. Arguments None public  subroutine EnterSubLog () Call this subroutine when you enter into a section with verbose output Arguments None public  subroutine ExitSubLog () Call this subroutine when you exit a section with verbose output Arguments None public  subroutine SetInitialOffset (offset) Set a manual initial offset spacing. Arguments Type Intent Optional Attributes Name integer, intent(in) :: offset Number of spaces to offset public  subroutine WriteHeader (header_value) Write out a header to the log. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: header_value The text of the header. public  subroutine SetLoggerLevel (level) Set the logging level manually Arguments Type Intent Optional Attributes Name integer, intent(in) :: level","tags":"","loc":"module/loggingmodule.html"},{"title":"PSMatrixAlgebraModule – NTPoly","text":"A Module For Performing Distributed Sparse Matrix Algebra Operations. Uses SMatrixModule NTMPIModule SMatrixAlgebraModule TripletListModule PSMatrixModule GemmTasksModule DataTypesModule MatrixReduceModule PMatrixMemoryPoolModule Contents Interfaces MatrixSigma MatrixMultiply MatrixGrandSum PairwiseMultiplyMatrix MatrixNorm DotMatrix IncrementMatrix ScaleMatrix MatrixTrace Subroutines SimilarityTransform Interfaces public        interface MatrixSigma private  subroutine MatrixSigma_ps(this, sigma_value) Compute sigma for the inversion method.\nSee \\cite ozaki2001efficient for details. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the sigma value of. real(kind=NTREAL), intent(out) :: sigma_value Sigma public        interface MatrixMultiply private  subroutine MatrixMultiply_ps(matA, matB, matC, alpha_in, beta_in, threshold_in, memory_pool_in) Multiply two matrices together, and add to the third.\nC := alpha matA matB+ beta*matC Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = alpha matA matB + beta*matC real(kind=NTREAL), intent(in), optional :: alpha_in Scales the multiplication real(kind=NTREAL), intent(in), optional :: beta_in Scales matrix we sum on to. real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero. type( MatrixMemoryPool_p ), intent(inout), optional :: memory_pool_in A memory pool for the calculation. public        interface MatrixGrandSum private  subroutine MatrixGrandSum_psr(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. real(kind=NTREAL), intent(out) :: sum The sum of all elements. private  subroutine MatrixGrandSum_psc(this, sum) Sum up the elements in a matrix into a single value. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute. complex(kind=NTCOMPLEX), intent(out) :: sum The sum of all elements. public        interface PairwiseMultiplyMatrix private recursive subroutine PairwiseMultiplyMatrix_ps(matA, matB, matC) Elementwise multiplication. C_ij = A_ij * B_ij.\nAlso known as a Hadamard product. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. type( Matrix_ps ), intent(inout) :: matC matC = MatA mult MatB. public        interface MatrixNorm private  function MatrixNorm_ps(this) result(norm_value) Compute the norm of a distributed sparse matrix along the rows. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the norm of. Return Value real(kind=NTREAL) The norm value of the full distributed sparse matrix. public        interface DotMatrix private  subroutine DotMatrix_psr(matA, matB, product) product = dot(Matrix A,Matrix B)\nNote that a dot product is the sum of elementwise multiplication, not\ntraditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. real(kind=NTREAL), intent(out) :: product The dot product. private  subroutine DotMatrix_psc(matA, matB, product) product = dot(Matrix A,Matrix B)\nNote that a dot product is the sum of elementwise multiplication, not\ntraditional matrix multiplication. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(in) :: matB Matrix B. complex(kind=NTCOMPLEX), intent(out) :: product The dot product. public        interface IncrementMatrix private recursive subroutine IncrementMatrix_ps(matA, matB, alpha_in, threshold_in) Matrix B = alpha*Matrix A + Matrix B (AXPY)\nThis will utilize the sparse vector increment routine. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: matA Matrix A. type( Matrix_ps ), intent(inout) :: matB Matrix B. real(kind=NTREAL), intent(in), optional :: alpha_in Multiplier (default = 1.0). real(kind=NTREAL), intent(in), optional :: threshold_in For flushing values to zero (default = 0). public        interface ScaleMatrix private  subroutine ScaleMatrix_psr(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. real(kind=NTREAL), intent(in) :: constant A constant scale factor. private recursive subroutine ScaleMatrix_psc(this, constant) Will scale a distributed sparse matrix by a constant. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(inout) :: this Matrix to scale. complex(kind=NTCOMPLEX), intent(in) :: constant A constant scale factor. public        interface MatrixTrace private  subroutine MatrixTrace_psr(this, trace_value) Compute the trace of the matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: this The matrix to compute the trace of. real(kind=NTREAL), intent(out) :: trace_value The trace value of the full distributed sparse matrix. Subroutines public  subroutine SimilarityTransform (A, P, PInv, ResMat, pool_in, threshold_in) Transform a matrix B = P * A * P&#94;-1 Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: A The matrix to transform type( Matrix_ps ), intent(in) :: P The left matrix. type( Matrix_ps ), intent(in) :: PInv The right matrix. type( Matrix_ps ), intent(inout) :: ResMat The computed matrix P * A * P&#94;-1 type( MatrixMemoryPool_p ), intent(inout), optional :: pool_in A matrix memory pool. real(kind=NTREAL), intent(in), optional :: threshold_in The threshold for removing small elements.","tags":"","loc":"module/psmatrixalgebramodule.html"},{"title":"ErrorModule – NTPoly","text":"A module to do handle error passing. Uses NTMPIModule Contents Derived Types Error_t Functions CheckMPIError CheckAllocError ErrorOccurred Subroutines ConstructError SetGenericError SetCustomError PrintError Cleanup Derived Types type, public :: Error_t A type that can be passed around to accumulate errors. Functions public  function CheckMPIError (this, error_description, mpi_error, immediate_cleanup_in) result(error_occurred) Routine to call to check if an MPI error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: mpi_error The error variable produced by mpi. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. public  function CheckAllocError (this, error_description, alloc_error, immediate_cleanup_in) result(error_occurred) Routine to call if an alloc error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this This the error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. integer, intent(in) :: alloc_error The error variable produced by alloc. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. Return Value logical True if an error has occurred, false otherwise. public  function ErrorOccurred (this) result(occurred) Check if an error has occurred or not. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error variable to check. Return Value logical True if an error has occurred, false otherwise. Subroutines public  subroutine ConstructError (this) Default constructor for an error type. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The newly constructed error type public  subroutine SetGenericError (this, error_description, immediate_cleanup_in) Routine to call if a generic error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this The error variable to be set. character(len=*), intent(in) :: error_description Some string describing the details of the error. logical, intent(in), optional :: immediate_cleanup_in If true, the cleanup error handler is called. public  subroutine SetCustomError (this, error_code, error_description, immediate_cleanup_in) Arguments Type Intent Optional Attributes Name type( Error_t ), intent(inout) :: this integer, intent(in) :: error_code character(len=*), intent(in) :: error_description logical, intent(in), optional :: immediate_cleanup_in public  subroutine PrintError (this) Print out that an error has occurred. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error to print out. public  subroutine Cleanup (this) As a last case resort, this will print an error message and quit. Arguments Type Intent Optional Attributes Name type( Error_t ), intent(in) :: this The error which has caused the need to cleanup the program.","tags":"","loc":"module/errormodule.html"},{"title":"SquareRootSolversModule – NTPoly","text":"A Module For Computing The Square Root of a Matrix. Uses EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule EigenBoundsModule Contents Subroutines SquareRoot DenseSquareRoot InverseSquareRoot DenseInverseSquareRoot Subroutines public  subroutine SquareRoot (InputMat, OutputMat, solver_parameters_in, order_in) Compute the square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). public  subroutine DenseSquareRoot (Mat, OutputMat, solver_parameters_in) Computes the matrix square root function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the square root of. type( Matrix_ps ), intent(inout) :: OutputMat The computed matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine InverseSquareRoot (InputMat, OutputMat, solver_parameters_in, order_in) Compute the inverse square root of a matrix. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute. type( Matrix_ps ), intent(inout) :: OutputMat The resulting matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver. integer, intent(in), optional :: order_in Order of polynomial for calculation (default 5). public  subroutine DenseInverseSquareRoot (Mat, OutputMat, solver_parameters_in) Computes the matrix inverse square root function (dense version). Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: Mat The matrix to compute the inverse square root of. type( Matrix_ps ), intent(inout) :: OutputMat The computed matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/squarerootsolversmodule.html"},{"title":"SVectorModule – NTPoly","text":"A module for handling compressed vectors.\nCompressed vectors are stored in two lists. The first is a list of indices,\nthe second a list of values. Uses DataTypesModule Contents Interfaces AddSparseVectors DotSparseVectors PairwiseMultiplyVectors Interfaces public        interface AddSparseVectors private pure subroutine AddSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\nThe values that are returned for C are only valid in the range\n(1:total_values_c). We do not do an automatic shrinking of the array\nto keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. private pure subroutine AddSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c, alpha_in, threshold_in) Add together two sparse vectors. C = A + alpha*B\nThe values that are returned for C are only valid in the range\n(1:total_values_c). We do not do an automatic shrinking of the array\nto keep this routine low in overhead. Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c The total number of values in C. real(kind=NTREAL), intent(in), optional :: alpha_in Value to scale VecB by. Optional, default is 1.0. real(kind=NTREAL), intent(in), optional :: threshold_in for flushing values to zero. Default value is 0.0. public        interface DotSparseVectors private pure function DotSparseVectors_r(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value real(kind=NTREAL) Dot product. private pure function DotSparseVectors_c(inner_index_a, values_a, inner_index_b, values_b) result(product) product = dot(A,B) Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. Return Value complex(kind=NTCOMPLEX) Dot product. public        interface PairwiseMultiplyVectors private pure subroutine PairwiseMultiplyVectors_r(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. real(kind=NTREAL), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. real(kind=NTREAL), intent(out), DIMENSION(:) :: values_c List of values computed for C. integer, intent(out) :: total_values_c This is the total number of values in C. private pure subroutine PairwiseMultiplyVectors_c(inner_index_a, values_a, inner_index_b, values_b, inner_index_c, values_c, total_values_c) Pairwise Multiply Vectors C = A Mult B Arguments Type Intent Optional Attributes Name integer, intent(in), DIMENSION(:) :: inner_index_a List of indices for A. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_a List of values for A. integer, intent(in), DIMENSION(:) :: inner_index_b List of indices for B. complex(kind=NTCOMPLEX), intent(in), DIMENSION(:) :: values_b List of values for B. integer, intent(out), DIMENSION(:) :: inner_index_c List of indices computed for C. complex(kind=NTCOMPLEX), intent(out), DIMENSION(:) :: values_c This is the total number of values in C. integer, intent(out) :: total_values_c This is the total number of values in C.","tags":"","loc":"module/svectormodule.html"},{"title":"InverseSolversModule – NTPoly","text":"A Module For Computing The Inverse of a Matrix. Uses EigenSolversModule PSMatrixAlgebraModule LoggingModule SolverParametersModule PSMatrixModule DataTypesModule LoadBalancerModule PMatrixMemoryPoolModule Contents Subroutines Invert DenseInvert PseudoInverse Subroutines public  subroutine Invert (InputMat, OutputMat, solver_parameters_in) Compute the inverse of a matrix.\nAn implementation of the method of Hotelling \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to invert. type( Matrix_ps ), intent(inout) :: OutputMat The inverse of that matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine DenseInvert (InputMat, OutputMat, solver_parameters_in) Compute the inverse of a matrix using the eigendecomposition. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: OutputMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver public  subroutine PseudoInverse (InputMat, OutputMat, solver_parameters_in) Compute the pseudoinverse of a matrix.\nAn implementation of the method of Hotelling \\cite palser1998canonical. Arguments Type Intent Optional Attributes Name type( Matrix_ps ), intent(in) :: InputMat The matrix to compute the pseudo inverse of. type( Matrix_ps ), intent(inout) :: OutputMat The pseudoinverse of the input matrix. type( SolverParameters_t ), intent(in), optional :: solver_parameters_in Parameters for the solver","tags":"","loc":"module/inversesolversmodule.html"},{"title":"RootSolversModule.F90 – NTPoly","text":"Contents Modules RootSolversModule Source Code RootSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing General Matrix Roots. MODULE RootSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE InverseSolversModule , ONLY : Invert USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteListElement , & & WriteHeader , WriteElement USE PolynomialSolversModule , ONLY : Polynomial_t , ConstructPolynomial , & & DestructPolynomial , FactorizedCompute , SetCoefficient USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE SquareRootSolversModule , ONLY : SquareRoot , InverseSquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: ComputeRoot PUBLIC :: ComputeInverseRoot CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general matrix root. RECURSIVE SUBROUTINE ComputeRoot ( InputMat , OutputMat , root , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: TempMat !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Root Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Root\" , VALUE = root ) CALL PrintParameters ( params ) END IF !! Handle base cases, or call to general implementation. IF ( root . EQ . 1 ) THEN CALL CopyMatrix ( InputMat , OutputMat ) ELSE IF ( root . EQ . 2 ) THEN CALL SquareRoot ( InputMat , OutputMat , params ) ELSE IF ( root . EQ . 3 ) THEN CALL MatrixMultiply ( InputMat , InputMat , TempMat , & & threshold_in = params % threshold ) CALL ComputeRootImplementation ( TempMat , OutputMat , 6 , params ) ELSE IF ( root . EQ . 4 ) THEN CALL SquareRoot ( InputMat , TempMat , params ) CALL SquareRoot ( TempMat , OutputMat , params ) CALL DestructMatrix ( TempMat ) ELSE CALL ComputeRootImplementation ( InputMat , OutputMat , root , params ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE ComputeRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Actual implementation of computing a general matrix root. SUBROUTINE ComputeRootImplementation ( InputMat , OutputMat , root , params ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !! Local Variables TYPE ( Matrix_ps ) :: RaisedMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Polynomial_t ) :: power_poly INTEGER :: II !! We will use the formula A&#94;(1/x) = A*A&#94;(1/x - 1) !! So first, we raise to the root-1 power CALL ConstructPolynomial ( power_poly , root ) DO II = 1 , root - 1 CALL SetCoefficient ( power_poly , II , 0.0_NTREAL ) END DO CALL SetCoefficient ( power_poly , root , 1.0_NTREAL ) CALL FactorizedCompute ( InputMat , RaisedMat , power_poly , params ) CALL DestructPolynomial ( power_poly ) !! Now compute the inverse pth root CALL ComputeInverseRoot ( RaisedMat , TempMat , root , params ) !! Multiply by the original matrix CALL MatrixMultiply ( InputMat , TempMat , OutputMat , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( RaisedMat ) CALL DestructMatrix ( TempMat ) END SUBROUTINE ComputeRootImplementation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general inverse matrix root. RECURSIVE SUBROUTINE ComputeInverseRoot ( InputMat , OutputMat , root , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = InputMat&#94;-1/root. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: TempMat !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Inverse Root Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Root\" , VALUE = root ) CALL PrintParameters ( params ) END IF !! Handle base cases, or call to general implementation. IF ( root . EQ . 1 ) THEN CALL Invert ( InputMat , OutputMat , params ) ELSE IF ( root . EQ . 2 ) THEN CALL InverseSquareRoot ( InputMat , OutputMat , params ) ELSE IF ( root . EQ . 3 ) THEN CALL ComputeRoot ( InputMat , TempMat , 3 , params ) CALL Invert ( TempMat , OutputMat , params ) ELSE IF ( root . EQ . 4 ) THEN CALL SquareRoot ( InputMat , TempMat , params ) CALL InverseSquareRoot ( TempMat , OutputMat , params ) CALL DestructMatrix ( TempMat ) ELSE CALL ComputeInverseRootImplemention ( InputMat , OutputMat , root , params ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE ComputeInverseRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a general inverse matrix root for root > 4. SUBROUTINE ComputeInverseRootImplemention ( InputMat , OutputMat , root , params ) !> Matrix to compute the root of. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The inverse nth root of that matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Which inverse root to compute. INTEGER , INTENT ( IN ) :: root !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !! Constants. REAL ( NTREAL ), PARAMETER :: NEGATIVE_ONE = - 1.0 !! Local Matrices TYPE ( Matrix_ps ) :: SqrtMat , FthrtMat TYPE ( Matrix_ps ) :: IdentityMat TYPE ( Matrix_ps ) :: Mk TYPE ( Matrix_ps ) :: IntermediateMat TYPE ( Matrix_ps ) :: IntermediateMatP TYPE ( Matrix_ps ) :: Temp !! Local Variables INTEGER :: target_root REAL ( NTREAL ) :: e_min REAL ( NTREAL ) :: e_max REAL ( NTREAL ) :: scaling_factor REAL ( NTREAL ) :: norm_value !! Temporary Variables INTEGER :: II INTEGER :: JJ TYPE ( MatrixMemoryPool_p ) :: pool IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Root Solver\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"nicholas2008functions\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) scaling_factor = e_max / SQRT ( 2.0 ) ** ( 1.0 / root ) !! Compute the target root (adjust for the fact that we just took the !! fourth root. target_root = 0 IF ( MOD ( root , 4 ) . EQ . 0 ) THEN target_root = root / 4 ELSE IF ( MOD ( root , 4 ) . EQ . 1 . OR . MOD ( root , 4 ) . EQ . 3 ) THEN target_root = root ELSE target_root = ( root - 2 ) / 2 + 1 END IF !! Initialize !! Fourth Root Matrix CALL SquareRoot ( InputMat , SqrtMat , params ) CALL SquareRoot ( SqrtMat , FthrtMat , params ) CALL DestructMatrix ( SqrtMat ) !! Setup the Matrices CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( FthrtMat , FthrtMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & params % BalancePermutation , memorypool_in = pool ) END IF CALL CopyMatrix ( IdentityMat , OutputMat ) CALL ScaleMatrix ( OutputMat , 1.0 / scaling_factor ) CALL CopyMatrix ( FthrtMat , Mk ) CALL ScaleMatrix ( Mk , 1.0 / ( scaling_factor ** target_root )) CALL DestructMatrix ( FthrtMat ) CALL ConstructEmptyMatrix ( IntermediateMat , InputMat ) CALL ConstructEmptyMatrix ( IntermediateMatP , InputMat ) CALL ConstructEmptyMatrix ( Temp , InputMat ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations IF ( params % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF CALL CopyMatrix ( IdentityMat , IntermediateMat ) CALL ScaleMatrix ( IntermediateMat , & & REAL ( target_root + 1 , NTREAL )) CALL IncrementMatrix ( Mk , IntermediateMat , & & alpha_in =- 1.0_NTREAL ) CALL ScaleMatrix ( IntermediateMat , 1.0_NTREAL / target_root ) CALL MatrixMultiply ( OutputMat , IntermediateMat , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , OutputMat ) CALL CopyMatrix ( IntermediateMat , IntermediateMatP ) DO JJ = 1 , target_root - 1 CALL MatrixMultiply ( IntermediateMat , IntermediateMatP , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , IntermediateMatP ) END DO CALL MatrixMultiply ( IntermediateMatP , Mk , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , Mk ) CALL IncrementMatrix ( IdentityMat , Temp , & & alpha_in =- 1.0_NTREAL ) norm_value = MatrixNorm ( Temp ) IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) CALL PrintMatrixInformation ( OutputMat ) END IF IF ( MOD ( root , 4 ) . EQ . 1 . OR . MOD ( root , 4 ) . EQ . 3 ) THEN CALL MatrixMultiply ( OutputMat , OutputMat , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp , Temp , OutputMat , & & threshold_in = params % threshold , memory_pool_in = pool ) ELSE IF ( MOD ( root , 4 ) . NE . 0 ) THEN CALL MatrixMultiply ( OutputMat , OutputMat , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temp , OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Mk ) CALL DestructMatrix ( IntermediateMat ) CALL DestructMatrix ( IntermediateMatP ) CALL DestructMatrix ( Temp ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE ComputeInverseRootImplemention !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE RootSolversModule","tags":"","loc":"sourcefile/rootsolversmodule.f90.html"},{"title":"SingularValueSolversModule.F90 – NTPoly","text":"Contents Modules SingularValueSolversModule Source Code SingularValueSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing the singular values of a matrix. MODULE SingularValueSolversModule USE EigenSolversModule , ONLY : EigenDecomposition USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , WriteElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply USE PSMatrixModule , ONLY : Matrix_ps , DestructMatrix USE SignSolversModule , ONLY : PolarDecomposition USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SingularValueDecomposition CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the singular values and singular vectors of a matrix. SUBROUTINE SingularValueDecomposition ( this , left_vectors , & & right_vectors , singularvalues , solver_parameters_in ) !> The matrix to decompose. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> A matrix containing the left singular vectors. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: left_vectors !> A matrix containing the right singular vectors. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: right_vectors !> A diagonal matrix containing the singularvalues. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: singularvalues !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: UMat , HMat !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Singular Value Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Polar\" ) CALL PrintParameters ( params ) END IF !! First compute the polar decomposition of the matrix. CALL PolarDecomposition ( this , UMat , HMat , params ) !! Compute the eigen decomposition of the hermitian matrix CALL EigenDecomposition ( HMat , singularvalues , & & eigenvectors_in = right_vectors , solver_parameters_in = params ) !! Compute the left singular vectors CALL MatrixMultiply ( UMat , right_vectors , left_vectors , & & threshold_in = params % threshold ) !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) CALL DestructMatrix ( UMat ) CALL DestructMatrix ( HMat ) END SUBROUTINE SingularValueDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SingularValueSolversModule","tags":"","loc":"sourcefile/singularvaluesolversmodule.f90.html"},{"title":"AnalysisModule.F90 – NTPoly","text":"Contents Modules AnalysisModule Source Code AnalysisModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Methods for analyzing the results of electronic structure calculations. MODULE AnalysisModule USE CholeskyModule , ONLY : ConstructRankLookup , AppendToVector , & & BroadcastVector , ConstructDiag , DotAllHelper , DotAllPivoted , & & GatherMatrixColumn , GetPivot , UnpackCholesky USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE DensityMatrixSolversModule , ONLY : TRS4 USE DMatrixModule , ONLY : Matrix_ldr , DestructMatrix , & & ConstructMatrixDFromS USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader , WriteListElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , SimilarityTransform USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & TransposeMatrix , DestructMatrix , ConjugateMatrix , CopyMatrix , & & FillMatrixIdentity , PrintMatrixInformation , MergeMatrixLocalBlocks , & & GetMatrixSlice USE SMatrixModule , ONLY : Matrix_lsr USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: PivotedCholeskyDecomposition PUBLIC :: ReduceDimension CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Pivoted Cholesky Decomposition of a Hermitian Semi-Definite !> matrix. This is one way to generate localized orbitals. SUBROUTINE PivotedCholeskyDecomposition ( AMat , LMat , rank_in , & & solver_parameters_in ) !> The matrix A, must be hermitian, positive semi-definite. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The matrix computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: LMat !> The target rank of the matrix. INTEGER , INTENT ( IN ) :: rank_in !> Tarameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! For Pivoting INTEGER , DIMENSION (:), ALLOCATABLE :: pivot_vector REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: diag INTEGER :: pi_j !! Local Variables TYPE ( Matrix_lsr ) :: sparse_a TYPE ( Matrix_lsr ) :: acol TYPE ( Matrix_ldr ) :: dense_a !! For Storing The Results INTEGER , DIMENSION (:), ALLOCATABLE :: values_per_column_l INTEGER , DIMENSION (:,:), ALLOCATABLE :: index_l REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: values_l !! Broadcasted Column INTEGER , DIMENSION (:), ALLOCATABLE :: recv_index REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_values INTEGER :: recv_num_values !! Which pivots to treat locally INTEGER , DIMENSION (:), ALLOCATABLE :: local_pivots INTEGER :: num_local_pivots !! Root Lookups INTEGER , DIMENSION (:), ALLOCATABLE :: col_root_lookup !! Temporary Variables REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: a_buf INTEGER :: II , JJ , local_JJ INTEGER :: local_pi_i , local_pi_j REAL ( NTREAL ) :: Aval , insert_value , inverse_factor REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: dot_values INTEGER :: col_root INTEGER :: ierr !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Print out parameters IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Linear Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , & & VALUE = \"Pivoted Cholesky Decomposition\" ) CALL WriteElement ( key = \"Target_Rank\" , VALUE = rank_in ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"aquilante2006fast\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF CALL ConstructEmptyMatrix ( LMat , AMat ) !! Construct the pivot vector ALLOCATE ( pivot_vector ( AMat % actual_matrix_dimension )) DO JJ = 1 , AMat % actual_matrix_dimension pivot_vector ( JJ ) = JJ END DO !! First get the local matrix in a dense recommendation for quick lookup CALL MergeMatrixLocalBlocks ( AMat , sparse_a ) CALL ConstructMatrixDFromS ( sparse_a , dense_a ) ALLOCATE ( local_pivots ( sparse_a % columns )) !! Extract the diagonal ALLOCATE ( diag ( sparse_a % columns )) CALL ConstructDiag ( AMat , Lmat % process_grid , dense_a , diag ) !! Root Lookups ALLOCATE ( col_root_lookup ( AMat % logical_matrix_dimension )) CALL ConstructRankLookup ( AMat , LMat % process_grid , col_root_lookup ) !! Allocate space for L ALLOCATE ( values_per_column_l ( sparse_a % columns )) ALLOCATE ( index_l ( sparse_a % rows , sparse_a % columns )) ALLOCATE ( values_l ( sparse_a % rows , sparse_a % columns )) values_per_column_l = 0 !! Buffer for fast indexing of A ALLOCATE ( a_buf ( sparse_a % columns )) a_buf = 0 !! Allocate space for a received column ALLOCATE ( recv_index ( sparse_a % rows )) ALLOCATE ( recv_values ( sparse_a % rows )) ALLOCATE ( dot_values ( sparse_a % columns )) !! Pregather the full column of A. CALL GatherMatrixColumn ( sparse_a , acol , LMat % process_grid ) !! Main Loop DO JJ = 1 , rank_in !! Pick a pivot vector local_JJ = JJ - AMat % start_row + 1 CALL GetPivot ( AMat , LMat % process_grid , JJ , pivot_vector , diag , pi_j , & & insert_value , local_pivots , num_local_pivots ) IF ( pi_j . GE . AMat % start_column . AND . pi_j . LT . AMat % end_column ) THEN local_pi_j = pi_j - AMat % start_column + 1 insert_value = SQRT ( insert_value ) inverse_factor = 1.0_NTREAL / insert_value !! Insert IF ( JJ . GE . AMat % start_row . AND . JJ . LT . AMat % end_row ) THEN CALL AppendToVector ( values_per_column_l ( local_pi_j ), & & index_l (:, local_pi_j ), values_l (:, local_pi_j ), & & local_JJ , insert_value ) END IF !! Extract column J for sending later recv_num_values = values_per_column_l ( local_pi_j ) recv_index (: recv_num_values ) = index_l (: recv_num_values , local_pi_j ) recv_values (: recv_num_values ) = values_l (: recv_num_values , local_pi_j ) END IF col_root = col_root_lookup ( pi_j ) !! Broadcast column JJ, and Inverse Factor CALL BroadcastVector ( recv_num_values , recv_index , recv_values , & & col_root , LMat % process_grid % row_comm ) CALL MPI_Bcast ( inverse_factor , 1 , MPINTREAL , col_root , & & LMat % process_grid % row_comm , ierr ) !! Extract the row of A to a dense matrix for easy lookup DO II = MAX ( acol % outer_index ( pi_j ), 1 ), acol % outer_index ( pi_j + 1 ) a_buf ( acol % inner_index ( II )) = acol % values ( II ) END DO !! Compute Dot Products CALL DotAllPivoted ( recv_num_values , recv_index , recv_values , & & values_per_column_l , index_l , values_l , local_pivots , & & num_local_pivots , dot_values , LMat % process_grid % column_comm ) !! Loop over other columns DO II = 1 , num_local_pivots !! Insert Into L local_pi_i = local_pivots ( II ) Aval = a_buf ( local_pi_i ) insert_value = inverse_factor * ( Aval - dot_values ( II )) IF ( ABS ( insert_value ) . GT . params % threshold ) THEN IF ( JJ . GE . AMat % start_row . AND . JJ . LT . AMat % end_row ) THEN CALL AppendToVector ( values_per_column_l ( local_pi_i ), & & index_l (:, local_pi_i ), values_l (:, local_pi_i ), & & local_JJ , insert_value ) END IF END IF !! Update Diagonal Array diag ( local_pi_i ) = diag ( local_pi_i ) - insert_value ** 2 END DO !! Clear up the A buffer DO II = MAX ( acol % outer_index ( pi_j ), 1 ), acol % outer_index ( pi_j + 1 ) a_buf ( acol % inner_index ( II )) = 0 END DO END DO !! Unpack CALL UnpackCholesky ( values_per_column_l , index_l , values_l , LMat ) !! Cleanup IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( LMat ) CALL ExitSubLog END IF DEALLOCATE ( local_pivots ) DEALLOCATE ( pivot_vector ) DEALLOCATE ( diag ) CALL DestructMatrix ( dense_a ) DEALLOCATE ( values_per_column_l ) DEALLOCATE ( index_l ) DEALLOCATE ( values_l ) DEALLOCATE ( recv_index ) DEALLOCATE ( recv_values ) DEALLOCATE ( dot_values ) DEALLOCATE ( a_buf ) DEALLOCATE ( col_root_lookup ) CALL DestructMatrix ( sparse_a ) CALL DestructMatrix ( acol ) END SUBROUTINE PivotedCholeskyDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> When we want to only compute the first n eigenvalues of a matrix, this !> routine will project out the higher eigenvalues. SUBROUTINE ReduceDimension ( this , dim , ReducedMat , solver_parameters_in ) !> The starting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The number of eigenvalues ot keep. INTEGER , INTENT ( IN ) :: dim !> a dimxdim matrix with the same first n eigenvalues as the first. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: ReducedMat !> The solver parameters. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Local Variables - matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: PMat TYPE ( Matrix_ps ) :: PVec , PVecT TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: VAV !! Special parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Identity matrix passed instead of ISQ CALL ConstructEmptyMatrix ( Identity , this ) CALL FillMatrixIdentity ( Identity ) !! Purify CALL TRS4 ( this , Identity , REAL ( dim , KIND = NTREAL ), PMat , & & solver_parameters_in = params ) !! Compute Eigenvectors of the Density Matrix CALL PivotedCholeskyDecomposition ( PMat , PVec , dim , & & solver_parameters_in = params ) CALL TransposeMatrix ( PVec , PVecT ) IF ( PVecT % is_complex ) THEN CALL ConjugateMatrix ( PVecT ) END IF !! Rotate to the divided subspace CALL SimilarityTransform ( this , PVecT , PVec , VAV , & & threshold_in = params % threshold ) !! Extract CALL GetMatrixSlice ( VAV , ReducedMat , 1 , dim , 1 , dim ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( PMat ) CALL DestructMatrix ( PVec ) CALL DestructMatrix ( PVecT ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( VAV ) CALL DestructSolverParameters ( params ) END SUBROUTINE ReduceDimension !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE AnalysisModule","tags":"","loc":"sourcefile/analysismodule.f90.html"},{"title":"ChebyshevSolversModule.F90 – NTPoly","text":"Contents Modules ChebyshevSolversModule Source Code ChebyshevSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Matrix functions based on Chebyshev polynomials. MODULE ChebyshevSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : WriteElement , WriteHeader , EnterSubLog , ExitSubLog USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , FillMatrixIdentity , & & PrintMatrixInformation , ConstructEmptyMatrix , DestructMatrix , & & CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a Chebyshev polynomial. TYPE , PUBLIC :: ChebyshevPolynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE ChebyshevPolynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute PUBLIC :: FactorizedCompute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_cheby END INTERFACE ConstructPolynomial INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_cheby END INTERFACE DestructPolynomial INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_cheby END INTERFACE SetCoefficient INTERFACE Compute MODULE PROCEDURE Compute_cheby END INTERFACE Compute INTERFACE FactorizedCompute MODULE PROCEDURE FactorizedCompute_cheby END INTERFACE FactorizedCompute CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a Chebyshev polynomial object. PURE SUBROUTINE ConstructPolynomial_cheby ( this , degree ) !> The polynomial to construct. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this !> Degree of the polynomial. INTEGER , INTENT ( IN ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0_NTREAL END SUBROUTINE ConstructPolynomial_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a polynomial object. PURE SUBROUTINE DestructPolynomial_cheby ( this ) !> The polynomial to destruct. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set a coefficient of a Chebyshev polynomial. SUBROUTINE SetCoefficient_cheby ( this , degree , coefficient ) !> The polynomial to set. TYPE ( ChebyshevPolynomial_t ), INTENT ( INOUT ) :: this !> Degree for which to set the coefficient. INTEGER , INTENT ( IN ) :: degree !> Coefficient value. REAL ( NTREAL ), INTENT ( IN ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Chebyshev Polynomial of the matrix. !> This method uses the standard Chebyshev Polynomial expansion. SUBROUTINE Compute_cheby ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The Chebyshev polynomial to compute. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Tk TYPE ( Matrix_ps ) :: Tkminus1 TYPE ( Matrix_ps ) :: Tkminus2 TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: II !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF degree = SIZE ( poly % coefficients ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Chebyshev Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Standard\" ) CALL WriteElement ( key = \"Degree\" , VALUE = degree - 1 ) CALL PrintParameters ( params ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & params % BalancePermutation , memorypool_in = pool ) END IF !! First Term CALL CopyMatrix ( Identity , Tkminus2 ) IF ( degree == 1 ) THEN CALL CopyMatrix ( Tkminus2 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) ELSE CALL CopyMatrix ( BalancedInput , Tkminus1 ) CALL CopyMatrix ( Tkminus2 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) CALL IncrementMatrix ( Tkminus1 , OutputMat , & & alpha_in = poly % coefficients ( 2 )) IF ( degree . GT . 2 ) THEN CALL MatrixMultiply ( BalancedInput , Tkminus1 , Tk , & & alpha_in = 2.0_NTREAL , threshold_in = params % threshold , & & memory_pool_in = pool ) CALL IncrementMatrix ( Tkminus2 , Tk , alpha_in = - 1.0_NTREAL ) CALL IncrementMatrix ( Tk , OutputMat , & & alpha_in = poly % coefficients ( 3 )) DO II = 4 , degree CALL CopyMatrix ( Tkminus1 , Tkminus2 ) CALL CopyMatrix ( Tk , Tkminus1 ) CALL MatrixMultiply ( BalancedInput , Tkminus1 , Tk , & & alpha_in = 2.0_NTREAL , threshold_in = params % threshold , & & memory_pool_in = pool ) CALL IncrementMatrix ( Tkminus2 , Tk , alpha_in = - 1.0_NTREAL ) CALL IncrementMatrix ( Tk , OutputMat , & & alpha_in = poly % coefficients ( II )) END DO END IF END IF IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Identity ) CALL DestructMatrix ( Tk ) CALL DestructMatrix ( Tkminus1 ) CALL DestructMatrix ( Tkminus2 ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE Compute_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Chebyshev Polynomial of the matrix. !> This version first factors the Chebyshev Polynomial and computes the !> function using a divide and conquer algorithm. Based on a simplified !> version of the first method in \\cite liang2003improved . SUBROUTINE FactorizedCompute_cheby ( InputMat , OutputMat , poly , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The Chebyshev polynomial to compute. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ), DIMENSION (:), ALLOCATABLE :: T_Powers TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: log2degree INTEGER :: II !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF degree = SIZE ( poly % coefficients ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Chebyshev Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Recursive\" ) CALL WriteElement ( key = \"Degree\" , VALUE = degree - 1 ) CALL PrintParameters ( params ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Construct The X Powers Array !! First, compute how many powers of two are necessary to compute. log2degree = 1 DO WHILE ( 2 ** log2degree . LE . degree ) log2degree = log2degree + 1 END DO ALLOCATE ( T_Powers ( log2degree )) !! Now compute those powers of two CALL CopyMatrix ( Identity , T_Powers ( 1 )) IF ( degree . EQ . 1 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) ELSE CALL CopyMatrix ( BalancedInput , T_Powers ( 2 )) DO II = 3 , log2degree CALL MatrixMultiply ( T_Powers ( II - 1 ), T_Powers ( II - 1 ), & & T_Powers ( II ), threshold_in = params % threshold , & & alpha_in = 2.0_NTREAL , memory_pool_in = pool ) CALL IncrementMatrix ( Identity , T_Powers ( II ), alpha_in = - 1.0_NTREAL ) END DO !! Call Recursive CALL ComputeRecursive ( T_Powers , poly , OutputMat , pool , 1 , params ) END IF IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF DO II = 1 , log2degree CALL DestructMatrix ( T_Powers ( II )) END DO DEALLOCATE ( T_Powers ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE FactorizedCompute_cheby !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The workhorse routine for the factorized chebyshev computation function. RECURSIVE SUBROUTINE ComputeRecursive ( T_Powers , poly , OutputMat , pool , & & depth , params ) !> The precomputed Chebyshev polynomials. TYPE ( Matrix_ps ), DIMENSION (:), INTENT ( IN ) :: T_Powers !> Polynomial coefficients. TYPE ( ChebyshevPolynomial_t ), INTENT ( IN ) :: poly !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The depth of recursion. INTEGER , INTENT ( in ) :: depth !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> The memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: pool !! Local Data INTEGER :: coefficient_midpoint INTEGER :: left_length , right_length INTEGER :: full_midpoint TYPE ( ChebyshevPolynomial_t ) :: left_poly TYPE ( ChebyshevPolynomial_t ) :: right_poly TYPE ( Matrix_ps ) :: LeftMat TYPE ( Matrix_ps ) :: RightMat INTEGER :: II !! First Handle The Base Case IF ( SIZE ( poly % coefficients ) . EQ . 1 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) ELSE IF ( SIZE ( poly % coefficients ) . EQ . 2 ) THEN CALL CopyMatrix ( T_Powers ( 1 ), OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) CALL IncrementMatrix ( T_Powers ( 2 ), OutputMat , & & alpha_in = poly % coefficients ( 2 )) ELSE !! Adjust the coefficients. coefficient_midpoint = SIZE ( poly % coefficients ) / 2 left_length = coefficient_midpoint right_length = SIZE ( poly % coefficients ) - coefficient_midpoint ALLOCATE ( left_poly % coefficients ( left_length )) ALLOCATE ( right_poly % coefficients ( right_length )) left_poly % coefficients (:) = poly % coefficients (: coefficient_midpoint ) right_poly % coefficients (:) = poly % coefficients ( coefficient_midpoint + 1 :) DO II = 2 , SIZE ( left_poly % coefficients ) left_poly % coefficients ( II ) = left_poly % coefficients ( II ) - & & poly % coefficients ( SIZE ( poly % coefficients ) - II + 2 ) END DO !! Left recursion CALL ComputeRecursive ( T_Powers , left_poly , LeftMat , pool , depth + 1 , & & params ) !! Right recursion full_midpoint = SIZE ( T_Powers ) - depth + 1 CALL ComputeRecursive ( T_Powers , right_poly , RightMat , pool , depth + 1 , & & params ) !! Sum Together CALL MatrixMultiply ( T_Powers ( full_midpoint ), RightMat , & & OutputMat , threshold_in = params % threshold , & & alpha_in = 2.0_NTREAL , memory_pool_in = pool ) CALL IncrementMatrix ( LeftMat , OutputMat ) CALL IncrementMatrix ( T_Powers ( full_midpoint ), & & OutputMat , alpha_in = - 1.0 * right_poly % coefficients ( 1 )) !! Cleanup DEALLOCATE ( left_poly % coefficients ) DEALLOCATE ( right_poly % coefficients ) CALL DestructMatrix ( LeftMat ) CALL DestructMatrix ( RightMat ) END IF END SUBROUTINE ComputeRecursive !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ChebyshevSolversModule","tags":"","loc":"sourcefile/chebyshevsolversmodule.f90.html"},{"title":"NTMPIModule.F90 – NTPoly","text":"Contents Modules NTMPIModule Source Code NTMPIModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module wraps the MPI include statement because on certain platforms !> just writing \"USE MPI\" does not work. MODULE NTMPIModule #if USE_MPIH INCLUDE \"mpif.h\" #else USE MPI #endif END MODULE NTMPIModule","tags":"","loc":"sourcefile/ntmpimodule.f90.html"},{"title":"TrigonometrySolversModule.F90 – NTPoly","text":"Contents Modules TrigonometrySolversModule Source Code TrigonometrySolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Trigonometric functions of a Matrix. MODULE TrigonometrySolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE EigenSolversModule , ONLY : DenseMatrixFunction USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteListElement , WriteElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: Sine PUBLIC :: DenseSine PUBLIC :: Cosine PUBLIC :: DenseCosine PUBLIC :: ScaleSquareTrigonometryTaylor CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the sine of a matrix. SUBROUTINE Sine ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Optional parameters TYPE ( SolverParameters_t ) :: params !! A temporary matrix to hold the transformation from sine to cosine. TYPE ( Matrix_ps ) :: ShiftedMat TYPE ( Matrix_ps ) :: IdentityMat REAL ( NTREAL ), PARAMETER :: PI = 4 * ATAN ( 1.00_NTREAL ) !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Shift CALL CopyMatrix ( InputMat , ShiftedMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) CALL IncrementMatrix ( IdentityMat , ShiftedMat , & & alpha_in = - 1.0_NTREAL * PI / 2.0_NTREAL ) CALL DestructMatrix ( IdentityMat ) CALL ScaleSquareTrigonometry ( ShiftedMat , OutputMat , solver_parameters_in ) !! Cleanup CALL DestructMatrix ( ShiftedMat ) !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE Sine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the sine of a matrix. (dense version). SUBROUTINE DenseSine ( Mat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The sine of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Sine Function Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( Mat , OutputMat , SineLambda , params ) !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE DenseSine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the cosine of a matrix. SUBROUTINE Cosine ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Local variables TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF CALL ScaleSquareTrigonometry ( InputMat , OutputMat , params ) !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE Cosine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the cosine of a matrix. (dense version). SUBROUTINE DenseCosine ( Mat , OutputMat , solver_parameters_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The cosine of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Cosine Function Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( Mat , OutputMat , CosineLambda , params ) !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE DenseCosine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute trigonometric functions of a matrix using a taylor series. SUBROUTINE ScaleSquareTrigonometryTaylor ( InputMat , OutputMat , params ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( Matrix_ps ) :: IdentityMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: II IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Trigonometry Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Taylor\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"higham2003computing\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0_NTREAL sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 3.0e-3_NTREAL ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0_NTREAL / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL FillMatrixIdentity ( OutputMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Square the scaled matrix. taylor_denom = - 2.0_NTREAL CALL CopyMatrix ( OutputMat , Ak ) CALL MatrixMultiply ( ScaledMat , ScaledMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , ScaledMat ) !! Expand Taylor Series DO II = 2 , 40 , 2 CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat , & & alpha_in = 1.0_NTREAL / taylor_denom ) taylor_denom = taylor_denom * ( II + 1 ) taylor_denom = - 1.0_NTREAL * taylor_denom * ( II + 1 ) END DO !! Undo scaling DO II = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) CALL ScaleMatrix ( OutputMat , 2.0_NTREAL ) CALL IncrementMatrix ( IdentityMat , OutputMat , & & alpha_in =- 1.0_NTREAL ) END DO IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Ak ) END SUBROUTINE ScaleSquareTrigonometryTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute trigonometric functions of a matrix. !> This method uses Chebyshev polynomials. SUBROUTINE ScaleSquareTrigonometry ( InputMat , OutputMat , params ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( Matrix_ps ) :: IdentityMat !! For Chebyshev Expansion REAL ( NTREAL ), DIMENSION ( 17 ) :: coefficients TYPE ( Matrix_ps ) :: T2 TYPE ( Matrix_ps ) :: T4 TYPE ( Matrix_ps ) :: T6 TYPE ( Matrix_ps ) :: T8 !! Local Variables REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: II IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Trigonometry Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Chebyshev\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"serbin1980algorithm\" ) CALL WriteListElement ( \"higham2003computing\" ) CALL WriteListElement ( \"yau1993reducing\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0_NTREAL sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0_NTREAL ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0_NTREAL / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IdentityMat , IdentityMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Expand the Chebyshev Polynomial. coefficients ( 1 ) = 7.651976865579664e-01_NTREAL coefficients ( 2 ) = 0_NTREAL coefficients ( 3 ) = - 2.298069698638004e-01_NTREAL coefficients ( 4 ) = 0_NTREAL coefficients ( 5 ) = 4.953277928219409e-03_NTREAL coefficients ( 6 ) = 0_NTREAL coefficients ( 7 ) = - 4.187667600472235e-05_NTREAL coefficients ( 8 ) = 0_NTREAL coefficients ( 9 ) = 1.884468822397086e-07_NTREAL coefficients ( 10 ) = 0_NTREAL coefficients ( 11 ) = - 5.261224549346905e-10_NTREAL coefficients ( 12 ) = 0_NTREAL coefficients ( 13 ) = 9.999906645345580e-13_NTREAL coefficients ( 14 ) = 0_NTREAL coefficients ( 15 ) = - 2.083597362700025e-15_NTREAL coefficients ( 16 ) = 0_NTREAL coefficients ( 17 ) = 9.181480886537484e-17_NTREAL !! Basic T Values. CALL MatrixMultiply ( ScaledMat , ScaledMat , T2 , alpha_in = 2.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( IdentityMat , T2 , alpha_in = - 1.0_NTREAL ) CALL MatrixMultiply ( T2 , T2 , T4 , alpha_in = 2.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( IdentityMat , T4 , alpha_in = - 1.0_NTREAL ) CALL MatrixMultiply ( T4 , T2 , T6 , alpha_in = 2.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( T2 , T6 , alpha_in = - 1.0_NTREAL ) CALL MatrixMultiply ( T6 , T2 , T8 , alpha_in = 2.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( T4 , T8 , alpha_in = - 1.0_NTREAL ) !! Contribution from the second half. CALL CopyMatrix ( T8 , OutputMat ) CALL ScaleMatrix ( OutputMat , 0.5_NTREAL * coefficients ( 17 )) CALL IncrementMatrix ( T6 , OutputMat , & & alpha_in = 0.5_NTREAL * coefficients ( 15 )) CALL IncrementMatrix ( T4 , OutputMat , & & alpha_in = 0.5_NTREAL * coefficients ( 13 )) CALL IncrementMatrix ( T2 , OutputMat , & & alpha_in = 0.5_NTREAL * coefficients ( 11 )) CALL MatrixMultiply ( T8 , OutputMat , TempMat ,& & threshold_in = params % threshold , memory_pool_in = pool ) !! Contribution from the first half. CALL CopyMatrix ( T8 , OutputMat ) CALL ScaleMatrix ( OutputMat , coefficients ( 9 )) CALL IncrementMatrix ( T6 , OutputMat , & & alpha_in = coefficients ( 7 ) + 0.5_NTREAL * coefficients ( 11 )) CALL IncrementMatrix ( T4 , OutputMat , & & alpha_in = coefficients ( 5 ) + 0.5_NTREAL * coefficients ( 13 )) CALL IncrementMatrix ( T2 , OutputMat , & & alpha_in = coefficients ( 3 ) + 0.5_NTREAL * coefficients ( 15 )) CALL IncrementMatrix ( IdentityMat , OutputMat , & & alpha_in = coefficients ( 1 ) + 0.5_NTREAL * coefficients ( 17 )) CALL IncrementMatrix ( TempMat , OutputMat ) !! Undo scaling DO II = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) CALL ScaleMatrix ( OutputMat , 2.0_NTREAL ) CALL IncrementMatrix ( IdentityMat , OutputMat , - 1.0_NTREAL ) END DO IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( T2 ) CALL DestructMatrix ( T4 ) CALL DestructMatrix ( T6 ) CALL DestructMatrix ( T8 ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE ScaleSquareTrigonometry !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical sine function for mapping. FUNCTION SineLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = SIN ( val ) END FUNCTION SineLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical cosine function. FUNCTION CosineLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = COS ( val ) END FUNCTION CosineLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TrigonometrySolversModule","tags":"","loc":"sourcefile/trigonometrysolversmodule.f90.html"},{"title":"PMatrixMemoryPoolModule.F90 – NTPoly","text":"Contents Modules PMatrixMemoryPoolModule Source Code PMatrixMemoryPoolModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling scratch memory for distributed matrix multiplication. MODULE PMatrixMemoryPoolModule USE PSMatrixModule , ONLY : Matrix_ps USE MatrixMemoryPoolModule , ONLY : MatrixMemoryPool_lr , MatrixMemoryPool_lc , & & DestructMatrixMemoryPool IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_p !> Grid of local pools. TYPE ( MatrixMemoryPool_lr ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: grid_r !> Grid of local pools (complex). TYPE ( MatrixMemoryPool_lc ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: grid_c END TYPE MatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructMatrixMemoryPool PUBLIC :: DestructMatrixMemoryPool PUBLIC :: CheckMemoryPoolValidity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructMatrixMemoryPool MODULE PROCEDURE ConstructMatrixMemoryPool_p END INTERFACE ConstructMatrixMemoryPool INTERFACE DestructMatrixMemoryPool MODULE PROCEDURE DestructMatrixMemoryPool_p END INTERFACE DestructMatrixMemoryPool INTERFACE CheckMemoryPoolValidity MODULE PROCEDURE CheckMemoryPoolValidity_p END INTERFACE CheckMemoryPoolValidity CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct Distributed Matrix Memory Pool object. PURE SUBROUTINE ConstructMatrixMemoryPool_p ( this , matrix ) !> A constructed Matrix Memory Pool object. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: this !> The associated distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: matrix CALL DestructMatrixMemoryPool ( this ) !! Allocate IF ( matrix % is_complex ) THEN ALLOCATE ( this % grid_c ( matrix % process_grid % number_of_blocks_rows , & & matrix % process_grid % number_of_blocks_columns )) ELSE ALLOCATE ( this % grid_r ( matrix % process_grid % number_of_blocks_rows , & & matrix % process_grid % number_of_blocks_columns )) END IF END SUBROUTINE ConstructMatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a Distributed Matrix Memory Pool object. PURE SUBROUTINE DestructMatrixMemoryPool_p ( this ) !> Distributed Matrix Memory Pool object to destroy. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: this !! Local Data INTEGER :: II , JJ #define grid grid_r #include \"distributed_pool_includes/DestructMatrixMemoryPool.f90\" #undef grid #define grid grid_c #include \"distributed_pool_includes/DestructMatrixMemoryPool.f90\" #undef grid END SUBROUTINE DestructMatrixMemoryPool_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given distributed memory pool has been validly allocated to !> handle the given parameters. PURE FUNCTION CheckMemoryPoolValidity_p ( this , matrix ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_p ), INTENT ( IN ) :: this !> The associated matrix to check against. TYPE ( Matrix_ps ), INTENT ( IN ) :: matrix !> True if the memory pool is valid. LOGICAL :: isvalid isvalid = . TRUE . !! Check allocation IF ( matrix % is_complex ) THEN IF (. NOT . ALLOCATED ( this % grid_c )) isvalid = . FALSE . ELSE IF (. NOT . ALLOCATED ( this % grid_r )) isvalid = . FALSE . END IF END FUNCTION CheckMemoryPoolValidity_p !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PMatrixMemoryPoolModule","tags":"","loc":"sourcefile/pmatrixmemorypoolmodule.f90.html"},{"title":"TripletListModule.F90 – NTPoly","text":"Contents Modules TripletListModule Source Code TripletListModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Storing Lists of Triplets. MODULE TripletListModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER USE TripletModule , ONLY : Triplet_r , Triplet_c , CompareTriplets , & & ConvertTripletType USE MatrixMarketModule , ONLY : MM_SYMMETRIC , MM_SKEW_SYMMETRIC , MM_HERMITIAN USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a list of triplets. TYPE :: TripletList_r !> Internal representation of the data. TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE :: DATA !> Current number of elements in the triplet list INTEGER :: CurrentSize END TYPE TripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a list of triplets. TYPE :: TripletList_c !> Internal representation of the data. TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE :: DATA !> Current number of elements in the triplet list INTEGER :: CurrentSize END TYPE TripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: TripletList_r PUBLIC :: TripletList_c PUBLIC :: ConstructTripletList PUBLIC :: CopyTripletList PUBLIC :: DestructTripletList PUBLIC :: ResizeTripletList PUBLIC :: AppendToTripletList PUBLIC :: SetTripletAt PUBLIC :: GetTripletAt PUBLIC :: SortTripletList PUBLIC :: SymmetrizeTripletList PUBLIC :: GetTripletListSize PUBLIC :: RedistributeTripletLists PUBLIC :: ShiftTripletList PUBLIC :: ConvertTripletListType !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructTripletList MODULE PROCEDURE ConstructTripletListSup_r MODULE PROCEDURE ConstructTripletListSup_c END INTERFACE ConstructTripletList INTERFACE CopyTripletList MODULE PROCEDURE CopyTripletList_r MODULE PROCEDURE CopyTripletList_c END INTERFACE CopyTripletList INTERFACE DestructTripletList MODULE PROCEDURE DestructTripletList_r MODULE PROCEDURE DestructTripletList_c END INTERFACE DestructTripletList INTERFACE ResizeTripletList MODULE PROCEDURE ResizeTripletList_r MODULE PROCEDURE ResizeTripletList_c END INTERFACE ResizeTripletList INTERFACE AppendToTripletList MODULE PROCEDURE AppendToTripletList_r MODULE PROCEDURE AppendToTripletList_c END INTERFACE AppendToTripletList INTERFACE SetTripletAt MODULE PROCEDURE SetTripletAt_r MODULE PROCEDURE SetTripletAt_c END INTERFACE SetTripletAt INTERFACE GetTripletAt MODULE PROCEDURE GetTripletAt_r MODULE PROCEDURE GetTripletAt_c END INTERFACE GetTripletAt INTERFACE SortTripletList MODULE PROCEDURE SortTripletList_r MODULE PROCEDURE SortTripletList_c END INTERFACE SortTripletList INTERFACE SortDenseTripletList MODULE PROCEDURE SortDenseTripletList_r MODULE PROCEDURE SortDenseTripletList_c END INTERFACE SortDenseTripletList INTERFACE SymmetrizeTripletList MODULE PROCEDURE SymmetrizeTripletList_r MODULE PROCEDURE SymmetrizeTripletList_c END INTERFACE SymmetrizeTripletList INTERFACE GetTripletListSize MODULE PROCEDURE GetTripletListSize_r MODULE PROCEDURE GetTripletListSize_c END INTERFACE GetTripletListSize INTERFACE RedistributeTripletLists MODULE PROCEDURE RedistributeTripletLists_r MODULE PROCEDURE RedistributeTripletLists_c END INTERFACE RedistributeTripletLists INTERFACE ShiftTripletList MODULE PROCEDURE ShiftTripletList_r MODULE PROCEDURE ShiftTripletList_c END INTERFACE ShiftTripletList INTERFACE ConvertTripletListType MODULE PROCEDURE ConvertTripletListToReal MODULE PROCEDURE ConvertTripletListToComplex END INTERFACE ConvertTripletListType CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for constructing a triplet list. PURE SUBROUTINE ConstructTripletListSup_r ( this , size_in ) !> The triplet list to construct. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The length of the triplet list (default = 0). INTEGER , INTENT ( IN ), OPTIONAL :: size_in #include \"triplet_includes/ConstructTripletList.f90\" END SUBROUTINE ConstructTripletListSup_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for constructing a triplet list. PURE SUBROUTINE ConstructTripletListSup_c ( this , size_in ) !> The triplet list to construct. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The length of the triplet list (default = 0). INTEGER , INTENT ( IN ), OPTIONAL :: size_in #include \"triplet_includes/ConstructTripletList.f90\" END SUBROUTINE ConstructTripletListSup_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destructs a triplet list. PURE SUBROUTINE DestructTripletList_r ( this ) !> The triplet list to destruct. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this #include \"triplet_includes/DestructTripletList.f90\" END SUBROUTINE DestructTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destructs a triplet list. PURE SUBROUTINE DestructTripletList_c ( this ) !> The triplet list to destruct. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this #include \"triplet_includes/DestructTripletList.f90\" END SUBROUTINE DestructTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE CopyTripletList_r ( tripA , tripB ) !> The triplet list to copy. TYPE ( TripletList_r ), INTENT ( IN ) :: tripA !> tripB = tripA TYPE ( TripletList_r ), INTENT ( INOUT ) :: tripB #include \"triplet_includes/CopyTripletList.f90\" END SUBROUTINE CopyTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE CopyTripletList_c ( tripA , tripB ) !> The triplet list to copy. TYPE ( TripletList_c ), INTENT ( IN ) :: tripA !> tripB = tripA TYPE ( TripletList_c ), INTENT ( INOUT ) :: tripB #include \"triplet_includes/CopyTripletList.f90\" END SUBROUTINE CopyTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Increase the size of a triplet list. PURE SUBROUTINE ResizeTripletList_r ( this , size ) !> The triplet list to resize. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> Size to resize to. INTEGER , INTENT ( IN ) :: size !! Local Data TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE :: temporary_data #include \"triplet_includes/ResizeTripletList.f90\" END SUBROUTINE ResizeTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Increase the size of a triplet list. PURE SUBROUTINE ResizeTripletList_c ( this , size ) !> The triplet list to resize. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> Size to resize to. INTEGER , INTENT ( IN ) :: size !! Local Data TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE :: temporary_data #include \"triplet_includes/ResizeTripletList.f90\" END SUBROUTINE ResizeTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add a value to the end of the triplet list. PURE SUBROUTINE AppendToTripletList_r ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The value to append. TYPE ( Triplet_r ), INTENT ( IN ) :: triplet_value #include \"triplet_includes/AppendToTripletList.f90\" END SUBROUTINE AppendToTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add a value to the end of the triplet list. PURE SUBROUTINE AppendToTripletList_c ( this , triplet_value ) !> This the triplet list to append to. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The value to append. TYPE ( Triplet_c ), INTENT ( IN ) :: triplet_value #include \"triplet_includes/AppendToTripletList.f90\" END SUBROUTINE AppendToTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of a triplet at a particular index. PURE SUBROUTINE SetTripletAt_r ( this , index , triplet_value ) !> The triplet list to set. TYPE ( TripletList_r ), INTENT ( INOUT ) :: this !> The index at which to set the triplet. INTEGER , INTENT ( IN ) :: index !> The value of the triplet to set. TYPE ( Triplet_r ), INTENT ( IN ) :: triplet_value #include \"triplet_includes/SetTripletAt.f90\" END SUBROUTINE SetTripletAt_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of a triplet at a particular index. PURE SUBROUTINE SetTripletAt_c ( this , index , triplet_value ) !> The triplet list to set. TYPE ( TripletList_c ), INTENT ( INOUT ) :: this !> The index at which to set the triplet. INTEGER , INTENT ( IN ) :: index !> The value of the triplet to set. TYPE ( Triplet_c ), INTENT ( IN ) :: triplet_value #include \"triplet_includes/SetTripletAt.f90\" END SUBROUTINE SetTripletAt_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the value of a triplet at a particular index. PURE SUBROUTINE GetTripletAt_r ( this , index , triplet_value ) !> The triplet list to get the value from. TYPE ( TripletList_r ), INTENT ( IN ) :: this !> The index from which to get the triplet. INTEGER , INTENT ( IN ) :: index !> The extracted triplet value. TYPE ( Triplet_r ), INTENT ( OUT ) :: triplet_value #include \"triplet_includes/GetTripletAt.f90\" END SUBROUTINE GetTripletAt_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the value of a triplet at a particular index. PURE SUBROUTINE GetTripletAt_c ( this , index , triplet_value ) !> The triplet list to get the value from. TYPE ( TripletList_c ), INTENT ( IN ) :: this !> The index from which to get the triplet. INTEGER , INTENT ( IN ) :: index !> The extracted triplet value. TYPE ( Triplet_c ), INTENT ( OUT ) :: triplet_value #include \"triplet_includes/GetTripletAt.f90\" END SUBROUTINE GetTripletAt_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sorts a triplet list by index values. !> Implementation is based on bucket sort. This is why it needs the number of !> matrix columns. Bubble sort is used within a bucket. PURE SUBROUTINE SortTripletList_r ( input_list , matrix_columns , matrix_rows , & & sorted_list , bubble_in ) !> List to be sorted. TYPE ( TripletList_r ), INTENT ( IN ) :: input_list !> This is the highest column value in the list. INTEGER , INTENT ( IN ) :: matrix_columns !> This is the highest row value in the list. INTEGER , INTENT ( IN ) :: matrix_rows !> A now sorted version of the list. This routine will allocate it. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_list !> False if you do not need the final bubble sort. LOGICAL , OPTIONAL , INTENT ( IN ) :: bubble_in !! Local Data TYPE ( Triplet_r ) :: trip #include \"triplet_includes/SortTripletList.f90\" END SUBROUTINE SortTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sorts a triplet list by index values. !> Implementation is based on bucket sort. This is why it needs the number of !> matrix columns. Bubble sort is used within a bucket. PURE SUBROUTINE SortTripletList_c ( input_list , matrix_columns , matrix_rows , & & sorted_list , bubble_in ) !> List to be sorted. TYPE ( TripletList_c ), INTENT ( IN ) :: input_list !> This is the highest column value in the list. INTEGER , INTENT ( IN ) :: matrix_columns !> This is the highest row value in the list. INTEGER , INTENT ( IN ) :: matrix_rows !> A now sorted version of the list. This routine will allocate it. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_list !> False if you do not need the final bubble sort. LOGICAL , OPTIONAL , INTENT ( IN ) :: bubble_in !! Local Data TYPE ( Triplet_c ) :: trip #include \"triplet_includes/SortTripletList.f90\" END SUBROUTINE SortTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of entries in a triplet list. PURE FUNCTION GetTripletListSize_r ( triplet_list ) RESULT ( list_size ) !> List to get the size of. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> The number of entries in the triplet list. INTEGER :: list_size #include \"triplet_includes/GetTripletListSize.f90\" END FUNCTION GetTripletListSize_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of entries in a triplet list. PURE FUNCTION GetTripletListSize_c ( triplet_list ) RESULT ( list_size ) !> List to get the size of. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> The number of entries in the triplet list. INTEGER :: list_size #include \"triplet_includes/GetTripletListSize.f90\" END FUNCTION GetTripletListSize_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute some triplet lists amongst a set of processors. !> Takes in a list of triplet lists, one list for each processor. Then the !> all to all redistribution is performed along the given communicator. SUBROUTINE RedistributeTripletLists_r ( triplet_lists , comm , local_data_out ) !> A list of triplet lists, one for each process. TYPE ( TripletList_r ), DIMENSION (:), INTENT ( IN ) :: triplet_lists !> The mpi communicator to redistribute along. INTEGER , INTENT ( INOUT ) :: comm !> The resulting local triplet list. TYPE ( TripletList_r ), INTENT ( INOUT ) :: local_data_out !! Local data (type specific) REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: send_buffer_val REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val TYPE ( Triplet_r ) :: temp_triplet #define MPIDATATYPE MPINTREAL #include \"triplet_includes/RedistributeTripletLists.f90\" #undef MPIDATATYPE END SUBROUTINE RedistributeTripletLists_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute some triplet lists amongst a set of processors. !> Takes in a list of triplet lists, one list for each processor. Then the !> all to all redistribution is performed along the given communicator. SUBROUTINE RedistributeTripletLists_c ( triplet_lists , comm , local_data_out ) !> A list of triplet lists, one for each process. TYPE ( TripletList_c ), DIMENSION (:), INTENT ( IN ) :: triplet_lists !> The mpi communicator to redistribute along. INTEGER , INTENT ( INOUT ) :: comm !> The resulting local triplet list. TYPE ( TripletList_c ), INTENT ( INOUT ) :: local_data_out !! Local data (type specific) COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: send_buffer_val COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val TYPE ( Triplet_c ) :: temp_triplet #define MPIDATATYPE MPINTCOMPLEX #include \"triplet_includes/RedistributeTripletLists.f90\" #undef MPIDATATYPE END SUBROUTINE RedistributeTripletLists_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Shift the rows and columns of a triplet list by set values. !> Frequently, we have a triplet list that comes from the global matrix which !> we would like to shift into a local matrix. In that case, just pass !> the negative of the starting row and column (plus 1) to this routine. PURE SUBROUTINE ShiftTripletList_r ( triplet_list , row_shift , column_shift ) !> The triplet list to shift. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> The row offset to shift by. INTEGER , INTENT ( IN ) :: row_shift !> The column offset to shift by. INTEGER , INTENT ( IN ) :: column_shift !! Local Variables INTEGER :: II #include \"triplet_includes/ShiftTripletList.f90\" END SUBROUTINE ShiftTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Shift the rows and columns of a triplet list by set values. !> Frequently, we have a triplet list that comes from the global matrix which !> we would like to shift into a local matrix. In that case, just pass !> the negative of the starting row and column (plus 1) to this routine. PURE SUBROUTINE ShiftTripletList_c ( triplet_list , row_shift , column_shift ) !> The triplet list to shift. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> The row offset to shift by. INTEGER , INTENT ( IN ) :: row_shift !> The column offset to shift by. INTEGER , INTENT ( IN ) :: column_shift !! Local Variables INTEGER :: II #include \"triplet_includes/ShiftTripletList.f90\" END SUBROUTINE ShiftTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sort a triplet list assuming that the matrix it corresponds to is nearly !> dense. PURE SUBROUTINE SortDenseTripletList_r ( input_list , matrix_columns , & & matrix_rows , sorted_list ) !> The list to sort. TYPE ( TripletList_r ), INTENT ( IN ) :: input_list !> Number of columns for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_columns !> Number of rows for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_rows !> Sorted and ready to use for building matrices. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_list !! Local Variables REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: value_buffer #include \"triplet_includes/SortDenseTripletList.f90\" END SUBROUTINE SortDenseTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sort a triplet list assuming that the matrix it corresponds to is nearly !> dense. PURE SUBROUTINE SortDenseTripletList_c ( input_list , matrix_columns , & & matrix_rows , sorted_list ) !> The list to sort. TYPE ( TripletList_c ), INTENT ( IN ) :: input_list !> Number of columns for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_columns !> Number of rows for the corresponding matrix. INTEGER , INTENT ( IN ) :: matrix_rows !> Sorted and ready to use for building matrices. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_list !! Local Variables COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: value_buffer #include \"triplet_includes/SortDenseTripletList.f90\" END SUBROUTINE SortDenseTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Symmetrizes an unsymmetric triplet list according to the specified !> symmetry type. SUBROUTINE SymmetrizeTripletList_r ( triplet_list , pattern_type ) !> List to be symmetrized. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> Type of symmetry. INTEGER , INTENT ( IN ) :: pattern_type !! Local variables TYPE ( Triplet_r ) :: trip , trip_t INTEGER :: II INTEGER :: initial_size initial_size = triplet_list % CurrentSize SELECT CASE ( pattern_type ) CASE ( MM_SYMMETRIC ) DO II = 1 , initial_size CALL GetTripletAt ( triplet_list , II , trip ) IF ( trip % index_column . NE . trip % index_row ) THEN trip_t % index_row = trip % index_column trip_t % index_column = trip % index_row trip_t % point_value = trip % point_value CALL AppendToTripletList ( triplet_list , trip_t ) END IF END DO CASE ( MM_SKEW_SYMMETRIC ) DO II = 1 , initial_size CALL GetTripletAt ( triplet_list , II , trip ) IF ( trip % index_column . NE . trip % index_row ) THEN trip_t % index_row = trip % index_column trip_t % index_column = trip % index_row trip_t % point_value = - 1.0 * trip % point_value CALL AppendToTripletList ( triplet_list , trip_t ) END IF END DO END SELECT END SUBROUTINE SymmetrizeTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Symmetrizes an unsymmetric triplet list according to the specified !> symmetry type. SUBROUTINE SymmetrizeTripletList_c ( triplet_list , pattern_type ) !> List to be symmetrized. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> Type of symmetry. INTEGER , INTENT ( IN ) :: pattern_type !! Local variables TYPE ( Triplet_c ) :: trip , trip_t INTEGER :: II INTEGER :: initial_size initial_size = triplet_list % CurrentSize SELECT CASE ( pattern_type ) CASE ( MM_SYMMETRIC ) DO II = 1 , initial_size CALL GetTripletAt ( triplet_list , II , trip ) IF ( trip % index_column . NE . trip % index_row ) THEN trip_t % index_row = trip % index_column trip_t % index_column = trip % index_row trip_t % point_value = trip % point_value CALL AppendToTripletList ( triplet_list , trip_t ) END IF END DO CASE ( MM_HERMITIAN ) DO II = 1 , initial_size CALL GetTripletAt ( triplet_list , II , trip ) IF ( trip % index_column . NE . trip % index_row ) THEN trip_t % index_row = trip % index_column trip_t % index_column = trip % index_row trip_t % point_value = CONJG ( trip % point_value ) CALL AppendToTripletList ( triplet_list , trip_t ) END IF END DO CASE ( MM_SKEW_SYMMETRIC ) DO II = 1 , initial_size CALL GetTripletAt ( triplet_list , II , trip ) IF ( trip % index_column . NE . trip % index_row ) THEN trip_t % index_row = trip % index_column trip_t % index_column = trip % index_row trip_t % point_value = - 1.0 * trip % point_value CALL AppendToTripletList ( triplet_list , trip_t ) END IF END DO END SELECT END SUBROUTINE SymmetrizeTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex triplet list to a real triplet list. SUBROUTINE ConvertTripletListToReal ( cin_triplet , rout_triplet ) !> The starting triplet list. TYPE ( TripletList_c ), INTENT ( IN ) :: cin_triplet !> Real valued triplet list. TYPE ( TripletList_r ), INTENT ( INOUT ) :: rout_triplet !! Local Variables INTEGER :: II CALL ConstructTripletList ( rout_triplet , cin_triplet % CurrentSize ) DO II = 1 , cin_triplet % CurrentSize CALL ConvertTripletType ( cin_triplet % DATA ( II ), rout_triplet % DATA ( II )) END DO END SUBROUTINE ConvertTripletListToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real triplet to a complex triplet list. SUBROUTINE ConvertTripletListToComplex ( rin_triplet , cout_triplet ) !> The starting triplet list. TYPE ( TripletList_r ), INTENT ( IN ) :: rin_triplet !> Complex valued triplet list. TYPE ( TripletList_c ), INTENT ( INOUT ) :: cout_triplet !! Local Variables INTEGER :: II CALL ConstructTripletList ( cout_triplet , rin_triplet % CurrentSize ) DO II = 1 , rin_triplet % CurrentSize CALL ConvertTripletType ( rin_triplet % DATA ( II ), cout_triplet % DATA ( II )) END DO END SUBROUTINE ConvertTripletListToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TripletListModule","tags":"","loc":"sourcefile/tripletlistmodule.f90.html"},{"title":"SolverParametersModule.F90 – NTPoly","text":"Contents Modules SolverParametersModule Source Code SolverParametersModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Storing The Parameters For Iterative Solvers. MODULE SolverParametersModule USE DataTypesModule , ONLY : NTREAL USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader USE PermutationModule , ONLY : Permutation_t , CopyPermutation , & & DestructPermutation IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A class for passing parameters to an iterative solver. TYPE , PUBLIC :: SolverParameters_t !> When do we consider a calculation converged. REAL ( NTREAL ) :: converge_diff !> Maximum number of iterations of a solver before termination. INTEGER :: max_iterations !> Threshold for sparse multiplication and addition. REAL ( NTREAL ) :: threshold !> If true, the sparse solver prints out information each loop iteration. LOGICAL :: be_verbose !> If true, the sparse solver will try and load balance before calculation. LOGICAL :: do_load_balancing !> The permutation used for load balancing. TYPE ( Permutation_t ) :: BalancePermutation !> Thresholds for step size searches. REAL ( NTREAL ) :: step_thresh END TYPE SolverParameters_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructSolverParameters PUBLIC :: CopySolverParameters PUBLIC :: SetParametersConvergeDiff PUBLIC :: SetParametersMaxIterations PUBLIC :: SetParametersThreshold PUBLIC :: SetParametersBeVerbose PUBLIC :: SetParametersLoadBalance PUBLIC :: SetParametersStepThreshold PUBLIC :: PrintParameters PUBLIC :: DestructSolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The default convergence difference. REAL ( NTREAL ), PARAMETER , PUBLIC :: CONVERGENCE_DIFF_CONST = 1e-6_NTREAL !> The default maximum number of iterations. INTEGER , PARAMETER , PUBLIC :: MAX_ITERATIONS_CONST = 1000 CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a data type which stores iterative solver parameters. SUBROUTINE ConstructSolverParameters ( this , converge_diff_in , threshold_in , & & max_iterations_in , be_verbose_in , BalancePermutation_in , & & step_thresh_in ) !> The parameters to construct. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Converge_diff_in the difference between iterations to consider !> a calculation converged. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: converge_diff_in !> The zero threshold REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !> The maximum number of iterations to perform INTEGER , INTENT ( IN ), OPTIONAL :: max_iterations_in !> Whether to print during the calculation (default = False) LOGICAL , INTENT ( IN ), OPTIONAL :: be_verbose_in !> For load balancing TYPE ( Permutation_t ), INTENT ( IN ), OPTIONAL :: BalancePermutation_in !> Step size for differential equation solvers. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: step_thresh_in CALL DestructSolverParameters ( this ) !! Optional Parameters IF (. NOT . PRESENT ( converge_diff_in )) THEN this % converge_diff = CONVERGENCE_DIFF_CONST ELSE this % converge_diff = converge_diff_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN this % threshold = 0.0_NTREAL ELSE this % threshold = threshold_in END IF IF (. NOT . PRESENT ( max_iterations_in )) THEN this % max_iterations = MAX_ITERATIONS_CONST ELSE this % max_iterations = max_iterations_in END IF IF (. NOT . PRESENT ( be_verbose_in )) THEN this % be_verbose = . FALSE . ELSE this % be_verbose = be_verbose_in END IF IF (. NOT . PRESENT ( BalancePermutation_in )) THEN this % do_load_balancing = . FALSE . ELSE this % do_load_balancing = . TRUE . CALL CopyPermutation ( BalancePermutation_in , this % BalancePermutation ) END IF IF (. NOT . PRESENT ( step_thresh_in )) THEN this % step_thresh = 1E-2_NTREAL ELSE this % step_thresh = step_thresh_in END IF END SUBROUTINE ConstructSolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE CopySolverParameters ( paramA , paramB ) !> Parameters to copy TYPE ( SolverParameters_t ), INTENT ( IN ) :: paramA !> paramB = paramA TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: paramB CALL DestructSolverParameters ( paramB ) paramB = paramA END SUBROUTINE CopySolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the convergence difference. PURE SUBROUTINE SetParametersConvergeDiff ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. REAL ( NTREAL ), INTENT ( IN ) :: new_value this % converge_diff = new_value END SUBROUTINE SetParametersConvergeDiff !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the max iterations. PURE SUBROUTINE SetParametersMaxIterations ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. INTEGER , INTENT ( IN ) :: new_value this % max_iterations = new_value END SUBROUTINE SetParametersMaxIterations !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the threshold. PURE SUBROUTINE SetParametersThreshold ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. REAL ( NTREAL ), INTENT ( IN ) :: new_value this % threshold = new_value END SUBROUTINE SetParametersThreshold !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the verbosity. PURE SUBROUTINE SetParametersBeVerbose ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. LOGICAL , INTENT ( IN ) :: new_value this % be_verbose = new_value END SUBROUTINE SetParametersBeVerbose !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the load balance. PURE SUBROUTINE SetParametersLoadBalance ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. TYPE ( Permutation_t ), INTENT ( IN ) :: new_value this % do_load_balancing = . TRUE . this % BalancePermutation = new_value END SUBROUTINE SetParametersLoadBalance !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the value of the step threshold. PURE SUBROUTINE SetParametersStepThreshold ( this , new_value ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this !> Value to set it to. REAL ( NTREAL ), INTENT ( IN ) :: new_value this % step_thresh = new_value END SUBROUTINE SetParametersStepThreshold !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the iterative solver parameter values. SUBROUTINE PrintParameters ( this ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( IN ) :: this CALL WriteHeader ( \"Solver Parameters\" ) CALL EnterSubLog CALL WriteElement ( key = \"Verbosity\" , & & VALUE = this % be_verbose ) CALL WriteElement ( key = \"Load Balancing\" , & & VALUE = this % do_load_balancing ) CALL WriteElement ( key = \"Convergence Difference\" , & & VALUE = this % converge_diff ) CALL WriteElement ( key = \"Threshold\" , & & VALUE = this % threshold ) CALL WriteElement ( key = \"Maximum Iterations\" , & & VALUE = this % max_iterations ) CALL WriteElement ( key = \"Step Threshold\" , & & VALUE = this % step_thresh ) CALL ExitSubLog END SUBROUTINE PrintParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Cleanup the solver parameters datastructure. PURE SUBROUTINE DestructSolverParameters ( this ) !> The parameter object. TYPE ( SolverParameters_t ), INTENT ( INOUT ) :: this CALL DestructPermutation ( this % BalancePermutation ) END SUBROUTINE DestructSolverParameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SolverParametersModule","tags":"","loc":"sourcefile/solverparametersmodule.f90.html"},{"title":"MatrixMapsModule.F90 – NTPoly","text":"Contents Modules MatrixMapsModule Source Code MatrixMapsModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Simplfiying Per Element Operations on Matrices. MODULE MatrixMapsModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & GetMatrixTripletList , FillMatrixFromTripletList USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & DestructTripletList , AppendToTripletList , GetTripletAt , & & ConstructTripletList USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MapMatrix_psr PUBLIC :: MapMatrix_psc PUBLIC :: MapTripletList !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MapMatrix_psr MODULE PROCEDURE MapMatrix_psr MODULE PROCEDURE MapMatrixArrayDouble_psr MODULE PROCEDURE MapMatrixArrayInt_psr END INTERFACE MapMatrix_psr INTERFACE MapMatrix_psc MODULE PROCEDURE MapMatrix_psc MODULE PROCEDURE MapMatrixArrayDouble_psc MODULE PROCEDURE MapMatrixArrayInt_psc END INTERFACE MapMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MapTripletList MODULE PROCEDURE MapTripletList_r MODULE PROCEDURE MapTripletList_c MODULE PROCEDURE MapTripletListArrayDouble_r MODULE PROCEDURE MapTripletListArrayDouble_c MODULE PROCEDURE MapTripletListArrayInt_r MODULE PROCEDURE MapTripletListArrayInt_c END INTERFACE MapTripletList CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (real). SUBROUTINE MapMatrix_psr ( inmat , outmat , proc ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !! Local Variables TYPE ( TripletList_r ) :: inlist , outlist #include \"map_includes/MapMatrix.f90\" END SUBROUTINE MapMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (complex). SUBROUTINE MapMatrix_psc ( inmat , outmat , proc ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !! Local Variables TYPE ( TripletList_c ) :: inlist , outlist #include \"map_includes/MapMatrix.f90\" END SUBROUTINE MapMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletList_r ( inlist , outlist , proc , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_r ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_r ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_r ) :: temp #include \"map_includes/MapTripletList.f90\" END SUBROUTINE MapTripletList_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a triplet list, apply this procedure to each element. SUBROUTINE MapTripletList_c ( inlist , outlist , proc , num_slices_in , & & my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_c ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_c ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_c ) :: temp #include \"map_includes/MapTripletList.f90\" END SUBROUTINE MapTripletList_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (real) !! with supplementary data (double). SUBROUTINE MapMatrixArrayDouble_psr ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_r ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArrayDouble_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (complex) !! with supplementary data (complex). SUBROUTINE MapMatrixArrayDouble_psc ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), & & INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_c ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArrayDouble_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (real) !! with supplementary data (double). SUBROUTINE MapMatrixArrayInt_psr ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_r ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArrayInt_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a distributed matrix, apply this procedure to each element (complex) !! with supplementary data (int). SUBROUTINE MapMatrixArrayInt_psc ( inmat , outmat , proc , supp_in ) !> The matrix to apply the procedure to. TYPE ( Matrix_ps ), INTENT ( IN ) :: inmat !> The matrix where each element has had proc called on it. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: outmat INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ) :: supp_in !! Local Variables TYPE ( TripletList_c ) :: inlist , outlist #define MAPARRAY #include \"map_includes/MapMatrix.f90\" #undef MAPARRAY END SUBROUTINE MapMatrixArrayInt_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a (real) triplet list, apply this procedure to each element with !! supplementary data (double). SUBROUTINE MapTripletListArrayDouble_r ( inlist , outlist , proc , supp_in , & & num_slices_in , my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_r ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_r ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. REAL ( KIND = NTREAL ), DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_r ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArrayDouble_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a (complex) triplet list, apply this procedure to each element !! with supplementary data (complex). SUBROUTINE MapTripletListArrayDouble_c ( inlist , outlist , proc , supp_in , & & num_slices_in , my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_c ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_c ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), & & INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. COMPLEX ( KIND = NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_c ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArrayDouble_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a (real) triplet list, apply this procedure to each element with !! supplementary data (int). SUBROUTINE MapTripletListArrayInt_r ( inlist , outlist , proc , supp_in , & & num_slices_in , my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_r ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_r ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTREAL !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_r ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArrayInt_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a (complex) triplet list, apply this procedure to each element !! with supplementary data (int). SUBROUTINE MapTripletListArrayInt_c ( inlist , outlist , proc , supp_in , & & num_slices_in , my_slice_in ) !> The matrix to apply the procedure to. TYPE ( TripletList_c ), INTENT ( IN ) :: inlist !> The matrix where each element has had proc called on it. TYPE ( TripletList_c ), INTENT ( INOUT ) :: outlist INTERFACE !> The procedure to apply to each element. FUNCTION proc ( row , column , val , supp_in ) RESULT ( valid ) USE DataTypesModule , ONLY : NTCOMPLEX !> The row value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: row !> The column value of an element. INTEGER , INTENT ( INOUT ), OPTIONAL :: column !> The actual value of an element. COMPLEX ( KIND = NTCOMPLEX ), INTENT ( INOUT ), OPTIONAL :: val !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: supp_in !> Set this to false to filter an element. LOGICAL :: valid END FUNCTION proc END INTERFACE !> Any supplementary data you need to pass the map can packed here. INTEGER , DIMENSION (:), INTENT ( IN ) :: supp_in !> How many process slices to do this mapping on (default is 1) INTEGER , INTENT ( IN ), OPTIONAL :: num_slices_in !> What process slice this process should compute (default is 0). INTEGER , INTENT ( IN ), OPTIONAL :: my_slice_in !! Local Variables TYPE ( Triplet_c ) :: temp #define MAPARRAY #include \"map_includes/MapTripletList.f90\" #undef MAPARRAY END SUBROUTINE MapTripletListArrayInt_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMapsModule","tags":"","loc":"sourcefile/matrixmapsmodule.f90.html"},{"title":"TimerModule.F90 – NTPoly","text":"Contents Modules TimerModule Source Code TimerModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to do timings. MODULE TimerModule USE DataTypesModule , ONLY : NTREAL USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader USE ProcessGridModule , ONLY : global_grid USE NTMPIModule IMPLICIT NONE PRIVATE INTEGER , PARAMETER :: name_len = 50 CHARACTER ( LEN = name_len ), DIMENSION (:), ALLOCATABLE , SAVE :: timer_list REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE , SAVE :: start_times REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE , SAVE :: elapsed_times !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: RegisterTimer PUBLIC :: StartTimer PUBLIC :: StopTimer PUBLIC :: PrintTimer PUBLIC :: PrintAllTimers PUBLIC :: PrintAllTimersDistributed CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Register a timer with the timer module.  Call this before using that timer. SUBROUTINE RegisterTimer ( timer_name ) !> Name of the timer. CHARACTER ( LEN = * ), INTENT ( IN ) :: timer_name !! Local Data CHARACTER ( LEN = name_len ), DIMENSION (:), ALLOCATABLE :: temp_timer_list REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: temp_start_times REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: temp_elapsed_times IF ( ALLOCATED ( timer_list )) THEN ALLOCATE ( temp_timer_list ( SIZE ( timer_list ) + 1 )) ALLOCATE ( temp_start_times ( SIZE ( start_times ) + 1 )) ALLOCATE ( temp_elapsed_times ( SIZE ( elapsed_times ) + 1 )) temp_timer_list (: SIZE ( timer_list )) = timer_list temp_start_times (: SIZE ( start_times )) = start_times temp_elapsed_times (: SIZE ( elapsed_times )) = elapsed_times CALL MOVE_ALLOC ( temp_timer_list , timer_list ) CALL MOVE_ALLOC ( temp_start_times , start_times ) CALL MOVE_ALLOC ( temp_elapsed_times , elapsed_times ) timer_list ( SIZE ( timer_list )) = timer_name elapsed_times ( SIZE ( timer_list )) = 0 ELSE ALLOCATE ( timer_list ( 1 )) ALLOCATE ( start_times ( 1 )) ALLOCATE ( elapsed_times ( 1 )) timer_list ( 1 ) = timer_name elapsed_times ( 1 ) = 0 END IF END SUBROUTINE RegisterTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Start the clock running for a given timer. SUBROUTINE StartTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( LEN = * ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: II REAL ( NTREAL ) :: temp_time temp_time = MPI_WTIME () II = GetTimerPosition ( timer_name ) IF ( II . GT . 0 ) THEN start_times ( II ) = temp_time END IF END SUBROUTINE StartTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Stop the clock for a given timer. SUBROUTINE StopTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( LEN = * ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: II REAL ( NTREAL ) :: temp_elapsed_time REAL ( NTREAL ) :: temp_start_time II = GetTimerPosition ( timer_name ) IF ( II . GT . 0 ) THEN temp_elapsed_time = MPI_WTIME () temp_start_time = start_times ( II ) elapsed_times ( II ) = elapsed_times ( II ) + & & temp_elapsed_time - temp_start_time END IF END SUBROUTINE StopTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for a given timer. SUBROUTINE PrintTimer ( timer_name ) !> Name of the timer. Must be registered. CHARACTER ( LEN = * ), INTENT ( IN ) :: timer_name !! Local Data INTEGER :: II II = GetTimerPosition ( timer_name ) CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog IF ( II > 0 ) THEN CALL WriteElement ( key = timer_name , VALUE = elapsed_times ( II )) END IF CALL ExitSubLog END SUBROUTINE PrintTimer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for each timer on this process. SUBROUTINE PrintAllTimers () !! Local Data INTEGER :: II CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog DO II = LBOUND ( timer_list , dim = 1 ), UBOUND ( timer_list , dim = 1 ) CALL WriteElement ( key = timer_list ( II ), VALUE = elapsed_times ( II )) END DO CALL ExitSubLog END SUBROUTINE PrintAllTimers !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out the elapsed time for each timer based on the max value across !> processes. SUBROUTINE PrintAllTimersDistributed () !! Local Data INTEGER :: II REAL ( NTREAL ) :: elapsed REAL ( NTREAL ) :: max_time INTEGER :: ierr CALL WriteHeader ( \"Timers\" ) CALL EnterSubLog DO II = LBOUND ( timer_list , dim = 1 ), UBOUND ( timer_list , dim = 1 ) elapsed = elapsed_times ( II ) CALL MPI_Allreduce ( elapsed , max_time , 1 , MPI_DOUBLE_PRECISION , MPI_MAX , & & global_grid % global_comm , ierr ) CALL WriteElement ( key = timer_list ( II ), VALUE = max_time ) END DO CALL ExitSubLog END SUBROUTINE PrintAllTimersDistributed !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Figure out the position in the timer list where timer_name is. !> This is a utility routine. FUNCTION GetTimerPosition ( timer_name ) RESULT ( timer_position ) !! Parameters !> Name of the timer. CHARACTER ( LEN = * ), INTENT ( IN ) :: timer_name !> The position of the timer. 0 means the timer has not been registered. INTEGER :: timer_position !! Local Data INTEGER :: II LOGICAL :: not_found not_found = . TRUE . IF ( ALLOCATED ( timer_list )) THEN DO II = 1 , SIZE ( timer_list ) IF ( timer_name . EQ . timer_list ( II )) THEN not_found = . FALSE . EXIT END IF END DO END IF IF ( not_found ) THEN timer_position = 0 ELSE timer_position = II END IF END FUNCTION GetTimerPosition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TimerModule","tags":"","loc":"sourcefile/timermodule.f90.html"},{"title":"LoadBalancerModule.F90 – NTPoly","text":"Contents Modules LoadBalancerModule Source Code LoadBalancerModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for load balancing the matrix multiplication calculation. MODULE LoadBalancerModule USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p USE PSMatrixAlgebraModule , ONLY : MatrixMultiply USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & DestructMatrix , FillMatrixPermutation USE PermutationModule , ONLY : Permutation_t IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: PermuteMatrix PUBLIC :: UndoPermuteMatrix CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Apply a permutation to a matrix. SUBROUTINE PermuteMatrix ( mat , mat_out , permutation , memorypool_in ) !> The matrix to permute. TYPE ( Matrix_ps ), INTENT ( IN ) :: mat !> The permuted matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: mat_out !> The permutation to apply. TYPE ( Permutation_t ), INTENT ( IN ) :: permutation !> Memory pool to use TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ), OPTIONAL :: memorypool_in !! Local Variables TYPE ( Matrix_ps ) :: PermuteRows , PermuteColumns TYPE ( Matrix_ps ) :: Temp !! Build Permutation Matrices CALL ConstructEmptyMatrix ( PermuteRows , mat ) CALL ConstructEmptyMatrix ( PermuteColumns , mat ) CALL FillMatrixPermutation ( PermuteRows , permutation % index_lookup , & & permute_rows_in = . TRUE .) CALL FillMatrixPermutation ( PermuteColumns , permutation % index_lookup , & & permute_rows_in = . FALSE .) CALL ConstructEmptyMatrix ( Temp , mat ) !! Permute Matrices. IF ( PRESENT ( memorypool_in )) THEN CALL MatrixMultiply ( PermuteRows , mat , Temp , & & memory_pool_in = memorypool_in ) CALL MatrixMultiply ( Temp , PermuteColumns , mat_out , & & memory_pool_in = memorypool_in ) ELSE CALL MatrixMultiply ( PermuteRows , mat , Temp ) CALL MatrixMultiply ( Temp , PermuteColumns , mat_out ) END IF CALL DestructMatrix ( PermuteRows ) CALL DestructMatrix ( PermuteColumns ) CALL DestructMatrix ( Temp ) END SUBROUTINE PermuteMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Undo a permutation applied to a matrix. SUBROUTINE UndoPermuteMatrix ( mat , mat_out , permutation , memorypool_in ) !> Matrix to undo permutation of. TYPE ( Matrix_ps ), INTENT ( IN ) :: mat !> Unpermuted matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: mat_out !> Permutation to remove. TYPE ( Permutation_t ), INTENT ( IN ) :: permutation !> Memory pool to use. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ), OPTIONAL :: memorypool_in !! Local Variables TYPE ( Matrix_ps ) :: PermuteRows , PermuteColumns TYPE ( Matrix_ps ) :: Temp !! Build Permutation Matrices CALL ConstructEmptyMatrix ( PermuteRows , mat ) CALL ConstructEmptyMatrix ( PermuteColumns , mat ) CALL FillMatrixPermutation ( PermuteRows , permutation % index_lookup , & & permute_rows_in = . TRUE .) CALL FillMatrixPermutation ( PermuteColumns , permutation % index_lookup , & & permute_rows_in = . FALSE .) CALL ConstructEmptyMatrix ( Temp , mat ) !! Permute Matrices. IF ( PRESENT ( memorypool_in )) THEN CALL MatrixMultiply ( PermuteColumns , mat , Temp , & & memory_pool_in = memorypool_in ) CALL MatrixMultiply ( Temp , PermuteRows , mat_out , & & memory_pool_in = memorypool_in ) ELSE CALL MatrixMultiply ( PermuteColumns , mat , Temp ) CALL MatrixMultiply ( Temp , PermuteRows , mat_out ) END IF !! Cleanup CALL DestructMatrix ( PermuteRows ) CALL DestructMatrix ( PermuteColumns ) CALL DestructMatrix ( Temp ) END SUBROUTINE UndoPermuteMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LoadBalancerModule","tags":"","loc":"sourcefile/loadbalancermodule.f90.html"},{"title":"GemmTasksModule.F90 – NTPoly","text":"Contents Modules GemmTasksModule Source Code GemmTasksModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module contains some enumerators which name the tasks for Gemm. MODULE GemmTasksModule IMPLICIT NONE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress ENUMERATOR :: TaskRunningA !> First we gather the blocks of A and send the size. ENUMERATOR :: LocalGatherA !> After the local gather, we then send the size to the other tasks. ENUMERATOR :: SendSizeA !> Next we compose those blocks of A into one big send buffer and send. ENUMERATOR :: ComposeA !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterA !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerA !> Wait for the data values to be gathered, ENUMERATOR :: WaitDataA !> Need to adjusts indices, transpose the values of A. ENUMERATOR :: AdjustIndicesA !> Just waiting on that last task. ENUMERATOR :: CleanupA !> No more work to do. ENUMERATOR :: FinishedA END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress ENUMERATOR :: TaskRunningB !> First we gather the blocks of B and send the size. ENUMERATOR :: LocalGatherB !> Next we compose those blocks of B into one big send buffer and send. ENUMERATOR :: LocalComposeB !> After the local gather, we then send the size to the other tasks. ENUMERATOR :: SendSizeB !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterB !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerB !> Wait for the data values to be gathered, and then adjusts the indices. ENUMERATOR :: WaitDataB !> Need to adjusts indices of B. ENUMERATOR :: AdjustIndicesB !> Just waiting on that last task. ENUMERATOR :: CleanupB !> No more work to do. ENUMERATOR :: FinishedB END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Something is in progress. ENUMERATOR :: TaskRunningAB !> A and B matrix both missing, so it cannot do gemm. ENUMERATOR :: AwaitingAB !> Actually call gemm and compute a block, and send its size. ENUMERATOR :: GemmAB !> After the local Gemm, we then send the size to the other tasks. ENUMERATOR :: SendSizeAB !> Start sending the data for summing. ENUMERATOR :: GatherAndSumAB !> Wait for the outer index values to be gathered. ENUMERATOR :: WaitOuterAB !> Wait for the inner index values to be gathered. ENUMERATOR :: WaitInnerAB !> Wait for the data values to be gathered. Once receive, we increment. ENUMERATOR :: WaitDataAB !> Sum up the gathered matrices. ENUMERATOR :: LocalSumAB !> Just waiting on that last task. ENUMERATOR :: CleanupAB !> No more work to do. ENUMERATOR :: FinishedAB END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE GemmTasksModule","tags":"","loc":"sourcefile/gemmtasksmodule.f90.html"},{"title":"MatrixMemoryPoolModule.F90 – NTPoly","text":"Contents Modules MatrixMemoryPoolModule Source Code MatrixMemoryPoolModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling scratch memory for matrix multiplication. !> The purpose of this module is to avoid having to allocate memory on the !> heap during a matrix multiply, and to manage the underlying hash table. MODULE MatrixMemoryPoolModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_lr PRIVATE !> Shape of matrix: columns INTEGER , PUBLIC :: columns !> Shape of matrix: rows INTEGER , PUBLIC :: rows !> storage for actual values added to the matrix. TYPE ( Triplet_r ), DIMENSION (:), ALLOCATABLE , PUBLIC :: pruned_list !> storage for potential values added to the matrix. REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: value_array !> true if an element has been pushed to this part of the matrix. LOGICAL , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: dirty_array !> Storage space for indices, hashed. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: hash_index !> Internal storage space for amount of items added to a bucket. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: inserted_per_bucket !> Size of the buckets. INTEGER , PUBLIC :: hash_size END TYPE MatrixMemoryPool_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A memory pool datatype that can be reused for matrix matrix multiplication. !> this is to prevent excessive alloc/dealloc. TYPE , PUBLIC :: MatrixMemoryPool_lc PRIVATE !> Shape of matrix: columns INTEGER , PUBLIC :: columns !> Shape of matrix: rows INTEGER , PUBLIC :: rows !> storage for actual values added to the matrix. TYPE ( Triplet_c ), DIMENSION (:), ALLOCATABLE , PUBLIC :: pruned_list !> storage for potential values added to the matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE , PUBLIC :: value_array !> true if an element has been pushed to this part of the matrix. LOGICAL , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: dirty_array !> Storage space for indices, hashed. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: hash_index !> Internal storage space for amount of items added to a bucket. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: inserted_per_bucket !> Size of the buckets. INTEGER , PUBLIC :: hash_size END TYPE MatrixMemoryPool_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructMatrixMemoryPool PUBLIC :: DestructMatrixMemoryPool PUBLIC :: CheckMemoryPoolValidity PUBLIC :: SetPoolSparsity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructMatrixMemoryPool MODULE PROCEDURE ConstructMatrixMemoryPoolSub_lr MODULE PROCEDURE ConstructMatrixMemoryPoolSub_lc END INTERFACE ConstructMatrixMemoryPool INTERFACE DestructMatrixMemoryPool MODULE PROCEDURE DestructMatrixMemoryPool_lr MODULE PROCEDURE DestructMatrixMemoryPool_lc END INTERFACE DestructMatrixMemoryPool INTERFACE CheckMemoryPoolValidity MODULE PROCEDURE CheckMemoryPoolValidity_lr MODULE PROCEDURE CheckMemoryPoolValidity_lc END INTERFACE CheckMemoryPoolValidity INTERFACE SetPoolSparsity MODULE PROCEDURE SetPoolSparsity_lr MODULE PROCEDURE SetPoolSparsity_lc END INTERFACE SetPoolSparsity CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the constructor. SUBROUTINE ConstructMatrixMemoryPoolSub_lr ( this , columns , rows , sparsity_in ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lr ), TARGET :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in #include \"dense_includes/ConstructMatrixMemoryPool.f90\" END SUBROUTINE ConstructMatrixMemoryPoolSub_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the constructor. SUBROUTINE ConstructMatrixMemoryPoolSub_lc ( this , columns , rows , sparsity_in ) !> The matrix to construct. TYPE ( MatrixMemoryPool_lc ), TARGET :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> Estimated sparsity (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: sparsity_in #include \"dense_includes/ConstructMatrixMemoryPool.f90\" END SUBROUTINE ConstructMatrixMemoryPoolSub_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A destructor for a matrix memory pool PURE SUBROUTINE DestructMatrixMemoryPool_lr ( this ) !> The matrix being destructed. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: this #include \"dense_includes/DestructMatrixMemoryPool.f90\" END SUBROUTINE DestructMatrixMemoryPool_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A destructor for a matrix memory pool PURE SUBROUTINE DestructMatrixMemoryPool_lc ( this ) !> The matrix being destructed. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: this #include \"dense_includes/DestructMatrixMemoryPool.f90\" END SUBROUTINE DestructMatrixMemoryPool_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given memory pool has been validly allocated to handle !> the given parameters. PURE FUNCTION CheckMemoryPoolValidity_lr ( this , columns , rows ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_lr ), INTENT ( in ) :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> true if the memory pool is valid. LOGICAL :: isvalid #include \"dense_includes/CheckMemoryPoolValidity.f90\" END FUNCTION CheckMemoryPoolValidity_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Checks if a given memory pool has been validly allocated to handle !> Checks if a given memory pool has been validly allocated to handle !> the given parameters. PURE FUNCTION CheckMemoryPoolValidity_lc ( this , columns , rows ) RESULT ( isvalid ) !> The memory pool to check. TYPE ( MatrixMemoryPool_lc ), INTENT ( in ) :: this !> Number of columns in the matrix. INTEGER , INTENT ( IN ) :: columns !> Number of rows in the matrix. INTEGER , INTENT ( IN ) :: rows !> true if the memory pool is valid. LOGICAL :: isvalid #include \"dense_includes/CheckMemoryPoolValidity.f90\" END FUNCTION CheckMemoryPoolValidity_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sets the expected sparsity of the matrix, which helps with hashing. SUBROUTINE SetPoolSparsity_lr ( this , sparsity ) !> The memory pool to set the sparsity of. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ), TARGET :: this !> The sparsity value. REAL ( NTREAL ), INTENT ( IN ) :: sparsity #include \"dense_includes/SetPoolSparsity.f90\" END SUBROUTINE SetPoolSparsity_lr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sets the expected sparsity of the matrix, which helps with hashing. SUBROUTINE SetPoolSparsity_lc ( this , sparsity ) !> The memory pool to set the sparsity of. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ), TARGET :: this !> The sparsity value. REAL ( NTREAL ), INTENT ( IN ) :: sparsity #include \"dense_includes/SetPoolSparsity.f90\" END SUBROUTINE SetPoolSparsity_lc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMemoryPoolModule","tags":"","loc":"sourcefile/matrixmemorypoolmodule.f90.html"},{"title":"DensityMatrixSolversModule.F90 – NTPoly","text":"Contents Modules DensityMatrixSolversModule Source Code DensityMatrixSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Solving Quantum Chemistry Systems using Purification. MODULE DensityMatrixSolversModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE FermiOperatorModule , ONLY : ComputeDenseFOE USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : WriteElement , WriteListElement , WriteHeader , & & EnterSubLog , ExitSubLog USE NTMPIModule USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & DotMatrix , MatrixTrace , ScaleMatrix , SimilarityTransform USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , DestructMatrix , & & CopyMatrix , PrintMatrixInformation , FillMatrixIdentity , & & TransposeMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: PM PUBLIC :: TRS2 PUBLIC :: TRS4 PUBLIC :: HPCP PUBLIC :: DenseDensity PUBLIC :: ScaleAndFold PUBLIC :: EnergyDensityMatrix PUBLIC :: McWeenyStep CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the PM method. !> Based on the PM algorithm presented in \\cite palser1998canonical SUBROUTINE PM ( H , ISQ , trace , K , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WH TYPE ( Matrix_ps ) :: IMat TYPE ( Matrix_ps ) :: ISQT TYPE ( Matrix_ps ) :: X_k , X_k2 , X_k3 , Temp !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: factor REAL ( NTREAL ) :: lambda , alpha , alpha1 , alpha2 REAL ( NTREAL ) :: a1 , a2 , a3 REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: trace_value2 REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value_old !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II , JJ INTEGER :: total_iterations !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"PM\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"palser1998canonical\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF ALLOCATE ( sigma_array ( params % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( K , H ) CALL ConstructEmptyMatrix ( WH , H ) CALL ConstructEmptyMatrix ( X_k , H ) CALL ConstructEmptyMatrix ( X_k2 , H ) CALL ConstructEmptyMatrix ( X_k3 , H ) CALL ConstructEmptyMatrix ( Temp , H ) CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WH , e_min , e_max ) !! Initialize CALL CopyMatrix ( WH , X_k ) !! Compute lambda CALL MatrixTrace ( X_k , trace_value ) lambda = trace_value / X_k % actual_matrix_dimension !! Compute alpha alpha1 = trace / ( e_max - lambda ) alpha2 = ( X_k % actual_matrix_dimension - trace ) / ( lambda - e_min ) alpha = MIN ( alpha1 , alpha2 ) factor = - alpha / X_k % actual_matrix_dimension CALL ScaleMatrix ( X_k , factor ) factor = ( alpha * lambda + trace ) / X_k % actual_matrix_dimension CALL IncrementMatrix ( IMat , X_k , alpha_in = factor ) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO II = 1 , params % max_iterations !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Compute X_k3 CALL MatrixMultiply ( X_k , X_k2 , X_k3 , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Compute X_k - X_k2 CALL CopyMatrix ( X_k , Temp ) CALL IncrementMatrix ( X_k2 , Temp , & & alpha_in = - 1.0_NTREAL , threshold_in = params % threshold ) !! Compute Sigma CALL MatrixTrace ( Temp , trace_value ) CALL DotMatrix ( Temp , X_k , trace_value2 ) !! If we hit 0 exact convergence, avoid a division by zero. IF ( trace_value . LE . TINY ( trace_value )) THEN sigma_array ( II ) = 1.0_NTREAL ELSE sigma_array ( II ) = trace_value2 / trace_value END IF IF ( sigma_array ( II ) . GT . 0.5_NTREAL ) THEN a1 = 0.0_NTREAL a2 = 1.0_NTREAL + 1.0_NTREAL / sigma_array ( II ) a3 = - 1.0_NTREAL / sigma_array ( II ) ELSE a1 = ( 1.0_NTREAL - 2.0_NTREAL * sigma_array ( II )) & & / ( 1.0_NTREAL - sigma_array ( II )) a2 = ( 1.0_NTREAL + sigma_array ( II )) / ( 1.0_NTREAL - sigma_array ( II )) a3 = - 1.0_NTREAL / ( 1.0_NTREAL - sigma_array ( II )) END IF !! Update X_k CALL ScaleMatrix ( X_k , a1 ) CALL IncrementMatrix ( X_k2 , X_k , & & alpha_in = a2 , threshold_in = params % threshold ) CALL IncrementMatrix ( X_k3 , X_k , & & alpha_in = a3 , threshold_in = params % threshold ) !! Energy value based convergence energy_value_old = energy_value CALL DotMatrix ( X_k , WH , energy_value ) norm_value = ABS ( energy_value - energy_value_old ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( \"Energy Value\" , VALUE = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO total_iterations = II - 1 IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( X_k , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( X_k3 ) CALL DestructMatrix ( Temp ) CALL DestructMatrix ( IMat ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO II = 1 , params % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO JJ = 1 , total_iterations IF ( sigma_array ( JJ ) . GT . 0.5_NTREAL ) THEN zero_value = (( 1.0_NTREAL + sigma_array ( JJ )) & & * zero_value ** 2 ) - ( zero_value ** 3 ) zero_value = zero_value / sigma_array ( JJ ) ELSE zero_value = (( 1.0_NTREAL - 2.0_NTREAL * & & sigma_array ( JJ )) * zero_value ) & & + (( 1.0_NTREAL + sigma_array ( JJ )) * & & zero_value ** 2 ) - ( zero_value ** 3 ) zero_value = zero_value / ( 1.0_NTREAL - sigma_array ( JJ )) END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . params % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = lambda - & & ( H % actual_matrix_dimension * midpoint - trace ) / alpha END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( params ) END SUBROUTINE PM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the TRS2 method. !> Based on the TRS2 algorithm presented in \\cite niklasson2002. SUBROUTINE TRS2 ( H , ISQ , trace , K , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WH TYPE ( Matrix_ps ) :: IMat TYPE ( Matrix_ps ) :: ISQT TYPE ( Matrix_ps ) :: X_k , X_k2 !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value_old !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II , JJ INTEGER :: total_iterations !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"TRS2\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"niklasson2002expansion\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF ALLOCATE ( sigma_array ( params % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( K , H ) CALL ConstructEmptyMatrix ( WH , H ) CALL ConstructEmptyMatrix ( X_k , H ) CALL ConstructEmptyMatrix ( X_k2 , H ) CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WH , e_min , e_max ) !! Initialize CALL CopyMatrix ( WH , X_k ) CALL ScaleMatrix ( X_k , - 1.0_NTREAL ) CALL IncrementMatrix ( IMat , X_k , alpha_in = e_max ) CALL ScaleMatrix ( X_k , 1.0_NTREAL / ( e_max - e_min )) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO II = 1 , params % max_iterations !! Compute Sigma CALL MatrixTrace ( X_k , trace_value ) IF ( trace - trace_value . LT . 0.0_NTREAL ) THEN sigma_array ( II ) = - 1.0_NTREAL ELSE sigma_array ( II ) = 1.0_NTREAL END IF !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Update X_k IF ( sigma_array ( II ) . GT . 0.0_NTREAL ) THEN CALL ScaleMatrix ( X_k , 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , X_k , & & alpha_in = - 1.0_NTREAL , threshold_in = params % threshold ) ELSE CALL CopyMatrix ( X_k2 , X_k ) END IF !! Energy value based convergence energy_value_old = energy_value CALL DotMatrix ( X_k , WH , energy_value ) norm_value = ABS ( energy_value - energy_value_old ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( \"Energy Value\" , VALUE = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO total_iterations = II - 1 IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( X_k , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( IMat ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO II = 1 , params % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO JJ = 1 , total_iterations IF ( sigma_array ( JJ ) . LT . 0.0_NTREAL ) THEN zero_value = zero_value * zero_value ELSE zero_value = 2.0_NTREAL * zero_value - zero_value * zero_value END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . params % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = e_max + ( e_min - e_max ) * midpoint END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( params ) END SUBROUTINE TRS2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the TRS4 method. !> Based on the TRS4 algorithm presented in \\cite niklasson2002 SUBROUTINE TRS4 ( H , ISQ , trace , K , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in REAL ( NTREAL ), PARAMETER :: sigma_min = 0.0_NTREAL REAL ( NTREAL ), PARAMETER :: sigma_max = 6.0_NTREAL !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WH TYPE ( Matrix_ps ) :: IMat TYPE ( Matrix_ps ) :: ISQT TYPE ( Matrix_ps ) :: X_k , X_k2 , Fx_right , GX_right , TempMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value_old !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b REAL ( NTREAL ) :: tempfx , tempgx !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II , JJ INTEGER :: total_iterations REAL ( NTREAL ) :: trace_fx , trace_gx !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"TRS4\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"niklasson2002expansion\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF ALLOCATE ( sigma_array ( params % max_iterations )) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( K , H ) CALL ConstructEmptyMatrix ( WH , H ) CALL ConstructEmptyMatrix ( X_k , H ) CALL ConstructEmptyMatrix ( X_k2 , H ) CALL ConstructEmptyMatrix ( TempMat , H ) CALL ConstructEmptyMatrix ( Fx_right , H ) CALL ConstructEmptyMatrix ( Gx_right , H ) CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WH , e_min , e_max ) !! Initialize CALL CopyMatrix ( WH , X_k ) CALL ScaleMatrix ( X_k , - 1.0_NTREAL ) CALL IncrementMatrix ( IMat , X_k , alpha_in = e_max ) CALL ScaleMatrix ( X_k , 1.0_NTREAL / ( e_max - e_min )) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO II = 1 , params % max_iterations !! Compute X_k2 CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Compute Fx_right CALL CopyMatrix ( X_k2 , Fx_right ) CALL ScaleMatrix ( Fx_right , - 3.0_NTREAL ) CALL IncrementMatrix ( X_k , Fx_right , alpha_in = 4.0_NTREAL ) !! Compute Gx_right CALL CopyMatrix ( IMat , Gx_right ) CALL IncrementMatrix ( X_k , Gx_right , alpha_in = - 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , Gx_right ) !! Compute Traces CALL DotMatrix ( X_k2 , Fx_right , trace_fx ) CALL DotMatrix ( X_k2 , Gx_right , trace_gx ) !! Avoid Overflow IF ( ABS ( trace_gx ) . LT . 1.0e-14_NTREAL ) THEN EXIT END IF !! Compute Sigma sigma_array ( II ) = ( trace - trace_fx ) / trace_gx !! Update The Matrix IF ( sigma_array ( II ) . GT . sigma_max ) THEN CALL CopyMatrix ( X_k , TempMat ) CALL ScaleMatrix ( TempMat , 2.0_NTREAL ) CALL IncrementMatrix ( X_k2 , TempMat , alpha_in = - 1.0_NTREAL ) ELSE IF ( sigma_array ( II ) . LT . sigma_min ) THEN CALL CopyMatrix ( X_k2 , TempMat ) ELSE CALL ScaleMatrix ( Gx_right , sigma_array ( II )) CALL IncrementMatrix ( Fx_right , Gx_right ) CALL MatrixMultiply ( X_k2 , Gx_right , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) END IF CALL IncrementMatrix ( TempMat , X_k , alpha_in = - 1.0_NTREAL ) CALL CopyMatrix ( TempMat , X_k ) !! Energy value based convergence energy_value_old = energy_value CALL DotMatrix ( X_k , WH , energy_value ) norm_value = ABS ( energy_value - energy_value_old ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( key = \"Energy Value\" , VALUE = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO total_iterations = II - 1 IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( X_k , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( Fx_right ) CALL DestructMatrix ( Gx_right ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IMat ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO II = 1 , params % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO JJ = 1 , total_iterations IF ( sigma_array ( JJ ) . GT . sigma_max ) THEN zero_value = 2.0_NTREAL * zero_value - zero_value * zero_value ELSE IF ( sigma_array ( JJ ) . LT . sigma_min ) THEN zero_value = zero_value * zero_value ELSE tempfx = ( zero_value * zero_value ) * & & ( 4.0_NTREAL * zero_value - & & 3.0_NTREAL * zero_value * zero_value ) tempgx = ( zero_value * zero_value ) * ( 1.0_NTREAL - zero_value ) & & * ( 1.0_NTREAL - zero_value ) zero_value = tempfx + sigma_array ( JJ ) * tempgx END IF END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . params % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = e_max + ( e_min - e_max ) * midpoint END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( params ) END SUBROUTINE TRS4 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the HPCP method. !> Based on the algorithm presented in \\cite truflandier2016communication. SUBROUTINE HPCP ( H , ISQ , trace , K , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WH TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: IMat TYPE ( Matrix_ps ) :: ISQT TYPE ( Matrix_ps ) :: D1 , DH , DDH , D2DH !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: beta_1 , beta_2 REAL ( NTREAL ) :: beta , beta_bar REAL ( NTREAL ) :: sigma , sigma_bar REAL ( NTREAL ) :: mu REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: sigma_array REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value_old !! For computing the chemical potential REAL ( NTREAL ) :: zero_value , midpoint , interval_a , interval_b !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II , JJ INTEGER :: total_iterations INTEGER :: matrix_dimension !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"HPCP\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"truflandier2016communication\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF ALLOCATE ( sigma_array ( params % max_iterations )) matrix_dimension = H % actual_matrix_dimension !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( K , H ) CALL ConstructEmptyMatrix ( WH , H ) CALL ConstructEmptyMatrix ( TempMat , H ) CALL ConstructEmptyMatrix ( D1 , H ) CALL ConstructEmptyMatrix ( DH , H ) CALL ConstructEmptyMatrix ( DDH , H ) CALL ConstructEmptyMatrix ( D2DH , H ) CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the initial matrix. CALL GershgorinBounds ( WH , e_min , e_max ) CALL MatrixTrace ( WH , mu ) mu = mu / matrix_dimension sigma_bar = ( matrix_dimension - trace ) / matrix_dimension sigma = 1.0_NTREAL - sigma_bar beta = sigma / ( e_max - mu ) beta_bar = sigma_bar / ( mu - e_min ) beta_1 = sigma beta_2 = MIN ( beta , beta_bar ) !! Initialize CALL CopyMatrix ( IMat , D1 ) CALL ScaleMatrix ( D1 , beta_1 ) CALL CopyMatrix ( IMat , TempMat ) CALL ScaleMatrix ( TempMat , mu ) CALL IncrementMatrix ( WH , TempMat , - 1.0_NTREAL ) CALL ScaleMatrix ( TempMat , beta_2 ) CALL IncrementMatrix ( TempMat , D1 ) trace_value = 0.0_NTREAL !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO II = 1 , params % max_iterations !! Compute the hole matrix DH CALL CopyMatrix ( D1 , DH ) CALL IncrementMatrix ( IMat , DH , alpha_in = - 1.0_NTREAL ) CALL ScaleMatrix ( DH , - 1.0_NTREAL ) !! Compute DDH, as well as convergence check CALL MatrixMultiply ( D1 , DH , DDH , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixTrace ( DDH , trace_value ) norm_value = ABS ( trace_value ) !! Compute D2DH CALL MatrixMultiply ( D1 , DDH , D2DH , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Compute Sigma CALL MatrixTrace ( D2DH , sigma_array ( II )) sigma_array ( II ) = sigma_array ( II ) / trace_value CALL CopyMatrix ( D1 , TempMat ) !! Compute D1 + 2*D2DH CALL IncrementMatrix ( D2DH , D1 , alpha_in = 2.0_NTREAL ) !! Compute D1 + 2*D2DH -2*Sigma*DDH CALL IncrementMatrix ( DDH , D1 , & & alpha_in = - 1.0_NTREAL * 2.0_NTREAL * sigma_array ( II )) !! Energy value based convergence energy_value_old = energy_value CALL DotMatrix ( D1 , WH , energy_value ) norm_value = ABS ( energy_value - energy_value_old ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( \"Energy Value\" , VALUE = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO total_iterations = II - 1 IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( D1 ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( D1 , D1 , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( D1 , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( D1 ) CALL DestructMatrix ( DH ) CALL DestructMatrix ( DDH ) CALL DestructMatrix ( D2DH ) CALL DestructMatrix ( IMat ) CALL DestructMatrixMemoryPool ( pool ) !! Compute The Chemical Potential IF ( PRESENT ( chemical_potential_out )) THEN interval_a = 0.0_NTREAL interval_b = 1.0_NTREAL midpoint = 0.0_NTREAL midpoints : DO II = 1 , params % max_iterations midpoint = ( interval_b - interval_a ) / 2.0_NTREAL + interval_a zero_value = midpoint !! Compute polynomial function at the guess point. polynomial : DO JJ = 1 , total_iterations zero_value = zero_value + & & 2.0_NTREAL * (( zero_value ** 2 ) * ( 1.0_NTREAL - zero_value ) & & - sigma_array ( JJ ) * & & zero_value * ( 1.0_NTREAL - zero_value )) END DO polynomial !! Change bracketing. IF ( zero_value . LT . 0.5_NTREAL ) THEN interval_a = midpoint ELSE interval_b = midpoint END IF !! Check convergence. IF ( ABS ( zero_value - 0.5_NTREAL ) . LT . params % converge_diff ) THEN EXIT END IF END DO midpoints !! Undo scaling. chemical_potential_out = mu + ( beta_1 - midpoint ) / beta_2 END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF DEALLOCATE ( sigma_array ) CALL DestructSolverParameters ( params ) END SUBROUTINE HPCP !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix from a Hamiltonian using the Scale and Fold !> method. Based on the method of \\cite rubensson2011nonmonotonic . !> Note that for this method, you must provide the value of the homo and !> lumo gap. It is not necessary for these to be accurate, but give a !> conservative value. SUBROUTINE ScaleAndFold ( H , ISQ , trace , K , & & homo , lumo , energy_value_out , solver_parameters_in ) !> The matrix to compute the corresponding density from TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> A conservative estimate of the highest occupied eigenvalue. REAL ( NTREAL ), INTENT ( IN ) :: homo !> A conservative estimate of the lowest unoccupied eigenvalue. REAL ( NTREAL ), INTENT ( IN ) :: lumo !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WH TYPE ( Matrix_ps ) :: IMat TYPE ( Matrix_ps ) :: ISQT TYPE ( Matrix_ps ) :: X_k , X_k2 , TempMat !! Local Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: Beta , BetaBar , alpha REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value REAL ( NTREAL ) :: energy_value , energy_value_old !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Scale and Fold\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"rubensson2011nonmonotonic\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( K , H ) CALL ConstructEmptyMatrix ( WH , H ) CALL ConstructEmptyMatrix ( X_k , H ) CALL ConstructEmptyMatrix ( X_k2 , H ) CALL ConstructEmptyMatrix ( TempMat , H ) CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the lambda scaling value. CALL GershgorinBounds ( WH , e_min , e_max ) !! Initialize CALL CopyMatrix ( WH , X_k ) CALL ScaleMatrix ( X_k , - 1.0_NTREAL ) CALL IncrementMatrix ( IMat , X_k , alpha_in = e_max ) CALL ScaleMatrix ( X_k , 1.0_NTREAL / ( e_max - e_min )) Beta = ( e_max - lumo ) / ( e_max - e_min ) BetaBar = ( e_max - homo ) / ( e_max - e_min ) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL energy_value = 0.0_NTREAL DO II = 1 , params % max_iterations !! Determine the path CALL MatrixTrace ( X_k , trace_value ) IF ( trace_value . GT . trace ) THEN alpha = 2.0 / ( 2.0 - Beta ) CALL ScaleMatrix ( X_k , alpha ) CALL IncrementMatrix ( IMat , X_k , alpha_in = ( 1.0_NTREAL - alpha )) CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( X_k2 , X_k ) Beta = ( alpha * Beta + 1 - alpha ) ** 2 BetaBar = ( alpha * BetaBar + 1 - alpha ) ** 2 ELSE alpha = 2.0 / ( 1.0 + BetaBar ) CALL MatrixMultiply ( X_k , X_k , X_k2 , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL ScaleMatrix ( X_k , 2 * alpha ) CALL IncrementMatrix ( X_k2 , X_k , alpha_in = - 1.0_NTREAL * alpha ** 2 ) Beta = 2.0 * alpha * Beta - alpha ** 2 * Beta ** 2 BetaBar = 2.0 * alpha * BetaBar - alpha ** 2 * BetaBar ** 2 END IF !! Energy value based convergence energy_value_old = energy_value CALL DotMatrix ( X_k , WH , energy_value ) energy_value = 2.0_NTREAL * energy_value norm_value = ABS ( energy_value - energy_value_old ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( \"Energy Value\" , VALUE = energy_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( X_k ) END IF IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( X_k , X_k , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( X_k , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( X_k2 ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IMat ) CALL DestructMatrixMemoryPool ( pool ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE ScaleAndFold !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix using a dense routine. SUBROUTINE DenseDensity ( H , ISQ , trace , K , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params REAL ( NTREAL ) :: chemical_potential , energy_value !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Call the unified routine. CALL ComputeDenseFOE ( H , ISQ , trace , K , energy_value_out = energy_value , & & chemical_potential_out = chemical_potential , & & solver_parameters_in = params ) !! Optional out variables. IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF IF ( PRESENT ( chemical_potential_out )) THEN chemical_potential_out = chemical_potential END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE DenseDensity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the energy-weighted density matrix. SUBROUTINE EnergyDensityMatrix ( H , D , ED , threshold_in ) !> The matrix to compute from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The density matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: D !> The energy-weighted density matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: ED !> Threshold for flushing small values (default = 0). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Handling Optional Parameters REAL ( NTREAL ) :: threshold !! Optional Parameters IF ( PRESENT ( threshold_in )) THEN threshold = threshold_in ELSE threshold = 0.0_NTREAL END IF !! EDM = DM * H * DM CALL SimilarityTransform ( H , D , D , ED , threshold_in = threshold ) END SUBROUTINE EnergyDensityMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take one McWeeny Step DOut = 3*DSD - 2*DSDSD SUBROUTINE McWeenyStep ( D , DOut , S_in , threshold_in ) !> The density matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: D !> The resulting purified matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: DOut !> The overlap matrix (optional) TYPE ( Matrix_ps ), INTENT ( IN ), OPTIONAL :: S_in !> Threshold for flushing small values (default = 0). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Handling Optional Parameters REAL ( NTREAL ) :: threshold !! Local Variables TYPE ( Matrix_ps ) :: DS , DSD TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( threshold_in )) THEN threshold = threshold_in ELSE threshold = 0.0_NTREAL END IF !! Form the matrix DS IF ( PRESENT ( S_in )) THEN CALL MatrixMultiply ( D , S_in , DS , & & threshold_in = threshold , memory_pool_in = pool ) ELSE CALL CopyMatrix ( D , DS ) END IF !! Compute CALL MatrixMultiply ( DS , D , DSD , & & threshold_in = threshold , memory_pool_in = pool ) CALL MatrixMultiply ( DS , DSD , DOut , alpha_in = - 2.0_NTREAL , & & threshold_in = threshold , memory_pool_in = pool ) CALL IncrementMatrix ( DSD , DOut , alpha_in = 3.0_NTREAL ) !! Cleanup CALL DestructMatrix ( DS ) CALL DestructMatrix ( DSD ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE McWeenyStep !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DensityMatrixSolversModule","tags":"","loc":"sourcefile/densitymatrixsolversmodule.f90.html"},{"title":"FermiOperatorModule.F90 – NTPoly","text":"Contents Modules FermiOperatorModule Source Code FermiOperatorModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Density Matrix Using the Fermi Operator Expansion MODULE FermiOperatorModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE EigenSolversModule , ONLY : EigenDecomposition USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : WriteElement , WriteHeader , & & EnterSubLog , ExitSubLog , WriteListElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , SimilarityTransform , & & IncrementMatrix , MatrixNorm , ScaleMatrix , DotMatrix , MatrixTrace USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & FillMatrixFromTripletList , GetMatrixTripletList , & & TransposeMatrix , ConjugateMatrix , DestructMatrix , & & FillMatrixIdentity , PrintMatrixInformation , CopyMatrix , GetMatrixSize USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE SolverParametersModule , ONLY : SolverParameters_t , & & PrintParameters , DestructSolverParameters , CopySolverParameters , & & ConstructSolverParameters USE TripletListModule , ONLY : TripletList_r , DestructTripletList USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ComputeDenseFOE PUBLIC :: WOM_GC PUBLIC :: WOM_C CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix using a dense routine. SUBROUTINE ComputeDenseFOE ( H , ISQ , trace , K , inv_temp_in , & & energy_value_out , chemical_potential_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The trace of the density matrix (usually the number of electrons) REAL ( NTREAL ), INTENT ( IN ) :: trace !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The inverse temperature for smearing in a.u. (optional). REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: inv_temp_in !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> The chemical potential (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: chemical_potential_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params REAL ( NTREAL ) :: inv_temp LOGICAL :: do_smearing !! Local Variables TYPE ( Matrix_ps ) :: ISQT , WH TYPE ( Matrix_ps ) :: WD TYPE ( Matrix_ps ) :: vecs , vecsT , vals , Temp TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( TripletList_r ) :: tlist REAL ( NTREAL ) :: chemical_potential , energy_value REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: eigs , occ REAL ( NTREAL ) :: sval , sv , occ_temp REAL ( NTREAL ) :: left , right , homo , lumo INTEGER :: num_eigs INTEGER :: II , JJ INTEGER :: ierr !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( PRESENT ( inv_temp_in )) THEN inv_temp = inv_temp_in do_smearing = . TRUE . ELSE do_smearing = . FALSE . END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog IF ( do_smearing ) THEN CALL WriteElement ( key = \"Method\" , VALUE = \"Dense FOE\" ) CALL WriteElement ( key = \"Inverse Temperature\" , VALUE = inv_temp ) ELSE CALL WriteElement ( key = \"Method\" , VALUE = \"Dense Step Function\" ) END IF CALL PrintParameters ( params ) END IF !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL MatrixMultiply ( ISQ , H , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp , ISQT , WH , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Perform the eigendecomposition CALL EigenDecomposition ( WH , vals , & & eigenvectors_in = vecs , solver_parameters_in = params ) !! Gather the eigenvalues on to every process CALL GetMatrixTripletList ( vals , tlist ) num_eigs = H % actual_matrix_dimension ALLOCATE ( eigs ( num_eigs )) eigs = 0 DO II = 1 , tlist % CurrentSize eigs ( tlist % DATA ( II )% index_column ) = tlist % DATA ( II )% point_value END DO CALL MPI_ALLREDUCE ( MPI_IN_PLACE , eigs , num_eigs , MPINTREAL , & & MPI_SUM , H % process_grid % within_slice_comm , ierr ) !! Compute MU By Bisection IF ( do_smearing ) THEN ALLOCATE ( occ ( num_eigs )) left = MINVAL ( eigs ) right = MAXVAL ( eigs ) DO JJ = 1 , 10 * params % max_iterations chemical_potential = left + ( right - left ) / 2 DO II = 1 , num_eigs sval = eigs ( II ) - chemical_potential ! occ(II) = 0.5_NTREAL * (1.0_NTREAL - ERF(inv_temp * sval)) occ ( II ) = 1.0_NTREAL / ( 1.0_NTREAL + EXP ( inv_temp * sval )) END DO sv = SUM ( occ ) IF ( ABS ( trace - sv ) . LT . 1E-8_NTREAL ) THEN EXIT ELSE IF ( SV > trace ) THEN right = chemical_potential ELSE left = chemical_potential END IF END DO ELSE JJ = 1 homo = eigs ( FLOOR ( trace )) lumo = eigs ( FLOOR ( trace ) + 1 ) occ_temp = FLOOR ( TRACE ) + 1 - trace chemical_potential = homo + occ_temp * 0.5_NTREAL * ( lumo - homo ) END IF !! Write out result of chemical potential search IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Chemical Potential Search\" ) CALL EnterSubLog CALL WriteElement ( key = \"Potential\" , VALUE = chemical_potential ) CALL WriteElement ( key = \"Iterations\" , VALUE = JJ ) CALL ExitSubLog END IF !! Map energy_value = 0.0_NTREAL DO II = 1 , tlist % CurrentSize IF (. NOT . do_smearing ) THEN IF ( tlist % DATA ( II )% index_column . LE . FLOOR ( trace )) THEN energy_value = energy_value + tlist % DATA ( II )% point_value tlist % DATA ( II )% point_value = 1.0_NTREAL ELSE IF ( tlist % DATA ( II )% index_column . EQ . CEILING ( trace )) THEN occ_temp = CEILING ( trace ) - trace energy_value = energy_value + & & occ_temp * tlist % DATA ( II )% point_value tlist % DATA ( II )% point_value = occ_temp ELSE tlist % DATA ( II )% point_value = 0.0_NTREAL ENDIF ELSE sval = tlist % DATA ( II )% point_value - chemical_potential ! occ_temp = 0.5_NTREAL * (1.0_NTREAL - ERF(inv_temp * sval)) occ_temp = 1.0_NTREAL / ( 1.0_NTREAL + EXP ( inv_temp * sval )) energy_value = energy_value + occ_temp * tlist % DATA ( II )% point_value tlist % DATA ( II )% point_value = occ_temp END IF END DO CALL MPI_ALLREDUCE ( MPI_IN_PLACE , energy_value , 1 , MPINTREAL , MPI_SUM , & & H % process_grid % within_slice_comm , ierr ) !! Fill CALL ConstructEmptyMatrix ( vals , H ) CALL FillMatrixFromTripletList ( vals , tlist , preduplicated_in = . TRUE .) !! Multiply Back Together CALL MatrixMultiply ( vecs , vals , temp , threshold_in = params % threshold ) CALL TransposeMatrix ( vecs , vecsT ) CALL ConjugateMatrix ( vecsT ) CALL MatrixMultiply ( temp , vecsT , WD , & & threshold_in = params % threshold ) !! Compute the density matrix in the non-orthogonalized basis CALL MatrixMultiply ( ISQT , WD , Temp , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp , ISQ , K , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Optional out variables. IF ( PRESENT ( energy_value_out )) THEN energy_value_out = energy_value END IF IF ( PRESENT ( chemical_potential_out )) THEN chemical_potential_out = chemical_potential END IF !! Cleanup CALL DestructMatrix ( WH ) CALL DestructMatrix ( WD ) CALL DestructMatrix ( ISQT ) CALL DestructMatrix ( vecs ) CALL DestructMatrix ( vecst ) CALL DestructMatrix ( vals ) CALL DestructMatrix ( temp ) CALL DestructTripletList ( tlist ) CALL DestructMatrixMemoryPool ( pool ) IF ( ALLOCATED ( occ )) THEN DEALLOCATE ( occ ) END IF IF ( ALLOCATED ( eigs )) THEN DEALLOCATE ( eigs ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE ComputeDenseFOE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix according to the wave operator minization !! method at fixed chemical potential. SUBROUTINE WOM_GC ( H , ISQ , K , chemical_potential , inv_temp , & & energy_value_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The inverse temperature for smearing in a.u. REAL ( NTREAL ), INTENT ( IN ) :: inv_temp !> The chemical potential. REAL ( NTREAL ), INTENT ( IN ) :: chemical_potential !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Print out details IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"WOM_GC\" ) CALL WriteElement ( key = \"Inverse Temperature\" , VALUE = inv_temp ) CALL WriteElement ( key = \"Chemical Potential\" , & & VALUE = chemical_potential ) CALL PrintParameters ( params ) END IF IF ( PRESENT ( energy_value_out )) THEN CALL WOM_Implementation ( H , ISQ , K , inv_temp , params , & & mu_in = chemical_potential , energy_value_out = energy_value_out ) ELSE CALL WOM_Implementation ( H , ISQ , K , inv_temp , params , & & mu_in = chemical_potential ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE WOM_GC !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the density matrix according to the wave operator minization !! method at fixed number of electrons. SUBROUTINE WOM_C ( H , ISQ , K , trace , inv_temp , & & energy_value_out , solver_parameters_in ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The inverse temperature for smearing in a.u. REAL ( NTREAL ), INTENT ( IN ) :: inv_temp !> The target trace. REAL ( NTREAL ), INTENT ( IN ) :: trace !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !> Parameters for the solver (optional). TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Print out details IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"WOM_C\" ) CALL WriteElement ( key = \"Inverse Temperature\" , VALUE = inv_temp ) CALL WriteElement ( key = \"Target Trace\" , VALUE = trace ) CALL PrintParameters ( params ) END IF IF ( PRESENT ( energy_value_out )) THEN CALL WOM_Implementation ( H , ISQ , K , inv_temp , params , & & trace_in = trace , energy_value_out = energy_value_out ) ELSE CALL WOM_Implementation ( H , ISQ , K , inv_temp , params , & & trace_in = trace ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE WOM_C !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Actual implementation of WOM methods. SUBROUTINE WOM_Implementation ( H , ISQ , K , inv_temp , params , & & trace_in , mu_in , energy_value_out ) !> The matrix to compute the corresponding density from. TYPE ( Matrix_ps ), INTENT ( IN ) :: H !> The inverse square root of the overlap matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: ISQ !> The density matrix computed by this routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: K !> The inverse temperature for smearing in a.u. REAL ( NTREAL ), INTENT ( IN ) :: inv_temp !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> The target trace. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: trace_in !> The target mu. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: mu_in !> The energy of the system (optional). REAL ( NTREAL ), INTENT ( OUT ), OPTIONAL :: energy_value_out !! Local Variables LOGICAL :: GC TYPE ( Matrix_ps ) :: ISQT , WH , IMat , RK1 , RK2 , K0 , K1 TYPE ( Matrix_ps ) :: Temp , W , A , X , KOrth TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II REAL ( NTREAL ) :: step , B_I , err , sparsity GC = PRESENT ( mu_in ) !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( IMat , H ) CALL FillMatrixIdentity ( IMat ) !! Compute the working hamiltonian. CALL TransposeMatrix ( ISQ , ISQT ) CALL SimilarityTransform ( H , ISQ , ISQT , WH , pool , & & threshold_in = params % threshold ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WH , WH , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( IMat , IMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Construct the \"A\" Matrix IF ( GC ) THEN CALL CopyMatrix ( WH , A ) CALL IncrementMatrix ( IMat , A , alpha_in = - 1.0_NTREAL * mu_in ) ELSE CALL CopyMatrix ( WH , A ) END IF !! Construct the Initial Guess IF ( GC ) THEN CALL CopyMatrix ( IMat , W ) CALL ScaleMatrix ( W , 1.0_NTREAL / SQRT ( 2.0_NTREAL )) ELSE CALL CopyMatrix ( IMat , W ) CALL ScaleMatrix ( W , SQRT ( trace_in / WH % actual_matrix_dimension )) END IF !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 0 B_I = 0.0_NTREAL step = 1.0_NTREAL DO WHILE ( B_I . LT . inv_temp ) !! First order step step = MIN ( step , inv_temp - B_I ) CALL ComputeX ( W , IMat , pool , params % threshold , X ) IF ( GC ) THEN CALL ComputeGCStep ( X , A , pool , params % threshold , K0 ) ELSE CALL ComputeCStep ( X , A , W , pool , params % threshold , K0 ) END IF II = II + 1 CALL CopyMatrix ( K0 , RK1 ) CALL ScaleMatrix ( RK1 , step ) CALL IncrementMatrix ( W , RK1 , threshold_in = params % threshold ) !! Second Order Step CALL ComputeX ( RK1 , IMat , pool , params % threshold , X ) IF ( GC ) THEN CALL ComputeGCStep ( X , A , pool , params % threshold , K1 ) ELSE CALL ComputeCStep ( X , A , RK1 , pool , params % threshold , K1 ) END IF II = II + 1 CALL CopyMatrix ( W , RK2 ) CALL IncrementMatrix ( K0 , RK2 , alpha_in = step * 0.5_NTREAL , & & threshold_in = params % threshold ) CALL IncrementMatrix ( K1 , RK2 , alpha_in = step * 0.5_NTREAL , & & threshold_in = params % threshold ) !! Check the Error CALL CopyMatrix ( RK1 , Temp ) CALL IncrementMatrix ( RK2 , Temp , alpha_in = - 1.0_NTREAL , & & threshold_in = params % threshold ) err = MatrixNorm ( Temp ) !! Correct Step Size as Needed DO WHILE ( err . GT . 1.1 * params % step_thresh ) step = step * ( params % step_thresh / err ) ** ( 0.5 ) !! Update First Order CALL CopyMatrix ( K0 , RK1 ) CALL ScaleMatrix ( RK1 , step ) CALL IncrementMatrix ( W , RK1 , threshold_in = params % threshold ) !! Update Second Order CALL ComputeX ( RK1 , IMat , pool , params % threshold , X ) IF ( GC ) THEN CALL ComputeGCStep ( X , A , pool , params % threshold , K1 ) ELSE CALL ComputeCStep ( X , A , RK1 , pool , params % threshold , K1 ) END IF II = II + 1 CALL CopyMatrix ( W , RK2 ) CALL IncrementMatrix ( K0 , RK2 , alpha_in = step * 0.5_NTREAL , & & threshold_in = params % threshold ) CALL IncrementMatrix ( K1 , RK2 , alpha_in = step * 0.5_NTREAL , & & threshold_in = params % threshold ) !! New Error CALL CopyMatrix ( RK1 , Temp ) CALL IncrementMatrix ( RK2 , Temp , alpha_in = - 1.0_NTREAL , & & threshold_in = params % threshold ) err = MatrixNorm ( Temp ) END DO !! Update CALL CopyMatrix ( RK2 , W ) B_I = B_I + step step = step * ( params % step_thresh / err ) ** ( 0.5 ) sparsity = REAL ( GetMatrixSize ( W ), KIND = NTREAL ) / & & ( REAL ( W % actual_matrix_dimension , KIND = NTREAL ) ** 2 ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Gradient Evaluations\" , VALUE = II ) CALL EnterSubLog CALL WriteElement ( \"Beta\" , VALUE = B_I ) CALL WriteElement ( \"Sparsity\" , VALUE = sparsity ) CALL ExitSubLog END IF END DO !! Form the density CALL MatrixMultiply ( W , W , KOrth , & & threshold_in = params % threshold , memory_pool_in = pool ) IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total_Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( W ) END IF !! Compute the energy IF ( PRESENT ( energy_value_out )) THEN CALL DotMatrix ( WH , KOrth , energy_value_out ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( KOrth , KOrth , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Compute the density matrix in the non-orthogonalized basis CALL SimilarityTransform ( KOrth , ISQT , ISQ , K , pool , & & threshold_in = params % threshold ) END SUBROUTINE WOM_Implementation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the \"X\" matrix X = W [1 - W&#94;2] !> Take one step for the WOM_GC algorithm. SUBROUTINE ComputeX ( W , I , pool , threshold , Out ) !> The working wave operator. TYPE ( Matrix_ps ), INTENT ( IN ) :: W !> The identity matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: I !> The memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: pool !> The threshold for small values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The result matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Out !! Local matrices. TYPE ( Matrix_ps ) :: W2 , Temp !! Build CALL MatrixMultiply ( W , W , W2 , & & threshold_in = threshold , memory_pool_in = pool ) CALL CopyMatrix ( W2 , Temp ) CALL ScaleMatrix ( Temp , - 1.0_NTREAL ) CALL IncrementMatrix ( I , Temp , threshold_in = threshold ) CALL MatrixMultiply ( W , Temp , Out , & & threshold_in = threshold , memory_pool_in = pool ) !! Cleanup CALL DestructMatrix ( W2 ) CALL DestructMatrix ( Temp ) END SUBROUTINE ComputeX !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take one step for the WOM_GC algorithm. SUBROUTINE ComputeGCStep ( X , A , pool , threshold , Out ) !> The X matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: X !> H - mu*I TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: pool !> The threshold for small values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The result matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Out CALL MatrixMultiply ( X , A , Out , alpha_in = - 0.5_NTREAL , & & threshold_in = threshold , memory_pool_in = pool ) END SUBROUTINE ComputeGCStep !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take one step for the WOM_C algorithm. SUBROUTINE ComputeCStep ( X , A , W , pool , threshold , Out ) !> The X matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: X !> H TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The wave operator TYPE ( Matrix_ps ), INTENT ( IN ) :: W !> The memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: pool !> The threshold for small values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The identity matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Out !! Local matrices. TYPE ( Matrix_ps ) :: XA REAL ( NTREAL ) :: num , denom !! Form XA CALL MatrixMultiply ( X , A , XA , & & threshold_in = threshold , memory_pool_in = pool ) !! Scaling Factor Bottom CALL DotMatrix ( X , W , denom ) CALL DotMatrix ( W , XA , num ) CALL CopyMatrix ( X , Out ) CALL ScaleMatrix ( Out , - 1.0_NTREAL * num / denom ) !! Combine CALL IncrementMatrix ( XA , Out ) CALL ScaleMatrix ( Out , - 0.5_NTREAL ) !! Cleanup CALL DestructMatrix ( XA ) END SUBROUTINE ComputeCStep !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE FermiOperatorModule","tags":"","loc":"sourcefile/fermioperatormodule.f90.html"},{"title":"MatrixReduceModule.F90 – NTPoly","text":"Contents Modules MatrixReduceModule Source Code MatrixReduceModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for reducing matrices across processes. MODULE MatrixReduceModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , MPINTCOMPLEX , MPINTINTEGER USE SMatrixAlgebraModule , ONLY : IncrementMatrix USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , ConstructEmptyMatrix , & & DestructMatrix , CopyMatrix USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data structure to stores internal information about a reduce call. TYPE , PUBLIC :: ReduceHelper_t !> Number of processors involved in this gather. INTEGER :: comm_size !> A request object for gathering outer indices. INTEGER :: outer_request !> A request object for gathering inner indices. INTEGER :: inner_request !> A request object for gathering data. INTEGER :: data_request !> The error code after an MPI call. INTEGER :: error_code !> Number of values to gather from each process. INTEGER , DIMENSION (:), ALLOCATABLE :: values_per_process !> The displacements for where those gathered values should go. INTEGER , DIMENSION (:), ALLOCATABLE :: displacement #ifdef NOIALLGATHER !> For mpi backup, a list of request objets for outer indices. INTEGER , DIMENSION (:), ALLOCATABLE :: outer_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: outer_recv_request_list !> For mpi backup, a list of request objects for inner indices. INTEGER , DIMENSION (:), ALLOCATABLE :: inner_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: inner_recv_request_list !> For mpi backup, a list of request object for data. INTEGER , DIMENSION (:), ALLOCATABLE :: data_send_request_list INTEGER , DIMENSION (:), ALLOCATABLE :: data_recv_request_list #endif END TYPE ReduceHelper_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ReduceAndComposeMatrixSizes PUBLIC :: ReduceAndComposeMatrixData PUBLIC :: ReduceAndComposeMatrixCleanup PUBLIC :: ReduceAndComposeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ReduceAndSumMatrixSizes PUBLIC :: ReduceAndSumMatrixData PUBLIC :: ReduceAndSumMatrixCleanup PUBLIC :: ReduceAndSumMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: TestReduceSizeRequest PUBLIC :: TestReduceInnerRequest PUBLIC :: TestReduceDataRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ReduceAndComposeMatrixSizes MODULE PROCEDURE ReduceAndComposeMatrixSizes_lsr MODULE PROCEDURE ReduceAndComposeMatrixSizes_lsc END INTERFACE ReduceAndComposeMatrixSizes INTERFACE ReduceAndComposeMatrixData MODULE PROCEDURE ReduceAndComposeMatrixData_lsr MODULE PROCEDURE ReduceAndComposeMatrixData_lsc END INTERFACE ReduceAndComposeMatrixData INTERFACE ReduceAndComposeMatrixCleanup MODULE PROCEDURE ReduceAndComposeMatrixCleanup_lsr MODULE PROCEDURE ReduceAndComposeMatrixCleanup_lsc END INTERFACE ReduceAndComposeMatrixCleanup INTERFACE ReduceAndComposeMatrix MODULE PROCEDURE ReduceAndComposeMatrix_lsr MODULE PROCEDURE ReduceAndComposeMatrix_lsc END INTERFACE ReduceAndComposeMatrix INTERFACE ReduceAndSumMatrixSizes MODULE PROCEDURE ReduceAndSumMatrixSizes_lsr MODULE PROCEDURE ReduceAndSumMatrixSizes_lsc END INTERFACE ReduceAndSumMatrixSizes INTERFACE ReduceAndSumMatrixData MODULE PROCEDURE ReduceAndSumMatrixData_lsr MODULE PROCEDURE ReduceAndSumMatrixData_lsc END INTERFACE ReduceAndSumMatrixData INTERFACE ReduceAndSumMatrixCleanup MODULE PROCEDURE ReduceAndSumMatrixCleanup_lsr MODULE PROCEDURE ReduceAndSumMatrixCleanup_lsc END INTERFACE ReduceAndSumMatrixCleanup INTERFACE ReduceAndSumMatrix MODULE PROCEDURE ReduceAndSumMatrix_lsr MODULE PROCEDURE ReduceAndSumMatrix_lsc END INTERFACE ReduceAndSumMatrix CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndComposeMatrixSizes_lsr ( matrix , comm , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The  helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndComposeMatrixSizes_sendrecv.f90\" #else #include \"comm_includes/ReduceAndComposeMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndComposeMatrixSizes_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndComposeMatrixSizes_lsc ( matrix , comm , gathered_matrix , & & helper ) !! The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !! The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !! The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndComposeMatrixSizes_sendrecv.f90\" #else #include \"comm_includes/ReduceAndComposeMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndComposeMatrixSizes_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second function to call, will gather the data and align one matrix !> next to another. SUBROUTINE ReduceAndComposeMatrixData_lsr ( matrix , comm , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndComposeMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTREAL , & & II - 1 , 4 , comm , helper % data_send_request_list ( II ), ierr ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , MPINTREAL , & & II - 1 , 4 , comm , helper % data_recv_request_list ( II ), ierr ) END DO #else #include \"comm_includes/ReduceAndComposeMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTREAL ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTREAL , comm , helper % data_request , ierr ) #endif END SUBROUTINE ReduceAndComposeMatrixData_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second function to call, will gather the data and align one matrix !> next to another. SUBROUTINE ReduceAndComposeMatrixData_lsc ( matrix , comm , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndComposeMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX , & & II - 1 , 4 , comm , helper % data_send_request_list ( II ), ierr ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , & & MPINTCOMPLEX , II - 1 , 4 , comm , & & helper % data_recv_request_list ( II ), ierr ) END DO #else #include \"comm_includes/ReduceAndComposeMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTCOMPLEX , comm , helper % data_request , ierr ) #endif END SUBROUTINE ReduceAndComposeMatrixData_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Third function to call, finishes setting up the matrices. PURE SUBROUTINE ReduceAndComposeMatrixCleanup_lsr ( matrix , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #include \"comm_includes/ReduceAndComposeMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndComposeMatrixCleanup_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Third function to call, finishes setting up the matrices. PURE SUBROUTINE ReduceAndComposeMatrixCleanup_lsc ( matrix , gathered_matrix , & & helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #include \"comm_includes/ReduceAndComposeMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndComposeMatrixCleanup_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Reduce and sum the matrices in one step. If you use this method, you !> lose the opportunity for overlapping communication. SUBROUTINE ReduceAndComposeMatrix_lsr ( matrix , comm , gathered_matrix ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !! Local Variables TYPE ( ReduceHelper_t ) :: helper #include \"comm_includes/ReduceAndComposeMatrix.f90\" END SUBROUTINE ReduceAndComposeMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Reduce and sum the matrices in one step. If you use this method, you !> lose the opportunity for overlapping communication. SUBROUTINE ReduceAndComposeMatrix_lsc ( matrix , comm , gathered_matrix ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !! Local Variables TYPE ( ReduceHelper_t ) :: helper #include \"comm_includes/ReduceAndComposeMatrix.f90\" END SUBROUTINE ReduceAndComposeMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndSumMatrixSizes_lsr ( matrix , comm , gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The  helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndSumMatrixSizes_sendrecv.f90\" #else #include \"comm_includes/ReduceAndSumMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndSumMatrixSizes_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The first routine to call, gathers the sizes of the data to be sent. SUBROUTINE ReduceAndSumMatrixSizes_lsc ( matrix , comm , gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndSumMatrixSizes_sendrecv.f90\" #else #include \"comm_includes/ReduceAndSumMatrixSizes.f90\" #endif END SUBROUTINE ReduceAndSumMatrixSizes_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second routine to call for gathering and summing up the data. SUBROUTINE ReduceAndSumMatrixData_lsr ( matrix , comm , gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndSumMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTREAL , & & II - 1 , 4 , comm , helper % data_send_request_list ( II ), ierr ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , MPINTREAL , & & II - 1 , 4 , comm , helper % data_recv_request_list ( II ), ierr ) END DO #else #include \"comm_includes/ReduceAndSumMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTREAL ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTREAL , comm , helper % data_request , ierr ) #endif END SUBROUTINE ReduceAndSumMatrixData_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Second routine to call for gathering and summing up the data. SUBROUTINE ReduceAndSumMatrixData_lsc ( matrix , comm , gathered_matrix , helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The matrix we are gathering. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper #ifdef NOIALLGATHER #include \"comm_includes/ReduceAndSumMatrixData_sendrecv.f90\" DO II = 1 , helper % comm_size CALL MPI_ISend ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX , & & II - 1 , 4 , comm , helper % data_send_request_list ( II ), ierr ) istart = helper % displacement ( II ) + 1 isize = helper % values_per_process ( II ) iend = istart + isize - 1 CALL MPI_Irecv ( gathered_matrix % values ( istart : iend ), isize , & & MPINTCOMPLEX , II - 1 , 4 , comm , & & helper % data_recv_request_list ( II ), ierr ) END DO #else #include \"comm_includes/ReduceAndSumMatrixData.f90\" CALL MPI_IAllGatherv ( matrix % values , SIZE ( matrix % values ), MPINTCOMPLEX ,& & gathered_matrix % values , helper % values_per_process , & & helper % displacement , MPINTCOMPLEX , comm , helper % data_request , ierr ) #endif END SUBROUTINE ReduceAndSumMatrixData_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Finally routine to sum up the matrices. PURE SUBROUTINE ReduceAndSumMatrixCleanup_lsr ( matrix , gathered_matrix , & & threshold , helper ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The gathered_matrix the matrix being gathered. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !! Local Data TYPE ( Matrix_lsr ) :: acc_matrix , sum_matrix #include \"comm_includes/ReduceAndSumMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndSumMatrixCleanup_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Finally routine to sum up the matrices. PURE SUBROUTINE ReduceAndSumMatrixCleanup_lsc ( matrix , gathered_matrix , & & threshold , helper ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The threshold the threshold for flushing values. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> The helper associated with this gather. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !! Local Data TYPE ( Matrix_lsc ) :: acc_matrix , sum_matrix #include \"comm_includes/ReduceAndSumMatrixCleanup.f90\" #ifdef NOIALLGATHER IF ( ALLOCATED ( helper % outer_send_request_list )) THEN DEALLOCATE ( helper % outer_send_request_list ) END IF IF ( ALLOCATED ( helper % outer_recv_request_list )) THEN DEALLOCATE ( helper % outer_recv_request_list ) END IF IF ( ALLOCATED ( helper % inner_send_request_list )) THEN DEALLOCATE ( helper % inner_send_request_list ) END IF IF ( ALLOCATED ( helper % inner_recv_request_list )) THEN DEALLOCATE ( helper % inner_recv_request_list ) END IF IF ( ALLOCATED ( helper % data_send_request_list )) THEN DEALLOCATE ( helper % data_send_request_list ) END IF IF ( ALLOCATED ( helper % data_recv_request_list )) THEN DEALLOCATE ( helper % data_recv_request_list ) END IF #endif END SUBROUTINE ReduceAndSumMatrixCleanup_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Reduce and sum the matrices in one step. If you use this method, you !> lose the opportunity for overlapping communication. SUBROUTINE ReduceAndSumMatrix_lsr ( matrix , comm , gathered_matrix , threshold ) !> The matrix to send. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The gathered_matrix the matrix being gathered. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( ReduceHelper_t ) :: helper #include \"comm_includes/ReduceAndSumMatrix.f90\" END SUBROUTINE ReduceAndSumMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Reduce and sum the matrices in one step. If you use this method, you !> lose the opportunity for overlapping communication. SUBROUTINE ReduceAndSumMatrix_lsc ( matrix , comm , gathered_matrix , threshold ) !> The matrix to send. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix !> The communicator to send along. INTEGER , INTENT ( INOUT ) :: comm !> The threshold the threshold for flushing values. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: gathered_matrix !> The threshold the threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( ReduceHelper_t ) :: helper #include \"comm_includes/ReduceAndSumMatrix.f90\" END SUBROUTINE ReduceAndSumMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the size of the matrices is complete. FUNCTION TestReduceSizeRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % outer_send_request_list ), & & helper % outer_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % outer_recv_request_list ), & & helper % outer_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % outer_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceSizeRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the inner indices of the matrices is complete. FUNCTION TestReduceInnerRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % inner_send_request_list ), & & helper % inner_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % inner_recv_request_list ), & & helper % inner_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % inner_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceInnerRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Test if a request for the data of the matrices is complete. FUNCTION TestReduceDataRequest ( helper ) RESULT ( request_completed ) !> The gatherer helper structure. TYPE ( ReduceHelper_t ), INTENT ( INOUT ) :: helper !> True if the request is finished. LOGICAL :: request_completed #ifdef NOIALLGATHER LOGICAL :: send_request_completed , recv_request_completed CALL MPI_Testall ( SIZE ( helper % data_send_request_list ), & & helper % data_send_request_list , send_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) CALL MPI_Testall ( SIZE ( helper % data_recv_request_list ), & & helper % data_recv_request_list , recv_request_completed , & & MPI_STATUSES_IGNORE , helper % error_code ) request_completed = send_request_completed . AND . recv_request_completed #else CALL MPI_Test ( helper % data_request , request_completed , & & MPI_STATUS_IGNORE , helper % error_code ) #endif END FUNCTION TestReduceDataRequest !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixReduceModule","tags":"","loc":"sourcefile/matrixreducemodule.f90.html"},{"title":"SMatrixModule.F90 – NTPoly","text":"Contents Modules SMatrixModule Source Code SMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling locally stored CSR matrices. MODULE SMatrixModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX , NTLONG USE MatrixMarketModule , ONLY : ParseMMHeader , WriteMMSize , WriteMMLine , & & MAX_LINE_LENGTH USE TripletListModule , ONLY : TripletList_r , TripletList_c , SortTripletList , & & DestructTripletList , ConstructTripletList , AppendToTripletList , & & SymmetrizeTripletList , ConvertTripletListType USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a local, real CSR matrix. TYPE , PUBLIC :: Matrix_lsr INTEGER , DIMENSION (:), ALLOCATABLE :: outer_index !< Outer indices INTEGER , DIMENSION (:), ALLOCATABLE :: inner_index !< Inner indices REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: values !< Values INTEGER :: rows !< Matrix dimension: rows INTEGER :: columns !< Matrix dimension: columns END TYPE Matrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a local, complex CSR matrix. TYPE , PUBLIC :: Matrix_lsc INTEGER , DIMENSION (:), ALLOCATABLE :: outer_index !< Outer indices INTEGER , DIMENSION (:), ALLOCATABLE :: inner_index !< Inner indices COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: values !< Values INTEGER :: rows !< Matrix dimension: rows INTEGER :: columns !< Matrix dimension: columns END TYPE Matrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Construct/Destruct PUBLIC :: ConstructEmptyMatrix PUBLIC :: ConstructMatrixFromFile PUBLIC :: ConstructMatrixFromTripletList PUBLIC :: DestructMatrix PUBLIC :: CopyMatrix !! Basic Accessors PUBLIC :: GetMatrixRows PUBLIC :: GetMatrixColumns PUBLIC :: ExtractMatrixRow PUBLIC :: ExtractMatrixColumn !! Routines for splitting and composing PUBLIC :: SplitMatrix PUBLIC :: SplitMatrixColumns PUBLIC :: ComposeMatrix PUBLIC :: ComposeMatrixColumns !! ETC PUBLIC :: ConvertMatrixType PUBLIC :: TransposeMatrix PUBLIC :: ConjugateMatrix PUBLIC :: PrintMatrix PUBLIC :: MatrixToTripletList !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrixSub_lsr MODULE PROCEDURE ConstructEmptyMatrixSub_lsc END INTERFACE ConstructEmptyMatrix INTERFACE ConstructMatrixFromFile MODULE PROCEDURE ConstructMatrixFromFileSub_lsr MODULE PROCEDURE ConstructMatrixFromFileSub_lsc END INTERFACE ConstructMatrixFromFile INTERFACE ConstructMatrixFromTripletList MODULE PROCEDURE ConstructMatrixFromTripletListSub_lsr MODULE PROCEDURE ConstructMatrixFromTripletListSub_lsc END INTERFACE ConstructMatrixFromTripletList INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_lsr MODULE PROCEDURE DestructMatrix_lsc END INTERFACE DestructMatrix INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_lsr MODULE PROCEDURE CopyMatrix_lsc END INTERFACE CopyMatrix INTERFACE GetMatrixRows MODULE PROCEDURE GetMatrixRows_lsr MODULE PROCEDURE GetMatrixRows_lsc END INTERFACE GetMatrixRows INTERFACE GetMatrixColumns MODULE PROCEDURE GetMatrixColumns_lsr MODULE PROCEDURE GetMatrixColumns_lsc END INTERFACE GetMatrixColumns INTERFACE ExtractMatrixRow MODULE PROCEDURE ExtractMatrixRow_lsr MODULE PROCEDURE ExtractMatrixRow_lsc END INTERFACE ExtractMatrixRow INTERFACE ExtractMatrixColumn MODULE PROCEDURE ExtractMatrixColumn_lsr MODULE PROCEDURE ExtractMatrixColumn_lsc END INTERFACE ExtractMatrixColumn INTERFACE SplitMatrix MODULE PROCEDURE SplitMatrix_lsr MODULE PROCEDURE SplitMatrix_lsc END INTERFACE SplitMatrix INTERFACE SplitMatrixColumns MODULE PROCEDURE SplitMatrixColumns_lsr MODULE PROCEDURE SplitMatrixColumns_lsc END INTERFACE SplitMatrixColumns INTERFACE ComposeMatrix MODULE PROCEDURE ComposeMatrix_lsr MODULE PROCEDURE ComposeMatrix_lsc END INTERFACE ComposeMatrix INTERFACE ComposeMatrixColumns MODULE PROCEDURE ComposeMatrixColumns_lsr MODULE PROCEDURE ComposeMatrixColumns_lsc END INTERFACE ComposeMatrixColumns INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_lsr MODULE PROCEDURE TransposeMatrix_lsc END INTERFACE TransposeMatrix INTERFACE ConjugateMatrix MODULE PROCEDURE ConjugateMatrix_lsc END INTERFACE ConjugateMatrix INTERFACE PrintMatrix MODULE PROCEDURE PrintMatrix_lsr MODULE PROCEDURE PrintMatrix_lsc END INTERFACE PrintMatrix INTERFACE MatrixToTripletList MODULE PROCEDURE MatrixToTripletList_lsr MODULE PROCEDURE MatrixToTripletList_lsc END INTERFACE MatrixToTripletList INTERFACE ConvertMatrixType MODULE PROCEDURE ConvertMatrixType_lsrtolsc MODULE PROCEDURE ConvertMatrixType_lsctolsr END INTERFACE ConvertMatrixType CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine type wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSub_lsr ( this , rows , columns , zero_in ) !> The matrix to construct. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in #include \"sparse_includes/ConstructEmptyMatrix.f90\" END SUBROUTINE ConstructEmptyMatrixSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine type wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSub_lsc ( this , rows , columns , zero_in ) !> The matrix to construct. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> The number of matrix columns. INTEGER , INTENT ( IN ) :: columns !> The number of matrix rows. INTEGER , INTENT ( IN ) :: rows !> Whether to set the matrix to zero. LOGICAL , INTENT ( IN ), OPTIONAL :: zero_in #include \"sparse_includes/ConstructEmptyMatrix.f90\" END SUBROUTINE ConstructEmptyMatrixSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Subroutine wrapper for the construct from file function. SUBROUTINE ConstructMatrixFromFileSub_lsr ( this , file_name ) !> The matrix being constructed. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Local Data TYPE ( TripletList_r ) :: tlist TYPE ( TripletList_r ) :: sorted_tlist TYPE ( Triplet_r ) :: temp #include \"sparse_includes/ConstructMatrixFromFile.f90\" END SUBROUTINE ConstructMatrixFromFileSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE ConstructMatrixFromFileSub_lsc ( this , file_name ) !> The matrix being constructed. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> Name of the file. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Local Data TYPE ( TripletList_c ) :: tlist TYPE ( TripletList_c ) :: sorted_tlist TYPE ( Triplet_c ) :: temp REAL ( NTREAL ) :: real_val , comp_val #define ISCOMPLEX #include \"sparse_includes/ConstructMatrixFromFile.f90\" #undef ISCOMPLEX END SUBROUTINE ConstructMatrixFromFileSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the triplet list based constructor. PURE SUBROUTINE ConstructMatrixFromTripletListSub_lsr ( this , triplet_list , & & rows , columns ) !> The matrix being constructed TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns #define ISCOMPLEX #include \"sparse_includes/ConstructMatrixFromTripletList.f90\" #undef ISCOMPLEX END SUBROUTINE ConstructMatrixFromTripletListSub_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the triplet list based constructor. PURE SUBROUTINE ConstructMatrixFromTripletListSub_lsc ( this , triplet_list , & & rows , columns ) !> The matrix being constructed TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this !> A list of triplet values. They must be sorted. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> Number of matrix rows INTEGER , INTENT ( IN ) :: rows !> Number of matrix columns INTEGER , INTENT ( IN ) :: columns #include \"sparse_includes/ConstructMatrixFromTripletList.f90\" END SUBROUTINE ConstructMatrixFromTripletListSub_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Explicitly destruct a sparse matrix. PURE SUBROUTINE DestructMatrix_lsr ( this ) !> The matrix to free up. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: this #include \"sparse_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Explicitly destruct a sparse matrix. PURE SUBROUTINE DestructMatrix_lsc ( this ) !> The matrix to free up. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this #include \"sparse_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a sparse matrix in a safe way. PURE SUBROUTINE CopyMatrix_lsr ( matA , matB ) !> Matrix to copy TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matB #include \"sparse_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a sparse matrix in a safe way. PURE SUBROUTINE CopyMatrix_lsc ( matA , matB ) !> Matrix to copy TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matB #include \"sparse_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of rows of a matrix. PURE FUNCTION GetMatrixRows_lsr ( this ) RESULT ( rows ) !> The matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The number of rows. INTEGER :: rows #include \"sparse_includes/GetMatrixRows.f90\" END FUNCTION GetMatrixRows_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of rows of a matrix. PURE FUNCTION GetMatrixRows_lsc ( this ) RESULT ( rows ) !> The matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The number of rows. INTEGER :: rows #include \"sparse_includes/GetMatrixRows.f90\" END FUNCTION GetMatrixRows_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of columns of a matrix. PURE FUNCTION GetMatrixColumns_lsr ( this ) RESULT ( columns ) !! The matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The number of columns. INTEGER :: columns #include \"sparse_includes/GetMatrixColumns.f90\" END FUNCTION GetMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the number of columns of a matrix. PURE FUNCTION GetMatrixColumns_lsc ( this ) RESULT ( columns ) !! The matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The number of columns. INTEGER :: columns #include \"sparse_includes/GetMatrixColumns.f90\" END FUNCTION GetMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a row from the matrix. PURE SUBROUTINE ExtractMatrixRow_lsr ( this , row_number , row_out ) !> The matrix to extract from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The row to extract. INTEGER , INTENT ( IN ) :: row_number !> The matrix representing that row. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: row_out !! Temporary Variables REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: value_buffer #include \"sparse_includes/ExtractMatrixRow.f90\" END SUBROUTINE ExtractMatrixRow_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a row from the matrix. PURE SUBROUTINE ExtractMatrixRow_lsc ( this , row_number , row_out ) !> The matrix to extract from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The row to extract. INTEGER , INTENT ( IN ) :: row_number !> The matrix representing that row. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: row_out !! Temporary Variables COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: value_buffer #include \"sparse_includes/ExtractMatrixRow.f90\" END SUBROUTINE ExtractMatrixRow_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a column from the matrix. PURE SUBROUTINE ExtractMatrixColumn_lsr ( this , column_number , column_out ) !> The matrix to extract from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The column to extract. INTEGER , INTENT ( IN ) :: column_number !> The column representing that row. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: column_out #include \"sparse_includes/ExtractMatrixColumn.f90\" END SUBROUTINE ExtractMatrixColumn_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract a column from the matrix. PURE SUBROUTINE ExtractMatrixColumn_lsc ( this , column_number , column_out ) !> The matrix to extract from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The column to extract. INTEGER , INTENT ( IN ) :: column_number !> The column representing that row. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: column_out #include \"sparse_includes/ExtractMatrixColumn.f90\" END SUBROUTINE ExtractMatrixColumn_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix and return it in a separate matrix. !> The current implementation has you go from matrix to triplet list, !> triplet list to transposed triplet list. The triplet list must then be !> sorted and then the return matrix is constructed. PURE SUBROUTINE TransposeMatrix_lsr ( this , matT ) !> The matrix to be transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The input matrix transposed. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matT #include \"sparse_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix and return it in a separate matrix. !> The current implementation has you go from matrix to triplet list, !> triplet list to transposed triplet list. The triplet list must then be !> sorted and then the return matrix is constructed. PURE SUBROUTINE TransposeMatrix_lsc ( this , matT ) !> The matrix to be transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The input matrix transposed. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matT #include \"sparse_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_lsr ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_lsr ), DIMENSION (:, :), INTENT ( IN ) :: mat_array !> The composed matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: out_matrix !! Local Data TYPE ( Matrix_lsr ), DIMENSION ( block_columns ) :: merged_columns TYPE ( Matrix_lsr ) :: Temp TYPE ( Matrix_lsr ), DIMENSION ( block_rows , block_columns ) :: mat_t #include \"sparse_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_lsc ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_lsc ), DIMENSION (:, :), INTENT ( IN ) :: mat_array !> The composed matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: out_matrix !! Local Data TYPE ( Matrix_lsc ), DIMENSION ( block_columns ) :: merged_columns TYPE ( Matrix_lsc ) :: Temp TYPE ( Matrix_lsc ), DIMENSION ( block_rows , block_columns ) :: mat_t #include \"sparse_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of !> the first matrix are followed by the columns of the matrices in the list. PURE SUBROUTINE ComposeMatrixColumns_lsr ( mat_list , out_matrix ) !> A list of matrices to compose. TYPE ( Matrix_lsr ), DIMENSION (:), INTENT ( IN ) :: mat_list !> out_matrix = [Matrix 1 | Matrix 2, ...]. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: out_matrix #include \"sparse_includes/ComposeMatrixColumns.f90\" END SUBROUTINE ComposeMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big Matrix C = [Matrix 1 | Matrix 1, ...] where the columns of !> the first matrix are followed by the columns of the matrices in the list. PURE SUBROUTINE ComposeMatrixColumns_lsc ( mat_list , out_matrix ) !> A list of matrices to compose. TYPE ( Matrix_lsc ), DIMENSION (:), INTENT ( IN ) :: mat_list !> out_matrix = [Matrix 1 | Matrix 2, ...]. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: out_matrix #include \"sparse_includes/ComposeMatrixColumns.f90\" END SUBROUTINE ComposeMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_lsr ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_lsr ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in !! Local Data TYPE ( Matrix_lsr ), DIMENSION ( block_columns ) :: column_split TYPE ( Matrix_lsr ), DIMENSION ( block_rows ) :: row_split TYPE ( Matrix_lsr ) :: Temp #include \"sparse_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_lsc ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_lsc ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in !! Local Data TYPE ( Matrix_lsc ), DIMENSION ( block_columns ) :: column_split TYPE ( Matrix_lsc ), DIMENSION ( block_rows ) :: row_split TYPE ( Matrix_lsc ) :: Temp #include \"sparse_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a matrix into into small blocks based on the specified offsets. PURE SUBROUTINE SplitMatrixColumns_lsr ( this , num_blocks , block_sizes , & & split_list ) !> This matrix to perform this operation on. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Number of blocks to split into. INTEGER , INTENT ( IN ) :: num_blocks !> The sizes used for splitting. INTEGER , DIMENSION ( num_blocks ), INTENT ( IN ) :: block_sizes !> 1D array of blocks. TYPE ( Matrix_lsr ), DIMENSION ( num_blocks ), INTENT ( INOUT ) :: split_list #include \"sparse_includes/SplitMatrixColumns.f90\" END SUBROUTINE SplitMatrixColumns_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a matrix into into small blocks based on the specified offsets. PURE SUBROUTINE SplitMatrixColumns_lsc ( this , num_blocks , block_sizes , & & split_list ) !> This matrix to perform this operation on. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Number of blocks to split into. INTEGER , INTENT ( IN ) :: num_blocks !> The sizes used for splitting. INTEGER , DIMENSION ( num_blocks ), INTENT ( IN ) :: block_sizes !> 1D array of blocks. TYPE ( Matrix_lsc ), DIMENSION ( num_blocks ), INTENT ( INOUT ) :: split_list #include \"sparse_includes/SplitMatrixColumns.f90\" END SUBROUTINE SplitMatrixColumns_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list from a matrix. PURE SUBROUTINE MatrixToTripletList_lsr ( this , triplet_list ) !> The matrix to construct the triplet list from. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The triplet list we created. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list #include \"sparse_includes/MatrixToTripletList.f90\" END SUBROUTINE MatrixToTripletList_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a triplet list from a matrix. PURE SUBROUTINE MatrixToTripletList_lsc ( this , triplet_list ) !> The matrix to construct the triplet list from. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The triplet list we created. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list #include \"sparse_includes/MatrixToTripletList.f90\" END SUBROUTINE MatrixToTripletList_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a sparse matrix to the console. SUBROUTINE PrintMatrix_lsr ( this , file_name_in ) !> The matrix to be printed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> Optionally you can pass a file to print to. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Local Data TYPE ( TripletList_r ) :: triplet_list #include \"sparse_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a sparse matrix to the console. SUBROUTINE PrintMatrix_lsc ( this , file_name_in ) !> The matrix to be printed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> Optionally you can pass a file to print to. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Local Data TYPE ( TripletList_c ) :: triplet_list #define ISCOMPLEX #include \"sparse_includes/PrintMatrix.f90\" #undef ISCOMPLEX END SUBROUTINE PrintMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Every value in the matrix is changed into its complex conjugate. PURE SUBROUTINE ConjugateMatrix_lsc ( this ) !> The matrix to compute the complex conjugate of. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: this this % values (:) = CONJG ( this % values ) END SUBROUTINE ConjugateMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex matrix to a real matrix. SUBROUTINE ConvertMatrixType_lsrtolsc ( cin , rout ) !> The starting matrix. TYPE ( Matrix_lsc ), INTENT ( IN ) :: cin !> Real valued matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: rout !! Local Variables TYPE ( TripletList_c ) :: in_list TYPE ( TripletList_r ) :: out_list CALL MatrixToTripletList ( cin , in_list ) CALL ConvertTripletListType ( in_list , out_list ) CALL ConstructMatrixFromTripletList ( rout , out_list , cin % rows , cin % columns ) CALL DestructTripletList ( in_list ) CALL DestructTripletList ( out_list ) END SUBROUTINE ConvertMatrixType_lsrtolsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real matrix to a complex matrix. SUBROUTINE ConvertMatrixType_lsctolsr ( rin , cout ) !> The starting matrix. TYPE ( Matrix_lsr ), INTENT ( IN ) :: rin !> The complex valued matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: cout !! Local Variables TYPE ( TripletList_r ) :: in_list TYPE ( TripletList_c ) :: out_list CALL MatrixToTripletList ( rin , in_list ) CALL ConvertTripletListType ( in_list , out_list ) CALL ConstructMatrixFromTripletList ( cout , out_list , rin % rows , rin % columns ) CALL DestructTripletList ( in_list ) CALL DestructTripletList ( out_list ) END SUBROUTINE ConvertMatrixType_lsctolsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SMatrixModule","tags":"","loc":"sourcefile/smatrixmodule.f90.html"},{"title":"DataTypesModule.F90 – NTPoly","text":"Contents Modules DataTypesModule Source Code DataTypesModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to store specifications for basic data types. MODULE DataTypesModule USE NTMPIModule USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_DOUBLE , C_DOUBLE_COMPLEX , C_LONG IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The precision of floating point numbers we will use in this program. INTEGER , PARAMETER , PUBLIC :: NTREAL = C_DOUBLE !> MPI floating point datatype with the precision we will use in this program. INTEGER , PUBLIC :: MPINTREAL = MPI_DOUBLE_PRECISION !> The complex numbers we will use in this program. INTEGER , PARAMETER , PUBLIC :: NTCOMPLEX = C_DOUBLE_COMPLEX !> MPI complex datatype with the precision we will use in this program. INTEGER , PARAMETER , PUBLIC :: MPINTCOMPLEX = MPI_DOUBLE_COMPLEX !> A long integer type for when normal ints will not do INTEGER , PARAMETER , PUBLIC :: NTLONG = C_LONG !> MPI Integer type we will use in this program. INTEGER , PARAMETER , PUBLIC :: MPINTINTEGER = MPI_INTEGER !> MPI Integer type we will use in this program. INTEGER , PARAMETER , PUBLIC :: MPINTLONG = MPI_LONG !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DataTypesModule","tags":"","loc":"sourcefile/datatypesmodule.f90.html"},{"title":"ExponentialSolversModule.F90 – NTPoly","text":"Contents Modules ExponentialSolversModule Source Code ExponentialSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing Matrix Exponentials and Logarithms. MODULE ExponentialSolversModule USE ChebyshevSolversModule , ONLY : ChebyshevPolynomial_t , Compute , & & ConstructPolynomial , DestructPolynomial , FactorizedCompute , & & SetCoefficient USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds , PowerBounds USE EigenSolversModule , ONLY : DenseMatrixFunction USE LinearSolversModule , ONLY : CGSolver USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , WriteElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , ScaleMatrix , & & IncrementMatrix USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE RootSolversModule , ONLY : ComputeRoot USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE SquareRootSolversModule , ONLY : SquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: ComputeExponential PUBLIC :: ComputeExponentialPade PUBLIC :: ComputeExponentialTaylor PUBLIC :: ComputeDenseExponential PUBLIC :: ComputeLogarithm PUBLIC :: ComputeLogarithmTaylor PUBLIC :: ComputeDenseLogarithm CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix. SUBROUTINE ComputeExponential ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params TYPE ( SolverParameters_t ) :: sub_params TYPE ( SolverParameters_t ) :: psub_params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool !! For Chebyshev Expansion TYPE ( ChebyshevPolynomial_t ) :: polynomial !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: counter !! Handle The Optional Parameters !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF CALL CopySolverParameters ( params , sub_params ) CALL CopySolverParameters ( params , psub_params ) psub_params % max_iterations = 10 IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Chebyshev\" ) CALL PrintParameters ( params ) END IF CALL ConstructEmptyMatrix ( OutputMat , InputMat ) !! Scale the matrix CALL PowerBounds ( InputMat , spectral_radius , psub_params ) sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) sub_params % threshold = sub_params % threshold / sigma_val IF ( params % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , VALUE = sigma_val ) END IF !! Expand Chebyshev Series CALL ConstructPolynomial ( polynomial , 16 ) CALL SetCoefficient ( polynomial , 1 , 1.266065877752007e+00_NTREAL ) CALL SetCoefficient ( polynomial , 2 , 1.130318207984970e+00_NTREAL ) CALL SetCoefficient ( polynomial , 3 , 2.714953395340771e-01_NTREAL ) CALL SetCoefficient ( polynomial , 4 , 4.433684984866504e-02_NTREAL ) CALL SetCoefficient ( polynomial , 5 , 5.474240442092110e-03_NTREAL ) CALL SetCoefficient ( polynomial , 6 , 5.429263119148932e-04_NTREAL ) CALL SetCoefficient ( polynomial , 7 , 4.497732295351912e-05_NTREAL ) CALL SetCoefficient ( polynomial , 8 , 3.198436462630565e-06_NTREAL ) CALL SetCoefficient ( polynomial , 9 , 1.992124801999838e-07_NTREAL ) CALL SetCoefficient ( polynomial , 10 , 1.103677287249654e-08_NTREAL ) CALL SetCoefficient ( polynomial , 11 , 5.505891628277851e-10_NTREAL ) CALL SetCoefficient ( polynomial , 12 , 2.498021534339559e-11_NTREAL ) CALL SetCoefficient ( polynomial , 13 , 1.038827668772902e-12_NTREAL ) CALL SetCoefficient ( polynomial , 14 , 4.032447357431817e-14_NTREAL ) CALL SetCoefficient ( polynomial , 15 , 2.127980007794583e-15_NTREAL ) CALL SetCoefficient ( polynomial , 16 , - 1.629151584468762e-16_NTREAL ) CALL Compute ( ScaledMat , OutputMat , polynomial , sub_params ) !! Undo the scaling by squaring at the end. IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF DO counter = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructPolynomial ( polynomial ) CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( params ) CALL DestructSolverParameters ( psub_params ) CALL DestructSolverParameters ( sub_params ) END SUBROUTINE ComputeExponential !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix using a pade approximation. !> Be warned, the pade method can result in a lot of intermediate fill. SUBROUTINE ComputeExponentialPade ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params TYPE ( SolverParameters_t ) :: sub_params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: IdentityMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: B1 , B2 , B3 TYPE ( Matrix_ps ) :: P1 , P2 TYPE ( Matrix_ps ) :: LeftMat , RightMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val INTEGER :: sigma_counter INTEGER :: II !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Pade\" ) CALL PrintParameters ( params ) END IF !! Setup CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Scale the matrix spectral_radius = MatrixNorm ( InputMat ) sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 1.0 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) IF ( params % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , VALUE = sigma_val ) CALL WriteElement ( key = \"Scaling Steps\" , VALUE = sigma_counter ) END IF !! Sub Solver Parameters CALL CopySolverParameters ( params , sub_params ) sub_params % threshold = sub_params % threshold / sigma_val !! Power Matrices CALL MatrixMultiply ( ScaledMat , ScaledMat , B1 , & & threshold_in = sub_params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( B1 , B1 , B2 , & & threshold_in = sub_params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( B2 , B2 , B3 , & & threshold_in = sub_params % threshold , memory_pool_in = pool ) !! Polynomials - 1 CALL CopyMatrix ( IdentityMat , P1 ) CALL ScaleMatrix ( P1 , 1729728 0.0_NTREAL ) CALL IncrementMatrix ( B1 , P1 , alpha_in = 199584 0.0_NTREAL ) CALL IncrementMatrix ( B2 , P1 , alpha_in = 2520 0.0_NTREAL ) CALL IncrementMatrix ( B3 , P1 , alpha_in = 5 6.0_NTREAL ) !! Polynomials - 2 CALL CopyMatrix ( IdentityMat , TempMat ) CALL ScaleMatrix ( TempMat , 864864 0.0_NTREAL ) CALL IncrementMatrix ( B1 , TempMat , alpha_in = 27720 0.0_NTREAL ) CALL IncrementMatrix ( B2 , TempMat , alpha_in = 151 2.0_NTREAL ) CALL IncrementMatrix ( B3 , TempMat ) CALL MatrixMultiply ( ScaledMat , TempMat , P2 , & & threshold_in = sub_params % threshold , memory_pool_in = pool ) !! Left and Right CALL CopyMatrix ( P1 , LeftMat ) CALL IncrementMatrix ( P2 , LeftMat , - 1.0_NTREAL ) CALL CopyMatrix ( P1 , RightMat ) CALL IncrementMatrix ( P2 , RightMat , 1.0_NTREAL ) CALL CGSolver ( LeftMat , OutputMat , RightMat , sub_params ) !! Undo the scaling by squaring at the end. DO II = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( B1 ) CALL DestructMatrix ( B2 ) CALL DestructMatrix ( B3 ) CALL DestructMatrix ( P1 ) CALL DestructMatrix ( P2 ) CALL DestructMatrix ( LeftMat ) CALL DestructMatrix ( RightMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) CALL DestructSolverParameters ( sub_params ) END SUBROUTINE ComputeExponentialPade !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the exponential of a matrix using a taylor series expansion. !> This is only really useful if you have a very small spectrum, because !> quite a bit of scaling is required. SUBROUTINE ComputeExponentialTaylor ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params TYPE ( SolverParameters_t ) :: psub_params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: TempMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables REAL ( NTREAL ) :: spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: II !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF CALL CopySolverParameters ( params , psub_params ) psub_params % max_iterations = 10 IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Taylor\" ) CALL PrintParameters ( params ) END IF !! Compute The Scaling Factor CALL PowerBounds ( InputMat , spectral_radius , psub_params ) !! Figure out how much to scale the matrix. sigma_val = 1.0 sigma_counter = 1 DO WHILE ( spectral_radius / sigma_val . GT . 3.0e-8 ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL CopyMatrix ( InputMat , ScaledMat ) CALL ScaleMatrix ( ScaledMat , 1.0 / sigma_val ) CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL FillMatrixIdentity ( OutputMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Expand Taylor Series taylor_denom = 1.0 CALL CopyMatrix ( OutputMat , Ak ) DO II = 1 , 10 taylor_denom = taylor_denom * II CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat ) END DO DO II = 1 , sigma_counter - 1 CALL MatrixMultiply ( OutputMat , OutputMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , OutputMat ) END DO IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrix ( TempMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) CALL DestructSolverParameters ( psub_params ) END SUBROUTINE ComputeExponentialTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE ComputeDenseExponential ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Exponential Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( InputMat , OutputMat , ExpLambda , params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE ComputeDenseExponential !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the logarithm of a matrix. SUBROUTINE ComputeLogarithm ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: IdentityMat !! For Chebyshev Expansion TYPE ( ChebyshevPolynomial_t ) :: polynomial !! Local Variables TYPE ( SolverParameters_t ) :: i_sub_params TYPE ( SolverParameters_t ) :: p_sub_params TYPE ( SolverParameters_t ) :: f_sub_params REAL ( NTREAL ) :: spectral_radius INTEGER :: sigma_val INTEGER :: sigma_counter !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF CALL CopySolverParameters ( params , i_sub_params ) CALL CopySolverParameters ( params , p_sub_params ) CALL CopySolverParameters ( params , f_sub_params ) p_sub_params % max_iterations = 16 IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Logarithm Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Chebyshev\" ) CALL PrintParameters ( params ) END IF !! Setup CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Copy to a temporary matrix for scaling. CALL CopyMatrix ( InputMat , ScaledMat ) !! Compute The Scaling Factor sigma_val = 1 sigma_counter = 1 CALL PowerBounds ( InputMat , spectral_radius , p_sub_params ) DO WHILE ( spectral_radius . GT . SQRT ( 2.0 )) spectral_radius = SQRT ( spectral_radius ) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO IF ( params % be_verbose ) THEN CALL WriteElement ( key = \"Sigma\" , VALUE = sigma_val ) END IF f_sub_params % threshold = & & f_sub_params % threshold / REAL ( 2 ** ( sigma_counter - 1 ), NTREAL ) CALL ComputeRoot ( InputMat , ScaledMat , sigma_val , i_sub_params ) !! Shift Scaled Matrix CALL IncrementMatrix ( IdentityMat , ScaledMat , alpha_in = - 1.0_NTREAL ) !! Expand Chebyshev Series CALL ConstructPolynomial ( polynomial , 32 ) CALL SetCoefficient ( polynomial , 1 , - 0.485101351704_NTREAL ) CALL SetCoefficient ( polynomial , 2 , 1.58828112379_NTREAL ) CALL SetCoefficient ( polynomial , 3 , - 0.600947731795_NTREAL ) CALL SetCoefficient ( polynomial , 4 , 0.287304748177_NTREAL ) CALL SetCoefficient ( polynomial , 5 , - 0.145496447103_NTREAL ) CALL SetCoefficient ( polynomial , 6 , 0.0734013668818_NTREAL ) CALL SetCoefficient ( polynomial , 7 , - 0.0356277942958_NTREAL ) CALL SetCoefficient ( polynomial , 8 , 0.0161605505166_NTREAL ) CALL SetCoefficient ( polynomial , 9 , - 0.0066133591188_NTREAL ) CALL SetCoefficient ( polynomial , 10 , 0.00229833505456_NTREAL ) CALL SetCoefficient ( polynomial , 11 , - 0.000577804103964_NTREAL ) CALL SetCoefficient ( polynomial , 12 , 2.2849332964e-05_NTREAL ) CALL SetCoefficient ( polynomial , 13 , 8.37426826403e-05_NTREAL ) CALL SetCoefficient ( polynomial , 14 , - 6.10822859027e-05_NTREAL ) CALL SetCoefficient ( polynomial , 15 , 2.58132364523e-05_NTREAL ) CALL SetCoefficient ( polynomial , 16 , - 5.87577322647e-06_NTREAL ) CALL SetCoefficient ( polynomial , 17 , - 8.56711062722e-07_NTREAL ) CALL SetCoefficient ( polynomial , 18 , 1.52066488969e-06_NTREAL ) CALL SetCoefficient ( polynomial , 19 , - 7.12760496253e-07_NTREAL ) CALL SetCoefficient ( polynomial , 20 , 1.23102245249e-07_NTREAL ) CALL SetCoefficient ( polynomial , 21 , 6.03168259043e-08_NTREAL ) CALL SetCoefficient ( polynomial , 22 , - 5.1865499826e-08_NTREAL ) CALL SetCoefficient ( polynomial , 23 , 1.43185107512e-08_NTREAL ) CALL SetCoefficient ( polynomial , 24 , 2.58449717089e-09_NTREAL ) CALL SetCoefficient ( polynomial , 25 , - 3.73189861771e-09_NTREAL ) CALL SetCoefficient ( polynomial , 26 , 1.18469334815e-09_NTREAL ) CALL SetCoefficient ( polynomial , 27 , 1.51569931066e-10_NTREAL ) CALL SetCoefficient ( polynomial , 28 , - 2.89595999673e-10_NTREAL ) CALL SetCoefficient ( polynomial , 29 , 1.26720668874e-10_NTREAL ) CALL SetCoefficient ( polynomial , 30 , - 3.00079067694e-11_NTREAL ) CALL SetCoefficient ( polynomial , 31 , 3.91175568865e-12_NTREAL ) CALL SetCoefficient ( polynomial , 32 , - 2.21155654398e-13_NTREAL ) CALL FactorizedCompute ( ScaledMat , OutputMat , polynomial , f_sub_params ) !! Scale Back CALL ScaleMatrix ( OutputMat , REAL ( 2 ** ( sigma_counter - 1 ), NTREAL )) !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructPolynomial ( polynomial ) CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( params ) CALL DestructSolverParameters ( i_sub_params ) CALL DestructSolverParameters ( f_sub_params ) CALL DestructSolverParameters ( p_sub_params ) END SUBROUTINE ComputeLogarithm !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the logarithm of a matrix using a taylor series expansion. SUBROUTINE ComputeLogarithmTaylor ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: ScaledMat TYPE ( Matrix_ps ) :: TempMat TYPE ( Matrix_ps ) :: Ak TYPE ( Matrix_ps ) :: IdentityMat TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables TYPE ( SolverParameters_t ) :: sub_params REAL ( NTREAL ) :: e_min , e_max , spectral_radius REAL ( NTREAL ) :: sigma_val REAL ( NTREAL ) :: taylor_denom INTEGER :: sigma_counter INTEGER :: II !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF CALL CopySolverParameters ( params , sub_params ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Logarithm Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Taylor\" ) CALL PrintParameters ( params ) END IF !! Compute The Scaling Factor CALL GershgorinBounds ( InputMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) !! Figure out how much to scale the matrix. sigma_val = 1.0 sigma_counter = 1 CALL CopyMatrix ( InputMat , ScaledMat ) DO WHILE ( spectral_radius / sigma_val . GT . 1.1e-7 ) CALL SquareRoot ( ScaledMat , TempMat , sub_params ) CALL CopyMatrix ( TempMat , ScaledMat ) CALL GershgorinBounds ( ScaledMat , e_min , e_max ) spectral_radius = MAX ( ABS ( e_min ), ABS ( e_max )) sigma_val = sigma_val * 2 sigma_counter = sigma_counter + 1 END DO CALL ConstructEmptyMatrix ( IdentityMat , InputMat ) CALL FillMatrixIdentity ( IdentityMat ) !! Setup Matrices CALL IncrementMatrix ( IdentityMat , ScaledMat , & & alpha_in = - 1.0_NTREAL ) CALL CopyMatrix ( IdentityMat , Ak ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( ScaledMat , ScaledMat , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( Ak , Ak , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Expand taylor series. CALL CopyMatrix ( ScaledMat , OutputMat ) DO II = 2 , 10 IF ( MOD ( II , 2 ) . EQ . 0 ) THEN taylor_denom = - 1 * II ELSE taylor_denom = II END IF CALL MatrixMultiply ( Ak , ScaledMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( TempMat , Ak ) CALL IncrementMatrix ( Ak , OutputMat , & & alpha_in = 1.0 / taylor_denom ) END DO !! Undo scaling. CALL ScaleMatrix ( OutputMat , REAL ( 2 ** sigma_counter , NTREAL )) !! Undo load params. IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( ScaledMat ) CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( IdentityMat ) CALL DestructMatrix ( Ak ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) CALL DestructSolverParameters ( sub_params ) END SUBROUTINE ComputeLogarithmTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE ComputeDenseLogarithm ( InputMat , OutputMat , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = exp(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Logarithm Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( InputMat , OutputMat , LogLambda , params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE ComputeDenseLogarithm !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical exponential for mapping. FUNCTION ExpLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = EXP ( val ) END FUNCTION ExpLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical exponential for mapping. FUNCTION LogLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = LOG ( val ) END FUNCTION LogLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ExponentialSolversModule","tags":"","loc":"sourcefile/exponentialsolversmodule.f90.html"},{"title":"PermutationModule.F90 – NTPoly","text":"Contents Modules PermutationModule Source Code PermutationModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Module for load balancing the matrix multiplication calculation. MODULE PermutationModule USE DataTypesModule , ONLY : NTREAL USE ProcessGridModule , ONLY : global_grid , ProcessGrid_t USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data structure for storing permutations. TYPE , PUBLIC :: Permutation_t !> For each row/column, what index does it correspond to in the !> unperturbed matrix. INTEGER , DIMENSION (:), ALLOCATABLE :: index_lookup !> For each row/column in the unperturbed, what index does it correspond to !> in this matrix. INTEGER , DIMENSION (:), ALLOCATABLE :: reverse_index_lookup END TYPE Permutation_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructDefaultPermutation PUBLIC :: ConstructReversePermutation PUBLIC :: ConstructRandomPermutation PUBLIC :: ConstructLimitedRandomPermutation PUBLIC :: CopyPermutation PUBLIC :: DestructPermutation CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that preserves the original order. SUBROUTINE ConstructDefaultPermutation ( this , matrix_dimension ) !> The permutation to construct. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The dimension of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !! Local Data INTEGER :: II CALL DestructPermutation ( this ) ALLOCATE ( this % index_lookup ( matrix_dimension )) ALLOCATE ( this % reverse_index_lookup ( matrix_dimension )) !! Fill by counting. fill : DO II = 1 , matrix_dimension this % index_lookup ( II ) = II this % reverse_index_lookup ( II ) = II END DO fill END SUBROUTINE ConstructDefaultPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that reverses the original order. SUBROUTINE ConstructReversePermutation ( this , matrix_dimension ) !> A permutation that reverses the original order. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The size of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !! Local Data INTEGER :: II CALL DestructPermutation ( this ) ALLOCATE ( this % index_lookup ( matrix_dimension )) ALLOCATE ( this % reverse_index_lookup ( matrix_dimension )) !! Fill by counting. fill : DO II = 1 , matrix_dimension this % index_lookup ( II ) = matrix_dimension - II + 1 this % reverse_index_lookup ( II ) = II END DO fill END SUBROUTINE ConstructReversePermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that has a random order. !> Implements Knuth shuffle. SUBROUTINE ConstructRandomPermutation ( this , matrix_dimension , & & process_grid_in ) !> A permutation that reverses the original order. TYPE ( Permutation_t ), INTENT ( INOUT ) :: this !> The size of the matrix. INTEGER , INTENT ( IN ) :: matrix_dimension !> A permutation should be shared amongst these processes. !> This is to synchronize random number across processes. TYPE ( ProcessGrid_t ), INTENT ( INOUT ), OPTIONAL :: process_grid_in !! Local Data INTEGER :: II INTEGER :: random_integer REAL ( KIND = NTREAL ) :: rand_temp INTEGER :: swap_space INTEGER :: ierr !! First fill by counting. CALL ConstructDefaultPermutation ( this , matrix_dimension ) !! Do the shuffle shuffle : DO II = matrix_dimension , 1 , - 1 CALL RANDOM_NUMBER ( rand_temp ) random_integer = FLOOR ( matrix_dimension * rand_temp ) + 1 swap_space = this % index_lookup ( matrix_dimension ) this % index_lookup ( matrix_dimension ) = this % index_lookup ( random_integer ) this % index_lookup ( random_integer ) = swap_space END DO shuffle !! Broadcast the lookup (so each process has the same value) IF ( PRESENT ( process_grid_in )) THEN CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , process_grid_in % global_comm , ierr ) ELSE CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , global_grid % global_comm , ierr ) END IF !! Compute the reverse lookup reverse : DO II = 1 , matrix_dimension this % reverse_index_lookup ( this % index_lookup ( II )) = II END DO reverse END SUBROUTINE ConstructRandomPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Constructs a permutation that has a random order, but there is no !> permutation from beyond the actual matrix dimension. SUBROUTINE ConstructLimitedRandomPermutation ( this , actual_matrix_dimension , & & logical_matrix_dimension , process_grid_in ) !> The permutation to construct. TYPE ( Permutation_t ), INTENT ( inout ) :: this !> Actual size of the matrix. INTEGER , INTENT ( IN ) :: actual_matrix_dimension !> Padded size of the matrix. INTEGER , INTENT ( IN ) :: logical_matrix_dimension !> A permutation should be shared amongst these processes. !> This is to synchronize random number across processes. TYPE ( ProcessGrid_t ), INTENT ( INOUT ), OPTIONAL :: process_grid_in !! Local Data INTEGER :: II INTEGER :: random_integer REAL ( KIND = NTREAL ) :: rand_temp INTEGER :: swap_space INTEGER :: ierr !! First fill by counting. CALL ConstructDefaultPermutation ( this , logical_matrix_dimension ) !! Do the shuffle shuffle : DO II = actual_matrix_dimension , 1 , - 1 CALL RANDOM_NUMBER ( rand_temp ) random_integer = FLOOR ( actual_matrix_dimension * rand_temp ) + 1 swap_space = this % index_lookup ( actual_matrix_dimension ) this % index_lookup ( actual_matrix_dimension ) = & & this % index_lookup ( random_integer ) this % index_lookup ( random_integer ) = swap_space END DO shuffle !! Broadcast the lookup (so each process has the same value) IF ( PRESENT ( process_grid_in )) THEN CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , process_grid_in % global_comm , ierr ) ELSE CALL MPI_Bcast ( this % index_lookup , SIZE ( this % index_lookup ), & & MPI_INTEGER , 0 , global_grid % global_comm , ierr ) END IF !! Compute the reverse lookup reverse : DO II = 1 , logical_matrix_dimension this % reverse_index_lookup ( this % index_lookup ( II )) = II END DO reverse END SUBROUTINE ConstructLimitedRandomPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy one permutation to another in a safe way. SUBROUTINE CopyPermutation ( permA , permB ) !> Permutation to copy TYPE ( Permutation_t ), INTENT ( IN ) :: permA !> permB = permA TYPE ( Permutation_t ), INTENT ( INOUT ) :: permB CALL DestructPermutation ( permB ) permB = permA END SUBROUTINE CopyPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a permutation object. PURE SUBROUTINE DestructPermutation ( this ) !> The permutation to destruct. TYPE ( Permutation_t ), INTENT ( inout ) :: this IF ( ALLOCATED ( this % index_lookup )) THEN DEALLOCATE ( this % index_lookup ) END IF IF ( ALLOCATED ( this % reverse_index_lookup )) THEN DEALLOCATE ( this % reverse_index_lookup ) END IF END SUBROUTINE DestructPermutation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PermutationModule","tags":"","loc":"sourcefile/permutationmodule.f90.html"},{"title":"LinearSolversModule.F90 – NTPoly","text":"Contents Modules LinearSolversModule Source Code LinearSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Solve the matrix equation AX = B MODULE LinearSolversModule USE CholeskyModule , ONLY : ConstructRankLookup , AppendToVector , & & BroadcastVector , ConstructDiag , DotAllHelper , DotAllPivoted , & & GatherMatrixColumn , GetPivot , UnpackCholesky USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE DMatrixModule , ONLY : Matrix_ldr , DestructMatrix , & & ConstructMatrixDFromS USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader , WriteListElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixNorm , & & MatrixMultiply , MatrixTrace , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & TransposeMatrix , DestructMatrix , ConjugateMatrix , CopyMatrix , & & FillMatrixIdentity , PrintMatrixInformation , MergeMatrixLocalBlocks USE SMatrixModule , ONLY : Matrix_lsr USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE NTMPIMODULE IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: CGSolver PUBLIC :: CholeskyDecomposition CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Solve the matrix equation AX = B using the conjugate gradient method. SUBROUTINE CGSolver ( AMat , XMat , BMat , solver_parameters_in ) !> The matrix A, must be hermitian, positive definite. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The solved for matrix X. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: XMat !> The right hand side. TYPE ( Matrix_ps ), INTENT ( IN ) :: BMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: ABalanced TYPE ( Matrix_ps ) :: BBalanced TYPE ( Matrix_ps ) :: RMat , PMat , QMat TYPE ( Matrix_ps ) :: RMatT , PMatT TYPE ( Matrix_ps ) :: TempMat !! Temporary Variables INTEGER :: II REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool REAL ( NTREAL ) :: top , bottom , new_top , step_size !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Print out parameters IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Linear Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"CG\" ) CALL PrintParameters ( params ) END IF !! Setup all the matrices CALL ConstructEmptyMatrix ( Identity , AMat ) CALL FillMatrixIdentity ( Identity ) CALL ConstructEmptyMatrix ( ABalanced , AMat ) CALL ConstructEmptyMatrix ( BBalanced , AMat ) CALL ConstructEmptyMatrix ( RMat , AMat ) CALL ConstructEmptyMatrix ( PMat , AMat ) CALL ConstructEmptyMatrix ( QMat , AMat ) CALL ConstructEmptyMatrix ( TempMat , AMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( AMat , ABalanced , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BMat , BBalanced , & & params % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( AMat , ABalanced ) CALL CopyMatrix ( BMat , BBalanced ) END IF !! Initial Matrix Values CALL CopyMatrix ( Identity , XMat ) !! Compute residual CALL MatrixMultiply ( ABalanced , Xmat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( BBalanced , RMat ) CALL IncrementMatrix ( TempMat , RMat , - 1.0_NTREAL ) CALL CopyMatrix ( RMat , PMat ) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations IF ( params % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF !! Compute the Step Size CALL MatrixMultiply ( ABalanced , PMat , QMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL TransposeMatrix ( RMat , RMatT ) IF ( RMatT % is_complex ) THEN CALL ConjugateMatrix ( RMatT ) END IF CALL MatrixMultiply ( RMatT , RMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , top ) CALL TransposeMatrix ( PMat , PMatT ) IF ( PMatT % is_complex ) THEN CALL ConjugateMatrix ( PMatT ) END IF CALL MatrixMultiply ( PMatT , QMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , bottom ) step_size = top / bottom !! Update CALL IncrementMatrix ( PMat , XMat , alpha_in = step_size ) norm_value = ABS ( step_size * MatrixNorm ( PMat )) CALL IncrementMatrix ( QMat , RMat , alpha_in = - 1.0_NTREAL * step_size ) !! Update PMat CALL TransposeMatrix ( RMat , RMatT ) IF ( RMatT % is_complex ) THEN CALL ConjugateMatrix ( RMatT ) END IF CALL MatrixMultiply ( RMatT , RMat , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixTrace ( TempMat , new_top ) step_size = new_top / top CALL ScaleMatrix ( PMat , step_size ) CALL IncrementMatrix ( RMat , PMat ) END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) CALL PrintMatrixInformation ( XMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( XMat , XMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( TempMat ) CALL DestructMatrix ( RMat ) CALL DestructMatrix ( PMat ) CALL DestructMatrix ( QMat ) CALL DestructMatrix ( Identity ) CALL DestructMatrix ( ABalanced ) CALL DestructMatrix ( BBalanced ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE CGSolver !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Cholesky Decomposition of a Hermitian Positive Definite matrix. !> This is a really naive implementation, that might be worth revisiting. SUBROUTINE CholeskyDecomposition ( AMat , LMat , solver_parameters_in ) !> The matrix A, must be hermitian, positive definite. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The lower diagonal matrix computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: LMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_lsr ) :: sparse_a TYPE ( Matrix_ldr ) :: dense_a INTEGER , DIMENSION (:), ALLOCATABLE :: values_per_column_l INTEGER , DIMENSION (:,:), ALLOCATABLE :: index_l REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: values_l !! Temporary Variables INTEGER , DIMENSION (:), ALLOCATABLE :: recv_index REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_values INTEGER :: recv_num_values INTEGER :: II , JJ , local_JJ , local_II , local_row REAL ( NTREAL ) :: Aval , insert_value , inverse_factor REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: dot_values INTEGER , DIMENSION (:), ALLOCATABLE :: col_root_lookup INTEGER :: col_root INTEGER :: ierr !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Print out parameters IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Linear Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Cholesky Decomposition\" ) CALL PrintParameters ( params ) END IF CALL ConstructEmptyMatrix ( LMat , AMat ) !! First get the local matrix in a dense recommendation for quick lookup CALL MergeMatrixLocalBlocks ( AMat , sparse_a ) CALL ConstructMatrixDFromS ( sparse_a , dense_a ) !! Root Lookups ALLOCATE ( col_root_lookup ( AMat % logical_matrix_dimension )) CALL ConstructRankLookup ( AMat , LMat % process_grid , & & col_root_lookup = col_root_lookup ) !! Allocate space for L ALLOCATE ( values_per_column_l ( sparse_a % columns )) ALLOCATE ( index_l ( sparse_a % rows , sparse_a % columns )) ALLOCATE ( values_l ( sparse_a % rows , sparse_a % columns )) values_per_column_l = 0 !! Allocate space for a received column ALLOCATE ( recv_index ( sparse_a % rows )) ALLOCATE ( recv_values ( sparse_a % rows )) ALLOCATE ( dot_values ( sparse_a % columns )) !! Main Loop DO JJ = 1 , AMat % actual_matrix_dimension !! Dot Column JJ with Column JJ, Insert Value into L[J,J] inverse_factor = 0 IF ( JJ . GE . AMat % start_column . AND . JJ . LT . AMat % end_column ) THEN local_JJ = JJ - AMat % start_column + 1 CALL DotAllHelper ( values_per_column_l ( local_JJ ), & & index_l (:, local_JJ ), values_l (:, local_JJ ), & & values_per_column_l ( local_JJ : local_JJ ), & & index_l (:, local_JJ : local_JJ ), values_l (:, local_JJ : local_JJ ), & & dot_values ( 1 : 1 ), LMat % process_grid % column_comm ) IF ( JJ . GE . AMat % start_row . AND . JJ . LT . AMat % end_row ) THEN local_row = JJ - AMat % start_row + 1 Aval = dense_a % DATA ( local_row , local_JJ ) insert_value = SQRT ( Aval - dot_values ( 1 )) inverse_factor = 1.0_NTREAL / insert_value !! Insert CALL AppendToVector ( values_per_column_l ( local_JJ ), & & index_l (:, local_JJ ), values_l (:, local_JJ ), local_row , & & insert_value ) END IF !! Extract column J for sending later recv_num_values = values_per_column_l ( local_JJ ) recv_index (: recv_num_values ) = index_l (: recv_num_values , local_JJ ) recv_values (: recv_num_values ) = values_l (: recv_num_values , local_JJ ) END IF col_root = col_root_lookup ( JJ ) !! Broadcast column JJ, and Inverse Factor CALL BroadcastVector ( recv_num_values , recv_index , recv_values , & & col_root , LMat % process_grid % row_comm ) CALL MPI_Allreduce ( MPI_IN_PLACE , inverse_factor , 1 , MPINTREAL , & & MPI_SUM , LMat % process_grid % within_slice_comm , ierr ) !! Loop over other columns CALL DotAllHelper ( recv_num_values , recv_index , recv_values , & & values_per_column_l , index_l , values_l , dot_values , & & LMat % process_grid % column_comm ) IF ( JJ . GE . AMat % start_row . AND . JJ . LT . AMat % end_row ) THEN DO II = MAX ( JJ + 1 , AMat % start_column ), AMat % end_column - 1 local_II = II - AMat % start_column + 1 local_row = JJ - AMat % start_row + 1 Aval = dense_a % DATA ( local_row , local_II ) insert_value = inverse_factor * ( Aval - dot_values ( local_II )) IF ( ABS ( insert_value ) . GT . params % threshold ) THEN CALL AppendToVector ( values_per_column_l ( local_II ), & & index_l (:, local_II ), values_l (:, local_II ), & & local_row , insert_value ) END IF END DO END IF END DO !! Unpack CALL UnpackCholesky ( values_per_column_l , index_l , values_l , LMat ) !! Cleanup IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( LMat ) CALL ExitSubLog END IF CALL DestructMatrix ( dense_a ) DEALLOCATE ( values_per_column_l ) DEALLOCATE ( index_l ) DEALLOCATE ( values_l ) DEALLOCATE ( recv_index ) DEALLOCATE ( recv_values ) DEALLOCATE ( dot_values ) DEALLOCATE ( col_root_lookup ) CALL DestructMatrix ( sparse_a ) CALL DestructSolverParameters ( params ) END SUBROUTINE CholeskyDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LinearSolversModule","tags":"","loc":"sourcefile/linearsolversmodule.f90.html"},{"title":"HermiteSolversModule.F90 – NTPoly","text":"Contents Modules HermiteSolversModule Source Code HermiteSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing matrix functions based on Hermite polynomials. !! The Physicist variety. MODULE HermiteSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a Hermite polynomial. TYPE , PUBLIC :: HermitePolynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE HermitePolynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_horner END INTERFACE ConstructPolynomial INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_horner END INTERFACE DestructPolynomial INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_horner END INTERFACE SetCoefficient INTERFACE Compute MODULE PROCEDURE Compute_horner END INTERFACE Compute CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a Hermite polynomial object. PURE SUBROUTINE ConstructPolynomial_horner ( this , degree ) !> The polynomial to construct. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this !> The degree of the polynomial. INTEGER , INTENT ( in ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0.0_NTREAL END SUBROUTINE ConstructPolynomial_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a Hermite polynomial object. PURE SUBROUTINE DestructPolynomial_horner ( this ) !> The polynomial to destruct. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set a coefficient of a Hermite polynomial. SUBROUTINE SetCoefficient_horner ( this , degree , coefficient ) !> The polynomial to set. TYPE ( HermitePolynomial_t ), INTENT ( inout ) :: this !> The degree for which to set the coefficient. INTEGER , INTENT ( in ) :: degree !> Coefficient value to set. REAL ( NTREAL ), INTENT ( in ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute The Hermite Polynomial of the matrix. !> This method uses the standard Hermite Polynomial expansion. SUBROUTINE Compute_horner ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( in ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( inout ) :: OutputMat !> Polynomial to compute. TYPE ( HermitePolynomial_t ), INTENT ( in ) :: poly !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( in ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Hk TYPE ( Matrix_ps ) :: Hkminus1 TYPE ( Matrix_ps ) :: Hkplus1 TYPE ( Matrix_ps ) :: Hkprime TYPE ( MatrixMemoryPool_p ) :: pool !! Local Variables INTEGER :: degree INTEGER :: II !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF degree = SIZE ( poly % coefficients ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Hermite Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Standard\" ) CALL WriteElement ( key = \"Degree\" , VALUE = degree - 1 ) CALL PrintParameters ( params ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Recursive expansion CALL CopyMatrix ( Identity , Hkminus1 ) CALL CopyMatrix ( Hkminus1 , OutputMat ) CALL ScaleMatrix ( OutputMat , poly % coefficients ( 1 )) IF ( degree . GT . 1 ) THEN CALL CopyMatrix ( BalancedInput , Hk ) CALL ScaleMatrix ( Hk , 2.0_NTREAL ) CALL IncrementMatrix ( Hk , OutputMat , & & alpha_in = poly % coefficients ( 2 )) IF ( degree . GT . 2 ) THEN CALL CopyMatrix ( Hkminus1 , Hkprime ) CALL ScaleMatrix ( Hkprime , 2.0_NTREAL ) DO II = 3 , degree CALL MatrixMultiply ( BalancedInput , Hk , Hkplus1 , & & alpha_in = 2.0_NTREAL , threshold_in = params % threshold , & & memory_pool_in = pool ) CALL IncrementMatrix ( Hkprime , Hkplus1 , & & alpha_in = - 1.0_NTREAL ) CALL CopyMatrix ( Hk , Hkprime ) CALL ScaleMatrix ( Hkprime , REAL ( 2 * ( II - 1 ), KIND = NTREAL )) CALL CopyMatrix ( Hk , Hkminus1 ) CALL CopyMatrix ( Hkplus1 , Hk ) CALL IncrementMatrix ( Hk , OutputMat , & & alpha_in = poly % coefficients ( II )) END DO END IF END IF IF ( params % be_verbose ) THEN CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Identity ) CALL DestructMatrix ( Hk ) CALL DestructMatrix ( Hkminus1 ) CALL DestructMatrix ( Hkplus1 ) CALL DestructMatrix ( Hkprime ) CALL DestructMatrix ( BalancedInput ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE Compute_horner !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE HermiteSolversModule","tags":"","loc":"sourcefile/hermitesolversmodule.f90.html"},{"title":"CholeskySolversModule.F90 – NTPoly","text":"Contents Modules CholeskyModule Source Code CholeskySolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Helper Routines for Computing The Cholesky Decomposition MODULE CholeskyModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , MPINTINTEGER USE DMatrixModule , ONLY : Matrix_ldr USE MatrixReduceModule , ONLY : ReduceHelper_t , ReduceAndComposeMatrix USE PSMatrixModule , ONLY : Matrix_ps , FillMatrixFromTripletList USE ProcessGridModule , ONLY : ProcessGrid_t USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , TransposeMatrix , & & DestructMatrix USE SVectorModule , ONLY : DotSparseVectors USE TripletListModule , ONLY : TripletList_r , AppendToTripletList , & & DestructTripletList , ConstructTripletList USE TripletModule , ONLY : Triplet_r USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: AppendToVector PUBLIC :: BroadcastVector PUBLIC :: ConstructDiag PUBLIC :: ConstructRankLookup PUBLIC :: DotAllHelper PUBLIC :: DotAllPivoted PUBLIC :: GatherMatrixColumn PUBLIC :: GetPivot PUBLIC :: UnpackCholesky !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE AppendToVector MODULE PROCEDURE AppendToVector_r END INTERFACE AppendToVector INTERFACE BroadcastVector MODULE PROCEDURE BroadcastVector_r END INTERFACE BroadcastVector INTERFACE ConstructDiag MODULE PROCEDURE ConstructDiag_r END INTERFACE ConstructDiag INTERFACE DotAllHelper MODULE PROCEDURE DotAllHelper_r END INTERFACE DotAllHelper INTERFACE DotAllPivoted MODULE PROCEDURE DotAllPivoted_r END INTERFACE DotAllPivoted INTERFACE GatherMatrixColumn MODULE PROCEDURE GatherMatrixColumn_r END INTERFACE GatherMatrixColumn INTERFACE GetPivot MODULE PROCEDURE GetPivot_r END INTERFACE GetPivot INTERFACE UnpackCholesky MODULE PROCEDURE UnpackCholesky_r END INTERFACE UnpackCholesky CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A helper routine to insert a value into a sparse vector. PURE SUBROUTINE AppendToVector_r ( values_per , indices , values , insert_row , & & insert_value ) !> Values per row. INTEGER , INTENT ( INOUT ) :: values_per !> Indices associated with each value. INTEGER , DIMENSION (:), INTENT ( INOUT ) :: indices !> Values. REAL ( NTREAL ), DIMENSION (:), INTENT ( INOUT ) :: values !> Row to insert into. INTEGER , INTENT ( IN ) :: insert_row !> Value to insert. REAL ( NTREAL ), INTENT ( IN ) :: insert_value #include \"solver_includes/AppendToVector.f90\" END SUBROUTINE AppendToVector_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A helper routine to broadcast a sparse vector SUBROUTINE BroadcastVector_r ( num_values , indices , values , root , comm ) !> Number of values we are broadcasting. INTEGER , INTENT ( INOUT ) :: num_values !> Indices to broadcast. INTEGER , DIMENSION (:), INTENT ( INOUT ) :: indices !> Values to broadcast. REAL ( NTREAL ), DIMENSION (:), INTENT ( INOUT ) :: values !> Root from which we broadcast. INTEGER , INTENT ( IN ) :: root !> Communicator to broadcast along. INTEGER , INTENT ( INOUT ) :: comm !! Local INTEGER :: err #include \"solver_includes/BroadcastVector.f90\" CALL MPI_Bcast ( values (: num_values ), num_values , MPINTREAL , root , comm , err ) END SUBROUTINE BroadcastVector_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct the vector holding the accumulated diagonal values SUBROUTINE ConstructDiag_r ( AMat , process_grid , dense_a , diag ) !> AMat the matrix we are working on (for meta data). TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The process grid we are operating on. TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: process_grid !> A dense representation of the values. TYPE ( Matrix_ldr ), INTENT ( IN ) :: dense_a !> Diagonal values computed. REAL ( NTREAL ), DIMENSION (:), INTENT ( INOUT ) :: diag #include \"solver_includes/ConstructDiag.f90\" CALL MPI_Allgatherv ( MPI_IN_PLACE , diags_per_proc ( process_grid % my_row + 1 ), & & MPINTREAL , diag , diags_per_proc , diag_displ , MPINTREAL , & & process_grid % column_comm , ierr ) END SUBROUTINE ConstructDiag_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a lookup for columns SUBROUTINE ConstructRankLookup ( AMat , process_grid , col_root_lookup ) !> Matrix we are computing. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> Grid we are computing along. TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: process_grid !> The lookup we are computing. INTEGER , DIMENSION (:), INTENT ( INOUT ) :: col_root_lookup !! Local Variables INTEGER , DIMENSION ( process_grid % num_process_columns ) :: cols_per_proc INTEGER , DIMENSION ( process_grid % num_process_columns ) :: d_cols_per_proc INTEGER :: II INTEGER :: ierr cols_per_proc ( process_grid % my_column + 1 ) = AMat % local_columns CALL MPI_Allgather ( MPI_IN_PLACE , 1 , MPI_INTEGER , cols_per_proc , 1 , & & MPI_INTEGER , process_grid % row_comm , ierr ) d_cols_per_proc ( 1 ) = 0 DO II = 2 , process_grid % num_process_columns d_cols_per_proc ( II ) = d_cols_per_proc ( II - 1 ) + cols_per_proc ( II - 1 ) END DO col_root_lookup ( AMat % start_column : AMat % end_column - 1 ) = & & process_grid % row_rank CALL MPI_Allgatherv ( MPI_IN_PLACE , AMat % local_columns , MPI_INTEGER , & & col_root_lookup , cols_per_proc , d_cols_per_proc , MPI_INTEGER , & & process_grid % row_comm , ierr ) END SUBROUTINE ConstructRankLookup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Helper routine which computes sparse dot products across processors. !> Computes the dot product of one vector with several others. SUBROUTINE DotAllHelper_r ( num_values_i , indices_i , values_i , num_values_j , & & indices_j , values_j , out_values , comm ) !> The length of vector i. INTEGER , INTENT ( IN ) :: num_values_i !> Tn array with the length of vectors j. INTEGER , DIMENSION (:), INTENT ( IN ) :: num_values_j !> The index value of the sparse vector i. INTEGER , DIMENSION (:), INTENT ( IN ) :: indices_i !> The indices of the vectors j. INTEGER , DIMENSION (:,:), INTENT ( IN ) :: indices_j !> The values of the sparse vector i. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_i !> The values of the vectors j. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( IN ) :: values_j !> The dot product values for each vector j. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: out_values !> The communicator to reduce along. INTEGER , INTENT ( INOUT ) :: comm #include \"solver_includes/DotAllHelper.f90\" END SUBROUTINE DotAllHelper_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Helper routine which computes sparse dot products across processors. !> Computes the dot product of one vector with several others. !> The pivoted version has the number of local pivots to work on as a !> parameter. SUBROUTINE DotAllPivoted_r ( num_values_i , indices_i , values_i , num_values_j , & & indices_j , values_j , pivot_vector , num_local_pivots , out_values , comm ) !> The length of vector i. INTEGER , INTENT ( IN ) :: num_values_i !> Tn array with the length of vectors j. INTEGER , DIMENSION (:), INTENT ( IN ) :: num_values_j !> The index value of the sparse vector i. INTEGER , DIMENSION (:), INTENT ( IN ) :: indices_i !> The indices of the vectors j. INTEGER , DIMENSION (:,:), INTENT ( IN ) :: indices_j !> The values of the sparse vector i. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_i !> The values of the vectors j. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( IN ) :: values_j !> Vector storing the pivot values. INTEGER , DIMENSION (:), INTENT ( IN ) :: pivot_vector !> Number of pivots. INTEGER , INTENT ( IN ) :: num_local_pivots !> The dot product values for each vector j. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: out_values !> The communicator to reduce along. INTEGER , INTENT ( INOUT ) :: comm #include \"solver_includes/DotAllPivoted.f90\" END SUBROUTINE DotAllPivoted_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A helper routine that gathers the matrices in the same column into one. SUBROUTINE GatherMatrixColumn_r ( local_matrix , column_matrix , process_grid ) !> The local matrix on each process. TYPE ( Matrix_lsr ), INTENT ( IN ) :: local_matrix !> The final result. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: column_matrix !> The process grid to operate on. TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: process_grid !! Local Variables TYPE ( Matrix_lsr ) :: local_matrixT #include \"solver_includes/GatherMatrixColumn.f90\" END SUBROUTINE GatherMatrixColumn_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the pivot vector. SUBROUTINE GetPivot_r ( AMat , process_grid , start_index , pivot_vector , diag , & & index , VALUE , local_pivots , num_local_pivots ) !> The matrix we are working on. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> The process grid to compute on. TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: process_grid !> The current pivot vector. INTEGER , DIMENSION (:), INTENT ( INOUT ) :: pivot_vector !> The diagonal values. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: diag !> The start index to look INTEGER , INTENT ( IN ) :: start_index !> The pivot index selected. INTEGER , INTENT ( OUT ) :: index !> The pivot value. REAL ( NTREAL ), INTENT ( OUT ) :: VALUE !> The local pivot values to modify. INTEGER , DIMENSION (:), INTENT ( INOUT ) :: local_pivots !> Number of pivots stored locally. INTEGER , INTENT ( OUT ) :: num_local_pivots !! Local Variables REAL ( NTREAL ) :: temp_diag REAL ( NTREAL ), DIMENSION ( 2 ) :: max_diag #include \"solver_includes/GetPivot.f90\" END SUBROUTINE GetPivot_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Unpack to a global matrix. SUBROUTINE UnpackCholesky_r ( values_per_column , index , values , LMat ) !> The number of values in a column. INTEGER , DIMENSION (:), INTENT ( IN ) :: values_per_column !> Index values. INTEGER , DIMENSION (:,:), INTENT ( IN ) :: index !> Actual values. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( IN ) :: values !> Matrix to unpack into. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: LMat #include \"solver_includes/UnpackCholesky.f90\" END SUBROUTINE UnpackCholesky_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE CholeskyModule","tags":"","loc":"sourcefile/choleskysolversmodule.f90.html"},{"title":"EigenSolversModule.F90 – NTPoly","text":"Contents Modules EigenSolversModule Source Code EigenSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing the eigenvalues of a matrix. MODULE EigenSolversModule USE DataTypesModule , ONLY : NTREAL USE DMatrixModule , ONLY : Matrix_ldr , Matrix_ldc , ConstructMatrixDFromS , & & ConstructMatrixSFromD , DestructMatrix #if EIGENEXA USE EigenExaModule , ONLY : EigenExa_s #endif USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , WriteElement USE PSMatrixAlgebraModule , ONLY : MatrixMultiply USE PSMatrixModule , ONLY : Matrix_ps , GatherMatrixToProcess , & & FillMatrixFromTripletList , ConstructEmptyMatrix , ConvertMatrixToReal , & & DestructMatrix , CopyMatrix , GetMatrixTripletList , TransposeMatrix , & & ConjugateMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , MatrixToTripletList , & & DestructMatrix USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & ConstructTripletList , DestructTripletList USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: EigenDecomposition PUBLIC :: DenseMatrixFunction CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigendecomposition of a matrix. !! Uses a dense routine. SUBROUTINE EigenDecomposition ( this , eigenvalues , eigenvectors_in , nvals_in , & & solver_parameters_in ) !> The matrix to decompose. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Diagonal matrix of eigenvalues. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> The eigenvectors of a matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !> The number of desired eigenvalues. INTEGER , INTENT ( IN ), OPTIONAL :: nvals_in !> Parameters for computing TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! For Handling Optional Parameters TYPE ( SolverParameters_t ) :: params INTEGER :: nvals !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( PRESENT ( nvals_in )) THEN nvals = nvals_in ELSE nvals = this % actual_matrix_dimension END IF #if EIGENEXA IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenExa_s ( this , eigenvalues , nvals , eigenvectors_in , & & solver_parameters_in = params ) ELSE CALL EigenExa_s ( this , eigenvalues , nvals , & & solver_parameters_in = params ) END IF #else IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenSerial ( this , eigenvalues , nvals , params , eigenvectors_in ) ELSE CALL EigenSerial ( this , eigenvalues , nvals , params ) END IF #endif !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE EigenDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Apply an arbitrary matrix function defined by a matrix map as a !! transformation of the eigenvalues. SUBROUTINE DenseMatrixFunction ( this , ResultMat , func , solver_parameters_in ) !> The matrix to apply the function to. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The transformed matrix TYPE ( Matrix_ps ), INTENT ( INOUT ) :: ResultMat INTERFACE !> The procedure to apply to each eigenvalue. FUNCTION func ( val ) RESULT ( outval ) USE DataTypesModule , ONLY : NTREAL !> The actual value of an element. REAL ( KIND = NTREAL ), INTENT ( IN ) :: val !> The transformed value. REAL ( KIND = NTREAL ) :: outval END FUNCTION func END INTERFACE !> Parameters for computing TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! For Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: vecs , vecsT , vals , temp TYPE ( TripletList_r ) :: tlist INTEGER :: II !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Perform the eigendecomposition CALL EigenDecomposition ( this , vals , solver_parameters_in = params , & & eigenvectors_in = vecs ) !! Convert to a triplet list, map the triplet list, fill. CALL GetMatrixTripletList ( vals , tlist ) DO II = 1 , tlist % CurrentSize tlist % DATA ( II )% point_value = func ( tlist % DATA ( II )% point_value ) END DO !! Fill CALL ConstructEmptyMatrix ( ResultMat , this ) CALL FillMatrixFromTripletList ( ResultMat , tlist , preduplicated_in = . TRUE .) !! Multiply Back Together CALL MatrixMultiply ( vecs , ResultMat , temp , threshold_in = params % threshold ) CALL TransposeMatrix ( vecs , vecsT ) CALL ConjugateMatrix ( vecsT ) CALL MatrixMultiply ( temp , vecsT , ResultMat , threshold_in = params % threshold ) !! Cleanup CALL DestructMatrix ( vecs ) CALL DestructMatrix ( temp ) CALL DestructMatrix ( vals ) CALL DestructTripletList ( tlist ) CALL DestructSolverParameters ( params ) END SUBROUTINE DenseMatrixFunction !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The base case: use lapack to solve. SUBROUTINE EigenSerial ( this , eigenvalues , nvals , solver_params , & & eigenvectors_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The eigenvalues of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> The number of vals to compute. INTEGER , INTENT ( IN ) :: nvals !> The solve parameters. TYPE ( SolverParameters_t ), INTENT ( IN ) :: solver_params !> The eigenvectors of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !! Write info about the solver IF ( solver_params % be_verbose ) THEN CALL WriteHeader ( \"Eigen Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"LAPACK\" ) CALL WriteElement ( key = \"NVALS\" , VALUE = nvals ) CALL ExitSubLog CALL PrintParameters ( solver_params ) END IF IF ( this % is_complex ) THEN IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenSerial_c ( this , eigenvalues , nvals , & & solver_params % threshold , eigenvectors_in ) ELSE CALL EigenSerial_c ( this , eigenvalues , nvals , & & solver_params % threshold ) END IF ELSE IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenSerial_r ( this , eigenvalues , nvals , & & solver_params % threshold , eigenvectors_in ) ELSE CALL EigenSerial_r ( this , eigenvalues , nvals , & & solver_params % threshold ) END IF END IF END SUBROUTINE EigenSerial !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The base case: use lapack to solve (REAL). SUBROUTINE EigenSerial_r ( this , eigenvalues , nvals , threshold , & & eigenvectors_in ) USE DMatrixModule , ONLY : EigenDecomposition !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The eigenvalues of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> Number of values to compute. INTEGER , INTENT ( IN ) :: nvals !> Threshold REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Matrix eigenvectors. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !! Local variables TYPE ( Matrix_lsr ) :: local_s , V_s , W_s TYPE ( Matrix_ldr ) :: local_d , V , W TYPE ( TripletList_r ) :: V_t , W_t #include \"eigenexa_includes/EigenSerial.f90\" END SUBROUTINE EigenSerial_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The base case: use lapack to solve (COMPLEX). SUBROUTINE EigenSerial_c ( this , eigenvalues , nvals , threshold , & & eigenvectors_in ) USE DMatrixModule , ONLY : EigenDecomposition !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The eigenvalues of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> Number of values to compute. INTEGER , INTENT ( IN ) :: nvals !> Threshold REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Matrix eigenvectors. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !! Local variables TYPE ( Matrix_lsc ) :: local_s , V_s , W_s TYPE ( Matrix_ldc ) :: local_d , V , W TYPE ( TripletList_c ) :: V_t , W_t TYPE ( Matrix_ps ) :: eigenvalues_r #include \"eigenexa_includes/EigenSerial.f90\" CALL ConvertMatrixToReal ( eigenvalues , eigenvalues_r ) CALL CopyMatrix ( eigenvalues_r , eigenvalues ) CALL DestructMatrix ( eigenvalues_r ) END SUBROUTINE EigenSerial_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE EigenSolversModule","tags":"","loc":"sourcefile/eigensolversmodule.f90.html"},{"title":"SMatrixAlgebraModule.F90 – NTPoly","text":"Contents Modules SMatrixAlgebraModule Source Code SMatrixAlgebraModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for performing linear algebra using sparse matrices. MODULE SMatrixAlgebraModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE DMatrixModule , ONLY : Matrix_ldr , Matrix_ldc , ConstructMatrixDFromS , & & ConstructMatrixSFromD , CopyMatrix , MultiplyMatrix , TransposeMatrix , & & DestructMatrix USE MatrixMemoryPoolModule , ONLY : MatrixMemoryPool_lr , MatrixMemoryPool_lc , & & DestructMatrixMemoryPool , CheckMemoryPoolValidity , SetPoolSparsity , & & ConstructMatrixMemoryPool USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , CopyMatrix , & & TransposeMatrix , ConjugateMatrix , ConstructMatrixFromTripletList , & & ConstructEmptyMatrix USE SVectorModule , ONLY : AddSparseVectors , PairwiseMultiplyVectors USE TripletListModule , ONLY : TripletList_r , TripletList_c , SortTripletList , & & DestructTripletList , ConstructTripletList IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ScaleMatrix PUBLIC :: IncrementMatrix PUBLIC :: DotMatrix PUBLIC :: PairwiseMultiplyMatrix PUBLIC :: MatrixMultiply PUBLIC :: MatrixColumnNorm PUBLIC :: MatrixNorm PUBLIC :: MatrixGrandSum !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ScaleMatrix MODULE PROCEDURE ScaleMatrix_lsr MODULE PROCEDURE ScaleMatrix_lsc MODULE PROCEDURE ScaleMatrix_lsc_c END INTERFACE ScaleMatrix INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_lsr MODULE PROCEDURE IncrementMatrix_lsc END INTERFACE IncrementMatrix INTERFACE DotMatrix MODULE PROCEDURE DotMatrix_lsr MODULE PROCEDURE DotMatrix_lsc END INTERFACE DotMatrix INTERFACE PairwiseMultiplyMatrix MODULE PROCEDURE PairwiseMultiplyMatrix_lsr MODULE PROCEDURE PairwiseMultiplyMatrix_lsc END INTERFACE PairwiseMultiplyMatrix INTERFACE MatrixMultiply MODULE PROCEDURE GemmMatrix_lsr MODULE PROCEDURE GemmMatrix_lsc END INTERFACE MatrixMultiply INTERFACE MatrixColumnNorm MODULE PROCEDURE MatrixColumnNorm_lsr MODULE PROCEDURE MatrixColumnNorm_lsc END INTERFACE MatrixColumnNorm INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_lsr MODULE PROCEDURE MatrixNorm_lsc END INTERFACE MatrixNorm INTERFACE MatrixGrandSum MODULE PROCEDURE MatrixGrandSum_lsr MODULE PROCEDURE MatrixGrandSum_lsc END INTERFACE MatrixGrandSum INTERFACE MultiplyBlock MODULE PROCEDURE MultiplyBlock_lsr MODULE PROCEDURE MultiplyBlock_lsc END INTERFACE MultiplyBlock INTERFACE PruneList MODULE PROCEDURE PruneList_lsr MODULE PROCEDURE PruneList_lsc END INTERFACE PruneList INTERFACE SparseBranch MODULE PROCEDURE SparseBranch_lsr MODULE PROCEDURE SparseBranch_lsc END INTERFACE SparseBranch INTERFACE DenseBranch MODULE PROCEDURE DenseBranch_lsr MODULE PROCEDURE DenseBranch_lsc END INTERFACE DenseBranch CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsr ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matA !> Constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant #include \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsc ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matA !> Constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant #include \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a sparse matrix by a constant. PURE SUBROUTINE ScaleMatrix_lsc_c ( matA , constant ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matA !> Constant scale factor. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: constant #include \"sparse_includes/ScaleMatrix.f90\" END SUBROUTINE ScaleMatrix_lsc_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY). !> This will utilize the sparse vector addition routine. PURE SUBROUTINE IncrementMatrix_lsr ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matB !> Multiplier (default = 1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default = 0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Variables TYPE ( Matrix_lsr ) :: matC #include \"sparse_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY). !> This will utilize the sparse vector addition routine. PURE SUBROUTINE IncrementMatrix_lsc ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matB !> Multiplier (default = 1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default = 0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Variables TYPE ( Matrix_lsc ) :: matC #include \"sparse_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply two matrices. !> This will utilize the sparse vector pairwise multiply routine. PURE SUBROUTINE PairwiseMultiplyMatrix_lsr ( matA , matB , matC ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !! Local Variables TYPE ( Matrix_lsr ) :: TempMat #include \"sparse_includes/PairwiseMultiplyMatrix.f90\" END SUBROUTINE PairwiseMultiplyMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply two matrices. !> This will utilize the sparse vector pairwise routine. PURE SUBROUTINE PairwiseMultiplyMatrix_lsc ( matA , matB , matC ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !! Local Variables TYPE ( Matrix_lsc ) :: TempMat #include \"sparse_includes/PairwiseMultiplyMatrix.f90\" END SUBROUTINE PairwiseMultiplyMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Product = sum(MatA[ij]*MatB[ij]) PURE SUBROUTINE DotMatrix_lsr ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> Dot product. REAL ( NTREAL ), INTENT ( OUT ) :: product !! Local Variables TYPE ( Matrix_lsr ) :: matC CALL PairwiseMultiplyMatrix ( matA , matB , matC ) CALL MatrixGrandSum ( matC , product ) CALL DestructMatrix ( matC ) END SUBROUTINE DotMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Product = sum(MatA&#94;H[ij]*MatB[ij]) PURE SUBROUTINE DotMatrix_lsc ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> Dot product. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: product !! Local Variables TYPE ( Matrix_lsc ) :: matC TYPE ( Matrix_lsc ) :: matAH CALL CopyMatrix ( matA , matAH ) CALL ConjugateMatrix ( matAH ) CALL PairwiseMultiplyMatrix ( matAH , matB , matC ) CALL MatrixGrandSum ( matC , product ) CALL DestructMatrix ( matC ) CALL DestructMatrix ( matAH ) END SUBROUTINE DotMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*op( matB ) + beta*matC SUBROUTINE GemmMatrix_lsr ( matA , matB , matC , IsATransposed_in , & & IsBTransposed_in , alpha_in , beta_in , threshold_in , & & blocked_memory_pool_in ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !> Scales the multiplication. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> An optional memory pool for doing the calculation. TYPE ( MatrixMemoryPool_lr ), OPTIONAL , & & INTENT ( INOUT ), TARGET :: blocked_memory_pool_in !! Intermediate Data TYPE ( Matrix_lsr ) :: matAB LOGICAL :: IsATransposed , IsBTransposed REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_lr ) :: blocked_memory_pool #include \"sparse_includes/GemmMatrix.f90\" END SUBROUTINE GemmMatrix_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*op( matB ) + beta*matC SUBROUTINE GemmMatrix_lsc ( matA , matB , matC , IsATransposed_in , & & IsBTransposed_in , alpha_in , beta_in , threshold_in , & & blocked_memory_pool_in ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !> Scales the multiplication. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> An optional memory pool for doing the calculation. TYPE ( MatrixMemoryPool_lc ), OPTIONAL , & & INTENT ( INOUT ), TARGET :: blocked_memory_pool_in !! Intermediate Data TYPE ( Matrix_lsc ) :: matAB LOGICAL :: IsATransposed , IsBTransposed REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_lc ) :: blocked_memory_pool #include \"sparse_includes/GemmMatrix.f90\" END SUBROUTINE GemmMatrix_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a sparse matrix along the columns. PURE SUBROUTINE MatrixColumnNorm_lsr ( this , norm_per_column ) !> The matrix to compute the norm of. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The norm value for each column in this matrix. REAL ( NTREAL ), DIMENSION ( this % columns ), INTENT ( OUT ) :: norm_per_column !! Local Data REAL ( NTREAL ) :: temp_value #include \"sparse_includes/MatrixColumnNorm.f90\" END SUBROUTINE MatrixColumnNorm_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a sparse matrix along the columns. PURE SUBROUTINE MatrixColumnNorm_lsc ( this , norm_per_column ) !> The matrix to compute the norm of. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The norm value for each column in this matrix. REAL ( NTREAL ), DIMENSION ( this % columns ), INTENT ( OUT ) :: norm_per_column !! Local Data COMPLEX ( NTCOMPLEX ) :: temp_value #include \"sparse_includes/MatrixColumnNorm.f90\" END SUBROUTINE MatrixColumnNorm_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the 1 norm of a sparse matrix. PURE FUNCTION MatrixNorm_lsr ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables REAL ( NTREAL ), DIMENSION ( this % columns ) :: column #include \"sparse_includes/MatrixNorm.f90\" END FUNCTION MatrixNorm_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the 1 norm of a sparse matrix. PURE FUNCTION MatrixNorm_lsc ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables REAL ( NTREAL ), DIMENSION ( this % columns ) :: column #include \"sparse_includes/MatrixNorm.f90\" END FUNCTION MatrixNorm_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum the elements of a matrix PURE SUBROUTINE MatrixGrandSum_lsr ( this , sum_value ) !> The matrix to sum TYPE ( Matrix_lsr ), INTENT ( IN ) :: this !> The sum of the matrix elements REAL ( NTREAL ), INTENT ( OUT ) :: sum_value #include \"sparse_includes/MatrixGrandSum.f90\" END SUBROUTINE MatrixGrandSum_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum the elements of a matrix PURE SUBROUTINE MatrixGrandSum_lsc ( this , sum_value ) !> The matrix to sum TYPE ( Matrix_lsc ), INTENT ( IN ) :: this !> The sum of the matrix elements COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: sum_value #include \"sparse_includes/MatrixGrandSum.f90\" END SUBROUTINE MatrixGrandSum_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculates the matrix product if using sparse-sparse algorithm. PURE SUBROUTINE SparseBranch_lsr ( matA , matB , matC , IsATransposed , & & IsBTransposed , alpha , threshold , blocked_memory_pool ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Memory pool. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: blocked_memory_pool !! Local Data TYPE ( Matrix_lsr ) :: matAT , matBT #include \"sparse_includes/SparseBranch.f90\" END SUBROUTINE SparseBranch_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculates the matrix product if using the sparse-sparse algorithm. PURE SUBROUTINE SparseBranch_lsc ( matA , matB , matC , IsATransposed , & & IsBTransposed , alpha , threshold , blocked_memory_pool ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Memory pool. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: blocked_memory_pool !! Local Data TYPE ( Matrix_lsc ) :: matAT , matBT #include \"sparse_includes/SparseBranch.f90\" END SUBROUTINE SparseBranch_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate the matrix product using the dense-dense algorithm. SUBROUTINE DenseBranch_lsr ( matA , matB , matC , IsATransposed , IsBTransposed , & & alpha , threshold ) !> Matrix A. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsr ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( Matrix_ldr ) :: DenseA TYPE ( Matrix_ldr ) :: DenseB TYPE ( Matrix_ldr ) :: DenseC #include \"sparse_includes/DenseBranch.f90\" END SUBROUTINE DenseBranch_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate the matrix product using the dense-dense algorithm. SUBROUTINE DenseBranch_lsc ( matA , matB , matC , IsATransposed , IsBTransposed , & & alpha , threshold ) !> Matrix A. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matA !> Matrix B TYPE ( Matrix_lsc ), INTENT ( IN ) :: matB !> matC = alpha*matA*op( matB ) + beta*matC. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matC !> True if A is transposed. LOGICAL , INTENT ( IN ) :: IsATransposed !> True if B is transposed. LOGICAL , INTENT ( IN ) :: IsBTransposed !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values. REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Data TYPE ( Matrix_ldc ) :: DenseA TYPE ( Matrix_ldc ) :: DenseB TYPE ( Matrix_ldc ) :: DenseC #include \"sparse_includes/DenseBranch.f90\" END SUBROUTINE DenseBranch_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiplies a single block fo sparse-sparse. PURE SUBROUTINE MultiplyBlock_lsr ( matAT , matBT , memorypool ) !> Matrix A, already transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matAT !> Matrix B, already transposed. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matBT !> Memory pool to multiply into. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: memorypool !! Temp Variables REAL ( NTREAL ) :: val_a , val_b , val_c #include \"sparse_includes/MultiplyBlock.f90\" END SUBROUTINE MultiplyBlock_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiplies a single block fo sparse-sparse. PURE SUBROUTINE MultiplyBlock_lsc ( matAT , matBT , memorypool ) !> Matrix A, already transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matAT !> Matrix B, already transposed. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matBT !> Memory pool to multiply into. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: memorypool !! Temp Variables COMPLEX ( NTCOMPLEX ) :: val_a , val_b , val_c #include \"sparse_includes/MultiplyBlock.f90\" END SUBROUTINE MultiplyBlock_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prunes out the values of the hash table into the matrix. PURE SUBROUTINE PruneList_lsr ( memorypool , alpha , threshold , mat_c_columns , & & mat_c_rows , matAB ) !> Memory pool to prune from. TYPE ( MatrixMemoryPool_lr ), INTENT ( INOUT ) :: memorypool !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values to zero. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Size of the matrix we computed (columns). INTEGER , INTENT ( IN ) :: mat_c_columns !> Size of the matrix we computed (rows). INTEGER , INTENT ( IN ) :: mat_c_rows !> Sparse matrix to prune out into. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: matAB !! Local data REAL ( NTREAL ) :: working_value TYPE ( TripletList_r ) :: unsorted_pruned_list TYPE ( TripletList_r ) :: sorted_pruned_list #include \"sparse_includes/PruneList.f90\" END SUBROUTINE PruneList_lsr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prunes out the values of the hash table into the matrix. PURE SUBROUTINE PruneList_lsc ( memorypool , alpha , threshold , & & mat_c_columns , mat_c_rows , matAB ) !> Memory pool to prune from. TYPE ( MatrixMemoryPool_lc ), INTENT ( INOUT ) :: memorypool !> Scaling value. REAL ( NTREAL ), INTENT ( IN ) :: alpha !> Threshold for flushing values to zero. REAL ( NTREAL ), INTENT ( IN ) :: threshold !> Size of the matrix we computed (columns). INTEGER , INTENT ( IN ) :: mat_c_columns !> Size of the matrix we computed (rows). INTEGER , INTENT ( IN ) :: mat_c_rows !> Sparse matrix to prune out into. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: matAB !! Local data COMPLEX ( NTCOMPLEX ) :: working_value TYPE ( TripletList_c ) :: unsorted_pruned_list TYPE ( TripletList_c ) :: sorted_pruned_list #include \"sparse_includes/PruneList.f90\" END SUBROUTINE PruneList_lsc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SMatrixAlgebraModule","tags":"","loc":"sourcefile/smatrixalgebramodule.f90.html"},{"title":"EigenBoundsModule.F90 – NTPoly","text":"Contents Modules EigenBoundsModule Source Code EigenBoundsModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for computing estimates of the bounds of the spectrum of a matrix. MODULE EigenBoundsModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteListElement , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , DotMatrix , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , GetMatrixTripletList , FillMatrixFromTripletList USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & AppendToTripletList , DestructTripletList , ConstructTripletList USE TripletModule , ONLY : Triplet_r USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: GershgorinBounds PUBLIC :: PowerBounds CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a bounds on the minimum and maximum eigenvalue of a matrix. !> Uses the Gershgorin theorem. SUBROUTINE GershgorinBounds ( this , min_value , max_value ) !> The matrix to compute the min/max of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> A lower bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: min_value !> An uppder bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: max_value !! Local Data TYPE ( TripletList_r ) :: tlist_r TYPE ( TripletList_c ) :: tlist_c !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: per_column_min REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: per_column_max !! Counters/Temporary INTEGER :: II INTEGER :: local_column INTEGER :: ierr IF ( this % is_complex ) THEN #define tlist tlist_c #include \"solver_includes/GershgorinBounds.f90\" #undef tlist ELSE #define tlist tlist_r #include \"solver_includes/GershgorinBounds.f90\" #undef tlist END IF END SUBROUTINE GershgorinBounds !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute a bounds on the maximum eigenvalue of a matrix. !> Uses The Power Method. SUBROUTINE PowerBounds ( this , max_value , solver_parameters_in ) !> The matrix to compute the min/max of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> An upper bound on the eigenspectrum. REAL ( NTREAL ), INTENT ( OUT ) :: max_value !> The parameters for this calculation. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: param !! Local Data TYPE ( Matrix_ps ) :: vector , vector2 REAL ( NTREAL ) :: scale_value REAL ( NTREAL ) :: norm_value TYPE ( TripletList_r ) :: temp_list TYPE ( Triplet_r ) :: temp_triplet INTEGER :: II TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , param ) ELSE CALL ConstructSolverParameters ( param ) param % max_iterations = 10 END IF IF ( param % be_verbose ) THEN CALL WriteHeader ( \"Power Bounds Solver\" ) CALL EnterSubLog CALL PrintParameters ( param ) END IF !! Diagonal matrices serve as vectors. CALL ConstructEmptyMatrix ( vector , this ) CALL ConstructEmptyMatrix ( vector2 , this ) !! Guess Vector CALL ConstructTripletList ( temp_list ) IF ( this % process_grid % global_rank . EQ . 0 ) THEN temp_triplet % index_row = 1 temp_triplet % index_column = 1 temp_triplet % point_value = 1.0_NTREAL CALL AppendToTripletList ( temp_list , temp_triplet ) END IF CALL FillMatrixFromTripletList ( vector , temp_list ) !! Iterate IF ( param % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = param % converge_diff + 1.0_NTREAL DO II = 1 , param % max_iterations IF ( param % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF !! x = Ax CALL MatrixMultiply ( this , vector , vector2 , & & threshold_in = param % threshold , memory_pool_in = pool ) !! x = x/||x|| scale_value = 1.0 / MatrixNorm ( vector2 ) CALL ScaleMatrix ( vector2 , scale_value ) !! Check if Converged CALL IncrementMatrix ( vector2 , vector , alpha_in = - 1.0_NTREAL ) norm_value = MatrixNorm ( vector ) CALL CopyMatrix ( vector2 , vector ) IF ( norm_value . LE . param % converge_diff ) THEN EXIT END IF END DO IF ( param % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) END IF !! Compute The Largest Eigenvalue CALL DotMatrix ( vector , vector , scale_value ) CALL MatrixMultiply ( this , vector , vector2 , & & threshold_in = param % threshold , memory_pool_in = pool ) CALL DotMatrix ( vector , vector2 , max_value ) max_value = max_value / scale_value IF ( param % be_verbose ) THEN CALL WriteElement ( key = \"Max Eigen Value\" , VALUE = max_value ) CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( vector ) CALL DestructMatrix ( vector2 ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( param ) END SUBROUTINE PowerBounds !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE EigenBoundsModule","tags":"","loc":"sourcefile/eigenboundsmodule.f90.html"},{"title":"PolynomialSolversModule.F90 – NTPoly","text":"Contents Modules PolynomialSolversModule Source Code PolynomialSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing General Matrix Polynomials. MODULE PolynomialSolversModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteListElement , WriteHeader USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : IncrementMatrix , MatrixMultiply , & & ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , DestructMatrix , FillMatrixIdentity , & & ConstructEmptyMatrix , CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype that represents a polynomial. TYPE , PUBLIC :: Polynomial_t !> Coefficients of the polynomial. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: coefficients END TYPE Polynomial_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Polynomial type PUBLIC :: ConstructPolynomial PUBLIC :: DestructPolynomial PUBLIC :: SetCoefficient !! Solvers PUBLIC :: Compute PUBLIC :: FactorizedCompute !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructPolynomial MODULE PROCEDURE ConstructPolynomial_stand END INTERFACE ConstructPolynomial INTERFACE DestructPolynomial MODULE PROCEDURE DestructPolynomial_stand END INTERFACE DestructPolynomial INTERFACE SetCoefficient MODULE PROCEDURE SetCoefficient_stand END INTERFACE SetCoefficient INTERFACE Compute MODULE PROCEDURE Compute_stand END INTERFACE Compute INTERFACE FactorizedCompute MODULE PROCEDURE FactorizedCompute_stand END INTERFACE FactorizedCompute CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a polynomial. PURE SUBROUTINE ConstructPolynomial_stand ( this , degree ) !> The polynomial to construct. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this !> The degree of the polynomial. INTEGER , INTENT ( IN ) :: degree ALLOCATE ( this % coefficients ( degree )) this % coefficients = 0_NTREAL END SUBROUTINE ConstructPolynomial_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a polynomial object. PURE SUBROUTINE DestructPolynomial_stand ( this ) !> The polynomial to destruct. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this IF ( ALLOCATED ( this % coefficients )) THEN DEALLOCATE ( this % coefficients ) END IF END SUBROUTINE DestructPolynomial_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set coefficient of a polynomial. SUBROUTINE SetCoefficient_stand ( this , degree , coefficient ) !> The polynomial to set. TYPE ( Polynomial_t ), INTENT ( INOUT ) :: this !> Degree for which to set the coefficient. INTEGER , INTENT ( IN ) :: degree !> Coefficient value. REAL ( NTREAL ), INTENT ( IN ) :: coefficient this % coefficients ( degree ) = coefficient END SUBROUTINE SetCoefficient_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute A Matrix Polynomial Using the method of Horner. SUBROUTINE Compute_stand ( InputMat , OutputMat , poly , solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Polynomial to compute. TYPE ( Polynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: BalancedInput TYPE ( Matrix_ps ) :: Temporary INTEGER :: degree INTEGER :: II TYPE ( MatrixMemoryPool_p ) :: pool !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF degree = SIZE ( poly % coefficients ) IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Polynomial Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Horner\" ) CALL PrintParameters ( params ) CALL WriteElement ( key = \"Degree\" , VALUE = degree - 1 ) END IF !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) CALL ConstructEmptyMatrix ( Temporary , InputMat ) CALL CopyMatrix ( InputMat , BalancedInput ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( BalancedInput , BalancedInput , & & params % BalancePermutation , memorypool_in = pool ) END IF CALL CopyMatrix ( Identity , OutputMat ) IF ( SIZE ( poly % coefficients ) . EQ . 1 ) THEN CALL ScaleMatrix ( OutputMat , poly % coefficients ( degree )) ELSE CALL ScaleMatrix ( OutputMat , poly % coefficients ( degree - 1 )) CALL IncrementMatrix ( BalancedInput , OutputMat , & & poly % coefficients ( degree )) DO II = degree - 2 , 1 , - 1 CALL MatrixMultiply ( BalancedInput , OutputMat , Temporary , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL CopyMatrix ( Temporary , OutputMat ) CALL IncrementMatrix ( Identity , OutputMat , & & alpha_in = poly % coefficients ( II )) END DO END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Temporary ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE Compute_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute A Matrix Polynomial Using The Paterson and Stockmeyer method. !> This method first factors the polynomial to reduce the number of !> matrix multiplies required. SUBROUTINE FactorizedCompute_stand ( InputMat , OutputMat , poly , & & solver_parameters_in ) !> The input matrix TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> OutputMat = poly(InputMat) TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> The polynomial to compute. TYPE ( Polynomial_t ), INTENT ( IN ) :: poly !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Solver Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ), DIMENSION (:), ALLOCATABLE :: x_powers TYPE ( Matrix_ps ) :: Bk TYPE ( Matrix_ps ) :: Xs TYPE ( Matrix_ps ) :: Temp INTEGER :: degree INTEGER :: m_value , s_value , r_value INTEGER :: k_value INTEGER :: II INTEGER :: c_index TYPE ( MatrixMemoryPool_p ) :: pool !! Handle The Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Parameters for splitting up polynomial. degree = SIZE ( poly % coefficients ) m_value = degree - 1 s_value = INT ( SQRT ( REAL ( m_value ))) r_value = m_value / s_value IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Polynomial Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Paterson Stockmeyer\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"paterson1973number\" ) CALL ExitSubLog CALL PrintParameters ( params ) CALL WriteElement ( key = \"Degree\" , VALUE = degree - 1 ) END IF ALLOCATE ( x_powers ( s_value + 1 )) !! Initial values for matrices CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL FillMatrixIdentity ( Identity ) !! Create the X Powers CALL ConstructEmptyMatrix ( x_powers ( 1 ), InputMat ) CALL FillMatrixIdentity ( x_powers ( 1 )) DO II = 1 , s_value CALL MatrixMultiply ( InputMat , x_powers ( II ), x_powers ( II + 1 ), & & memory_pool_in = pool ) END DO CALL CopyMatrix ( x_powers ( s_value + 1 ), Xs ) !! S_k = bmX CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , poly % coefficients ( s_value * r_value + 1 )) DO II = 1 , m_value - s_value * r_value c_index = s_value * r_value + II CALL IncrementMatrix ( x_powers ( II + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL MatrixMultiply ( Bk , Xs , OutputMat , memory_pool_in = pool ) !! S_k += bmx + bm-1I k_value = r_value - 1 CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , poly % coefficients ( s_value * k_value + 1 )) DO II = 1 , s_value - 1 c_index = s_value * k_value + II CALL IncrementMatrix ( x_powers ( II + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL IncrementMatrix ( Bk , OutputMat ) !! Loop over the rest. DO k_value = r_value - 2 , 0 , - 1 CALL CopyMatrix ( Identity , Bk ) CALL ScaleMatrix ( Bk , poly % coefficients ( s_value * k_value + 1 )) DO II = 1 , s_value - 1 c_index = s_value * k_value + II CALL IncrementMatrix ( x_powers ( II + 1 ), Bk , & & alpha_in = poly % coefficients ( c_index + 1 )) END DO CALL MatrixMultiply ( Xs , OutputMat , Temp ) CALL CopyMatrix ( Temp , OutputMat ) CALL IncrementMatrix ( Bk , OutputMat ) END DO !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF DO II = 1 , s_value + 1 CALL DestructMatrix ( x_powers ( II )) END DO DEALLOCATE ( x_powers ) CALL DestructMatrix ( Bk ) CALL DestructMatrix ( Xs ) CALL DestructMatrix ( Temp ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE FactorizedCompute_stand !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PolynomialSolversModule","tags":"","loc":"sourcefile/polynomialsolversmodule.f90.html"},{"title":"DMatrixModule.F90 – NTPoly","text":"Contents Modules DMatrixModule Source Code DMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module allows one to convert a sparse matrix to a dense matrix. It also !! supports dense the dense versions of core matrix routines. This module is !! used in situations where matrices become too dense for good sparse matrix !! performance. MODULE DMatrixModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , ConstructEmptyMatrix USE TripletModule , ONLY : Triplet_r , Triplet_c IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a dense matrix. TYPE , PUBLIC :: Matrix_ldr REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: DATA !< values of the matrix. INTEGER :: rows !< Matrix dimension: rows. INTEGER :: columns !< Matrix dimension: columns. END TYPE Matrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for storing a dense matrix. TYPE , PUBLIC :: Matrix_ldc !> values of the matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: DATA INTEGER :: rows !< Matrix dimension: rows. INTEGER :: columns !< Matrix dimension: columns. END TYPE Matrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructEmptyMatrix PUBLIC :: ConstructMatrixDFromS PUBLIC :: ConstructMatrixSFromD PUBLIC :: CopyMatrix PUBLIC :: DestructMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SplitMatrix PUBLIC :: ComposeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MatrixNorm PUBLIC :: IncrementMatrix PUBLIC :: MultiplyMatrix PUBLIC :: TransposeMatrix PUBLIC :: EigenDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrixSup_ldr MODULE PROCEDURE ConstructEmptyMatrixSup_ldc END INTERFACE ConstructEmptyMatrix INTERFACE ConstructMatrixDFromS MODULE PROCEDURE ConstructMatrixDFromS_ldr MODULE PROCEDURE ConstructMatrixDFromS_ldc END INTERFACE ConstructMatrixDFromS INTERFACE ConstructMatrixSFromD MODULE PROCEDURE ConstructMatrixSFromD_ldr MODULE PROCEDURE ConstructMatrixSFromD_ldc END INTERFACE ConstructMatrixSFromD INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_ldr MODULE PROCEDURE CopyMatrix_ldc END INTERFACE CopyMatrix INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_ldr MODULE PROCEDURE DestructMatrix_ldc END INTERFACE DestructMatrix INTERFACE SplitMatrix MODULE PROCEDURE SplitMatrix_ldr MODULE PROCEDURE SplitMatrix_ldc END INTERFACE SplitMatrix INTERFACE ComposeMatrix MODULE PROCEDURE ComposeMatrix_ldr MODULE PROCEDURE ComposeMatrix_ldc END INTERFACE ComposeMatrix INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_ldr MODULE PROCEDURE MatrixNorm_ldc END INTERFACE MatrixNorm INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_ldr MODULE PROCEDURE IncrementMatrix_ldc END INTERFACE IncrementMatrix INTERFACE MultiplyMatrix MODULE PROCEDURE MultiplyMatrix_ldr MODULE PROCEDURE MultiplyMatrix_ldc END INTERFACE MultiplyMatrix INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_ldr MODULE PROCEDURE TransposeMatrix_ldc END INTERFACE TransposeMatrix INTERFACE EigenDecomposition MODULE PROCEDURE EigenDecomposition_ldr MODULE PROCEDURE EigenDecomposition_ldc END INTERFACE EigenDecomposition CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine wrapper for the empty constructor. PURE SUBROUTINE ConstructEmptyMatrixSup_ldr ( this , rows , columns ) !> The matrix to construct TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: this !> Rows of the matrix INTEGER , INTENT ( IN ) :: rows !> Columns of the matrix INTEGER , INTENT ( IN ) :: columns #include \"dense_includes/ConstructEmptyMatrix.f90\" END SUBROUTINE ConstructEmptyMatrixSup_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a sparse matrix to a dense matrix. PURE SUBROUTINE ConstructMatrixDFromS_ldr ( sparse_matrix , dense_matrix ) !> The sparse matrix to convert. TYPE ( Matrix_lsr ), INTENT ( IN ) :: sparse_matrix !> Output. Must be preallocated. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: dense_matrix !! Helper Variables TYPE ( Triplet_r ) :: temp #include \"dense_includes/ConstructMatrixDFromS.f90\" END SUBROUTINE ConstructMatrixDFromS_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a dense matrix to a sparse matrix. PURE SUBROUTINE ConstructMatrixSFromD_ldr ( dense_matrix , sparse_matrix , & & threshold_in ) !> Matrix to convert. TYPE ( Matrix_ldr ), INTENT ( IN ) :: dense_matrix !> Output matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: sparse_matrix !> Value for pruning values to zero. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in #include \"dense_includes/ConstructMatrixSFromD.f90\" END SUBROUTINE ConstructMatrixSFromD_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy the matrix A into the B. PURE SUBROUTINE CopyMatrix_ldr ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ldr ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: matB #include \"dense_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocate the memory associated with this matrix. PURE SUBROUTINE DestructMatrix_ldr ( this ) !> The matrix to delete. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: this #include \"dense_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> AXPY for dense matrices. B = B + alpha*A PURE SUBROUTINE IncrementMatrix_ldr ( MatA , MatB , alpha_in ) !> MatA is added TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatA !> MatB is incremented. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: MatB !> A scaling parameter. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !! Temporary REAL ( NTREAL ) :: alpha #include \"dense_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a dense matrix. !> Computes the Frobenius norm. FUNCTION MatrixNorm_ldr ( this ) RESULT ( norm ) !! Parameters !> The matrix to compute the norm of. TYPE ( Matrix_ldr ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm INTEGER :: II , JJ norm = 0 DO II = 1 , this % rows DO JJ = 1 , this % columns norm = norm + this % DATA ( II , JJ ) ** 2 END DO END DO END FUNCTION MatrixNorm_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a dense matrix. PURE SUBROUTINE TransposeMatrix_ldr ( matA , matAT ) !> matA the matrix to transpose. TYPE ( Matrix_ldr ), INTENT ( IN ) :: matA !> matAT = matA&#94;T. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: matAT #include \"dense_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_ldr ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_ldr ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: out_matrix #include \"dense_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_ldr ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_ldr ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A block_columns x block_rows array for the output to go into. TYPE ( Matrix_ldr ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in #include \"dense_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A wrapper for multiplying two dense matrices. SUBROUTINE MultiplyMatrix_ldr ( MatA , MatB , MatC , IsATransposed_in , & & IsBTransposed_in ) !> The first matrix. TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatA !> The second matrix. TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatB !> MatC = MatA*MatB. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: MatC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !! Local variables CHARACTER :: TRANSA CHARACTER :: TRANSB INTEGER :: M INTEGER :: N INTEGER :: K REAL ( NTREAL ), PARAMETER :: ALPHA = 1.0 INTEGER :: LDA INTEGER :: LDB REAL ( NTREAL ), PARAMETER :: BETA = 0.0 INTEGER :: LDC !! Optional Parameters TRANSA = 'N' IF ( PRESENT ( IsATransposed_in )) THEN IF ( IsATransposed_in ) THEN TRANSA = 'T' END IF END IF TRANSB = 'N' IF ( PRESENT ( IsBTransposed_in )) THEN IF ( IsBTransposed_in ) THEN TRANSB = 'T' END IF END IF !! Setup Lapack IF ( TRANSA . EQ . 'T' ) THEN M = MatA % columns ELSE M = MatA % rows END IF IF ( TRANSB . EQ . 'T' ) THEN N = MatB % rows ELSE N = MatB % columns END IF IF ( TRANSA . EQ . 'T' ) THEN K = MatA % rows ELSE K = MatA % columns END IF IF ( TRANSA . EQ . 'T' ) THEN LDA = K ELSE LDA = M END IF IF ( TRANSB . EQ . 'T' ) THEN LDB = N ELSE LDB = K END IF LDC = M !! Multiply CALL ConstructEmptyMatrix ( MatC , M , N ) CALL DGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , MatA % DATA , LDA , MatB % DATA , & & LDB , BETA , MatC % DATA , LDC ) END SUBROUTINE MultiplyMatrix_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigenvectors of a dense matrix. !> Wraps a standard dense linear algebra routine. SUBROUTINE EigenDecomposition_ldr ( MatA , MatV , MatW ) !> MatA the matrix to decompose. TYPE ( Matrix_ldr ), INTENT ( IN ) :: MatA !> The eigenvectors. TYPE ( Matrix_ldr ), INTENT ( INOUT ) :: MatV !> The eigenvalues. TYPE ( Matrix_ldr ), INTENT ( INOUT ), OPTIONAL :: MatW !! Local variables CHARACTER , PARAMETER :: job = 'V' , uplo = 'U' INTEGER :: N , LDA REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: W REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: WORK REAL ( NTREAL ), DIMENSION ( 1 ) :: WORKTEMP INTEGER :: LWORK INTEGER , DIMENSION (:), ALLOCATABLE :: IWORK INTEGER , DIMENSION ( 1 ) :: IWORKTEMP INTEGER :: LIWORK INTEGER :: INFO INTEGER :: II CALL ConstructEmptyMatrix ( MatV , MatA % rows , MatA % columns ) MatV % DATA (:, :) = MatA % DATA N = SIZE ( MatA % DATA , DIM = 1 ) LDA = N !! Allocations ALLOCATE ( W ( N )) !! Determine the scratch space size LWORK = - 1 CALL DSYEVD ( JOB , UPLO , N , MatA % DATA , LDA , W , WORKTEMP , LWORK , IWORKTEMP , & & LIWORK , INFO ) N = LDA LWORK = INT ( WORKTEMP ( 1 )) ALLOCATE ( WORK ( LWORK )) LIWORK = INT ( IWORKTEMP ( 1 )) ALLOCATE ( IWORK ( LIWORK )) !! Run Lapack For Real CALL DSYEVD ( JOB , UPLO , N , MatV % DATA , LDA , W , WORK , LWORK , IWORK , LIWORK , & & INFO ) !! Extract Eigenvalues IF ( PRESENT ( MatW )) THEN CALL ConstructEmptyMatrix ( MatW , MatA % rows , MatA % columns ) MatW % DATA = 0 DO II = 1 , N MatW % DATA ( II , II ) = W ( II ) END DO END IF !! Cleanup DEALLOCATE ( W ) DEALLOCATE ( Work ) END SUBROUTINE EigenDecomposition_ldr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A subroutine style wrapper for the constructor. PURE SUBROUTINE ConstructEmptyMatrixSup_ldc ( this , rows , columns ) !> The matrix to construct. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: this !> The number of rows of the matrix. INTEGER , INTENT ( IN ) :: rows !> The number of columns o the matrix. INTEGER , INTENT ( IN ) :: columns #include \"dense_includes/ConstructEmptyMatrix.f90\" END SUBROUTINE ConstructEmptyMatrixSup_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a sparse matrix to a dense matrix. PURE SUBROUTINE ConstructMatrixDFromS_ldc ( sparse_matrix , dense_matrix ) !> The sparse matrix to convert. TYPE ( Matrix_lsc ), INTENT ( IN ) :: sparse_matrix !> Dense matrix output. Must be preallocated. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: dense_matrix !! Helper Variables TYPE ( Triplet_c ) :: temp #include \"dense_includes/ConstructMatrixDFromS.f90\" END SUBROUTINE ConstructMatrixDFromS_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A function that converts a dense matrix to a sparse matrix. PURE SUBROUTINE ConstructMatrixSFromD_ldc ( dense_matrix , sparse_matrix , & & threshold_in ) !> The matrix to convert. TYPE ( Matrix_ldc ), INTENT ( IN ) :: dense_matrix !> The sparse output matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: sparse_matrix !> Value for pruning values to zero. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in #include \"dense_includes/ConstructMatrixSFromD.f90\" END SUBROUTINE ConstructMatrixSFromD_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy the matrix A into the B. PURE SUBROUTINE CopyMatrix_ldc ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ldc ), INTENT ( IN ) :: matA !> matB = matA TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: matB #include \"dense_includes/CopyMatrix.f90\" END SUBROUTINE CopyMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocate the memory associated with this matrix. PURE SUBROUTINE DestructMatrix_ldc ( this ) !> This the matrix to delete. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: this #include \"dense_includes/DestructMatrix.f90\" END SUBROUTINE DestructMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> AXPY for dense matrices. B = B + alpha*A PURE SUBROUTINE IncrementMatrix_ldc ( MatA , MatB , alpha_in ) !> MatA is added TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatA !> MatB is incremented. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: MatB !> A scaling parameter. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !! Temporary REAL ( NTREAL ) :: alpha #include \"dense_includes/IncrementMatrix.f90\" END SUBROUTINE IncrementMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a dense matrix. !> Computes the Frobenius norm. FUNCTION MatrixNorm_ldc ( this ) RESULT ( norm ) !> The matrix to compute the norm of. TYPE ( Matrix_ldc ), INTENT ( IN ) :: this !> The norm of the matrix. REAL ( NTREAL ) :: norm !! Local Variables INTEGER :: II , JJ COMPLEX ( NTCOMPLEX ) :: val , conjval norm = 0 DO II = 1 , this % rows DO JJ = 1 , this % columns val = this % DATA ( II , JJ ) conjval = CONJG ( val ) norm = norm + REAL ( val * conjval , KIND = NTREAL ) END DO END DO END FUNCTION MatrixNorm_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a dense matrix. PURE SUBROUTINE TransposeMatrix_ldc ( matA , matAT ) !> The matrix to transpose. TYPE ( Matrix_ldc ), INTENT ( IN ) :: matA !> matAT = matA&#94;T. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: matAT #include \"dense_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a big matrix from an array of matrices by putting them one next !> to another. PURE SUBROUTINE ComposeMatrix_ldc ( mat_array , block_rows , block_columns , & & out_matrix ) !> The number of rows of the array of blocks. INTEGER , INTENT ( IN ) :: block_rows !> The number of columns of the array of blocks. INTEGER , INTENT ( IN ) :: block_columns !> 2d array of matrices to compose. TYPE ( Matrix_ldc ), DIMENSION ( block_rows , block_columns ), INTENT ( IN ) :: & & mat_array !> The composed matrix. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: out_matrix #include \"dense_includes/ComposeMatrix.f90\" END SUBROUTINE ComposeMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split a sparse matrix into an array of sparse matrices. PURE SUBROUTINE SplitMatrix_ldc ( this , block_rows , block_columns , & & split_array , block_size_row_in , block_size_column_in ) !> The matrix to split. TYPE ( Matrix_ldc ), INTENT ( IN ) :: this !> Number of rows to split the matrix into. INTEGER , INTENT ( IN ) :: block_rows !> Number of columns to split the matrix into. INTEGER , INTENT ( IN ) :: block_columns !> A COLUMNxROW array for the output to go into. TYPE ( Matrix_ldc ), DIMENSION (:,:), INTENT ( INOUT ) :: split_array !> Specifies the size of the  rows. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_row_in !> Specifies the size of the columns. INTEGER , DIMENSION (:), INTENT ( IN ), OPTIONAL :: block_size_column_in #include \"dense_includes/SplitMatrix.f90\" END SUBROUTINE SplitMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A wrapper for multiplying two dense matrices. SUBROUTINE MultiplyMatrix_ldc ( MatA , MatB , MatC , IsATransposed_in , & & IsBTransposed_in ) !> The first matrix. TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatA !> The second matrix. TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatB !> MatC = MatA*MatB. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: MatC !> True if A is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsATransposed_in !> True if B is already transposed. LOGICAL , OPTIONAL , INTENT ( IN ) :: IsBTransposed_in !! Local variables CHARACTER :: TRANSA CHARACTER :: TRANSB INTEGER :: M INTEGER :: N INTEGER :: K COMPLEX ( NTCOMPLEX ), PARAMETER :: ALPHA = 1.0 INTEGER :: LDA INTEGER :: LDB COMPLEX ( NTCOMPLEX ), PARAMETER :: BETA = 0.0 INTEGER :: LDC !! Optional Parameters TRANSA = 'N' IF ( PRESENT ( IsATransposed_in )) THEN IF ( IsATransposed_in ) THEN TRANSA = 'T' END IF END IF TRANSB = 'N' IF ( PRESENT ( IsBTransposed_in )) THEN IF ( IsBTransposed_in ) THEN TRANSB = 'T' END IF END IF !! Setup Lapack IF ( TRANSA . EQ . 'T' ) THEN M = MatA % columns ELSE M = MatA % rows END IF IF ( TRANSB . EQ . 'T' ) THEN N = MatB % rows ELSE N = MatB % columns END IF IF ( TRANSA . EQ . 'T' ) THEN K = MatA % rows ELSE K = MatA % columns END IF IF ( TRANSA . EQ . 'T' ) THEN LDA = K ELSE LDA = M END IF IF ( TRANSB . EQ . 'T' ) THEN LDB = N ELSE LDB = K END IF LDC = M !! Multiply CALL ConstructEmptyMatrix ( MatC , M , N ) CALL ZGEMM ( TRANSA , TRANSB , M , N , K , ALPHA , MatA % DATA , LDA , MatB % DATA , & & LDB , BETA , MatC % DATA , LDC ) END SUBROUTINE MultiplyMatrix_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigenvectors of a dense matrix. !> Wraps a standard dense linear algebra routine. SUBROUTINE EigenDecomposition_ldc ( MatA , MatV , MatW ) !> The matrix to decompose. TYPE ( Matrix_ldc ), INTENT ( IN ) :: MatA !> The eigenvectors. TYPE ( Matrix_ldc ), INTENT ( INOUT ) :: MatV !> The eigenvalues. TYPE ( Matrix_ldc ), INTENT ( INOUT ), OPTIONAL :: MatW !! Standard parameters CHARACTER , PARAMETER :: job = 'V' , uplo = 'U' INTEGER :: N , LDA REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: W COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: WORK INTEGER :: LWORK REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: RWORK INTEGER :: LRWORK INTEGER , DIMENSION (:), ALLOCATABLE :: IWORK INTEGER :: LIWORK INTEGER :: INFO !! Temp COMPLEX ( NTCOMPLEX ), DIMENSION ( 1 ) :: WORKTEMP REAL ( NTREAL ), DIMENSION ( 1 ) :: RWORKTEMP INTEGER , DIMENSION ( 1 ) :: IWORKTEMP INTEGER :: II CALL ConstructEmptyMatrix ( MatV , MatA % rows , MatA % columns ) MatV % DATA (:, :) = MatA % DATA N = SIZE ( MatA % DATA , DIM = 1 ) LDA = N !! Allocations ALLOCATE ( W ( N )) !! Determine the scratch space size LWORK = - 1 CALL ZHEEVD ( JOB , UPLO , N , MatA % DATA , LDA , W , WORKTEMP , LWORK , RWORKTEMP , & & LRWORK , IWORKTEMP , LIWORK , INFO ) N = LDA LWORK = INT ( WORKTEMP ( 1 )) ALLOCATE ( WORK ( LWORK )) LRWORK = INT ( RWORKTEMP ( 1 )) ALLOCATE ( RWORK ( LRWORK )) LIWORK = INT ( IWORKTEMP ( 1 )) ALLOCATE ( IWORK ( LIWORK )) !! Run Lapack For Real CALL ZHEEVD ( JOB , UPLO , N , MatV % DATA , LDA , W , WORK , LWORK , RWORK , LRWORK , & & IWORK , LIWORK , INFO ) !! Extract Eigenvalues IF ( PRESENT ( MatW )) THEN CALL ConstructEmptyMatrix ( MatW , MatA % rows , MatA % columns ) MatW % DATA = 0 DO II = 1 , N MatW % DATA ( II , II ) = W ( II ) END DO END IF !! Cleanup DEALLOCATE ( W ) DEALLOCATE ( Work ) DEALLOCATE ( RWork ) END SUBROUTINE EigenDecomposition_ldc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE DMatrixModule","tags":"","loc":"sourcefile/dmatrixmodule.f90.html"},{"title":"MatrixMarketModule.F90 – NTPoly","text":"Contents Modules MatrixMarketModule Source Code MatrixMarketModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module contains helpers for processing matrix market files. MODULE MatrixMarketModule USE DataTypesModule , ONLY : NTREAL , NTLONG IMPLICIT NONE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ENUM , BIND ( c ) !> Sparse coordinate file. ENUMERATOR :: MM_COORDINATE = 1 !> Dense array file. ENUMERATOR :: MM_ARRAY = 2 !> Real data being read in. ENUMERATOR :: MM_REAL = 1 !> Integer data being read in. ENUMERATOR :: MM_INTEGER = 2 !>Complex numbers being read in. ENUMERATOR :: MM_COMPLEX = 3 !> Just a pattern of non zeros. ENUMERATOR :: MM_PATTERN = 4 !> File lacks symmetry. ENUMERATOR :: MM_GENERAL = 1 !> File is symmetric ENUMERATOR :: MM_SYMMETRIC = 2 !> File is skew symmetric. ENUMERATOR :: MM_SKEW_SYMMETRIC = 3 !> File is hermitian. ENUMERATOR :: MM_HERMITIAN = 4 END ENUM !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The longest line size possible according to the spec. INTEGER , PARAMETER :: MAX_LINE_LENGTH = 1024 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ParseMMHeader PUBLIC :: WriteMMSize PUBLIC :: WriteMMLine !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE WriteMMLine MODULE PROCEDURE WriteMMLine_ii MODULE PROCEDURE WriteMMLine_iif MODULE PROCEDURE WriteMMLine_iiff MODULE PROCEDURE WriteMMLine_f MODULE PROCEDURE WriteMMLine_ff END INTERFACE WriteMMLine CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Parse a matrix market header. FUNCTION ParseMMHeader ( line , sparsity_type , data_type , pattern_type ) & & RESULT ( no_error ) !> String to parse. CHARACTER ( LEN = * ), INTENT ( IN ) :: line !> If coordinate or array type. INTEGER , INTENT ( OUT ) :: sparsity_type !> If real, integer, complex, pattern. INTEGER , INTENT ( OUT ) :: data_type !> If general, symmetric, skew_symmetric, hermitian. INTEGER , INTENT ( OUT ) :: pattern_type !> True if no errors. LOGICAL :: no_error !! Local Data INTEGER :: pos1 , pos2 no_error = . TRUE . !! This part is just \"MatrixMarket\". pos1 = 1 pos2 = INDEX ( line ( pos1 :), ' ' ) !! This part is just \"matrix\". pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) !! This part is coordinate or array. pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) SELECT CASE ( TRIM ( line ( pos1 : pos1 + pos2 - 1 ))) CASE ( 'coordinate' ) sparsity_type = MM_COORDINATE CASE ( 'array' ) sparsity_type = MM_ARRAY CASE DEFAULT no_error = . FALSE . END SELECT !! This part is real, integer, complex, pattern. pos1 = pos2 + pos1 pos2 = INDEX ( line ( pos1 :), ' ' ) SELECT CASE ( TRIM ( line ( pos1 : pos1 + pos2 - 1 ))) CASE ( 'real' ) data_type = MM_REAL CASE ( 'array' ) data_type = MM_INTEGER CASE ( 'complex' ) data_type = MM_COMPLEX CASE ( 'pattern' ) data_type = MM_PATTERN CASE DEFAULT no_error = . FALSE . END SELECT !! This part is general, symmetric, skew-symmetric, hermitian. pos1 = pos2 + pos1 SELECT CASE ( TRIM ( line ( pos1 :))) CASE ( 'general' ) pattern_type = MM_GENERAL CASE ( 'symmetric' ) pattern_type = MM_SYMMETRIC CASE ( 'skew-symmetric' ) pattern_type = MM_SKEW_SYMMETRIC CASE ( 'hermitian' ) pattern_type = MM_HERMITIAN CASE DEFAULT no_error = . FALSE . END SELECT END FUNCTION ParseMMHeader !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write the line describing the size of the matrix PURE SUBROUTINE WriteMMSize ( outstring , rows , columns , values_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The number of rows of the matrix INTEGER , INTENT ( IN ) :: rows !> The number of columns of the matrix INTEGER , INTENT ( IN ) :: columns !> The total number of non zero values in the matrix (for sparse format). INTEGER ( KIND = NTLONG ), INTENT ( IN ), OPTIONAL :: values_in !! Local variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 , temp2 , temp3 !! Write everything to strings. WRITE ( temp1 , * ) rows WRITE ( temp2 , * ) columns IF ( PRESENT ( values_in )) THEN WRITE ( temp3 , * ) values_in ELSE WRITE ( temp3 , * ) \"\" END IF !! Combine WRITE ( outstring , '(3A)' ) ADJUSTL ( TRIM ( temp1 )), ADJUSTL ( TRIM ( temp2 )), & & ADJUSTL ( TRIM ( temp3 )) END SUBROUTINE WriteMMSize !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a single line that would correspond to a matrix market entry. PURE SUBROUTINE WriteMMLine_ii ( outstring , row , column , add_newline_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The first coordinate value INTEGER , INTENT ( IN ) :: row !> The second coordinate value INTEGER , INTENT ( IN ) :: column !> Whether to append a new line to the output (default = .false.) LOGICAL , INTENT ( IN ), OPTIONAL :: add_newline_in !! Local variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 , temp2 LOGICAL :: add_newline !! Process Optional Arguments IF ( PRESENT ( add_newline_in )) THEN add_newline = add_newline_in ELSE add_newline = . FALSE . END IF !! Write everything to strings. WRITE ( temp1 , * ) row WRITE ( temp2 , * ) column !! Combine IF ( add_newline ) THEN WRITE ( outstring , '(3A)' ) ADJUSTL ( TRIM ( temp1 )), & & ADJUSTL ( TRIM ( temp2 )) // NEW_LINE ( 'A' ) ELSE WRITE ( outstring , '(2A)' ) ADJUSTL ( TRIM ( temp1 )), ADJUSTL ( TRIM ( temp2 )) END IF END SUBROUTINE WriteMMLine_ii !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a single line that would correspond to a matrix market entry. PURE SUBROUTINE WriteMMLine_iif ( outstring , row , column , val , add_newline_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The first coordinate value INTEGER , INTENT ( IN ) :: row !> The second coordinate value INTEGER , INTENT ( IN ) :: column !> The value at that coordinate REAL ( NTREAL ), INTENT ( IN ) :: val !> Whether to append a new line to the output (default = .false.) LOGICAL , INTENT ( IN ), OPTIONAL :: add_newline_in !! Local variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 , temp2 , temp3 LOGICAL :: add_newline !! Process Optional Arguments IF ( PRESENT ( add_newline_in )) THEN add_newline = add_newline_in ELSE add_newline = . FALSE . END IF !! Write everything to strings. WRITE ( temp1 , * ) row WRITE ( temp2 , * ) column WRITE ( temp3 , * ) val !! Combine IF ( add_newline ) THEN WRITE ( outstring , '(4A)' ) ADJUSTL ( TRIM ( temp1 )), & & ADJUSTL ( TRIM ( temp2 )), ADJUSTL ( TRIM ( temp3 )) // NEW_LINE ( 'A' ) ELSE WRITE ( outstring , '(3A)' ) ADJUSTL ( TRIM ( temp1 )), ADJUSTL ( TRIM ( temp2 )), & & ADJUSTL ( TRIM ( temp3 )) END IF END SUBROUTINE WriteMMLine_iif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a single line that would correspond to a matrix market entry. PURE SUBROUTINE WriteMMLine_iiff ( outstring , row , column , val1 , val2 , & & add_newline_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The first coordinate value INTEGER , INTENT ( IN ) :: row !> The second coordinate value INTEGER , INTENT ( IN ) :: column !> The value at that coordinate REAL ( NTREAL ), INTENT ( IN ) :: val1 !> The second value at the coordinate REAL ( NTREAL ), INTENT ( IN ) :: val2 !> Whether to append a new line to the output (default = .false.) LOGICAL , INTENT ( IN ), OPTIONAL :: add_newline_in !! Local variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 , temp2 , temp3 , temp4 LOGICAL :: add_newline !! Process Optional Arguments IF ( PRESENT ( add_newline_in )) THEN add_newline = add_newline_in ELSE add_newline = . FALSE . END IF !! Write everything to strings. WRITE ( temp1 , * ) row WRITE ( temp2 , * ) column WRITE ( temp3 , * ) val1 WRITE ( temp4 , * ) val2 !! Combine IF ( add_newline ) THEN WRITE ( outstring , '(5A)' ) ADJUSTL ( TRIM ( temp1 )), & & ADJUSTL ( TRIM ( temp2 )), ADJUSTL ( TRIM ( temp3 )), & & ADJUSTL ( TRIM ( temp4 )) // NEW_LINE ( 'A' ) ELSE WRITE ( outstring , '(4A)' ) ADJUSTL ( TRIM ( temp1 )), & & ADJUSTL ( TRIM ( temp2 )), ADJUSTL ( TRIM ( temp3 )), ADJUSTL ( TRIM ( temp4 )) END IF END SUBROUTINE WriteMMLine_iiff !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a single line that would correspond to a matrix market entry. PURE SUBROUTINE WriteMMLine_f ( outstring , val , add_newline_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The value at that coordinate REAL ( NTREAL ), INTENT ( IN ) :: val !> Whether to append a new line to the output (default = .false.) LOGICAL , INTENT ( IN ), OPTIONAL :: add_newline_in !! Local Variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 LOGICAL :: add_newline !! Process Optional Arguments IF ( PRESENT ( add_newline_in )) THEN add_newline = add_newline_in ELSE add_newline = . FALSE . END IF !! Write everything to strings. WRITE ( temp1 , * ) val !! Combine IF ( add_newline ) THEN WRITE ( outstring , '(2A)' ) ADJUSTL ( TRIM ( temp1 )) // NEW_LINE ( 'A' ) ELSE WRITE ( outstring , '(A)' ) ADJUSTL ( TRIM ( temp1 )) END IF END SUBROUTINE WriteMMLine_f !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a single line that would correspond to a matrix market entry. PURE SUBROUTINE WriteMMLine_ff ( outstring , val1 , val2 , add_newline_in ) !> The final string is written to this variable. CHARACTER ( LEN = MAX_LINE_LENGTH ), INTENT ( INOUT ) :: outstring !> The value at that coordinate REAL ( NTREAL ), INTENT ( IN ) :: val1 !> The second value at that coordinate REAL ( NTREAL ), INTENT ( IN ) :: val2 !> Whether to append a new line to the output (default = .false.) LOGICAL , INTENT ( IN ), OPTIONAL :: add_newline_in !! Local variables CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp1 , temp2 LOGICAL :: add_newline !! Process Optional Arguments IF ( PRESENT ( add_newline_in )) THEN add_newline = add_newline_in ELSE add_newline = . FALSE . END IF !! Write everything to strings. WRITE ( temp1 , * ) val1 WRITE ( temp2 , * ) val2 !! Combine IF ( add_newline ) THEN WRITE ( outstring , '(3A)' ) ADJUSTL ( TRIM ( temp1 )), ADJUSTL ( TRIM ( temp2 )) & & // NEW_LINE ( 'A' ) ELSE WRITE ( outstring , '(2A)' ) ADJUSTL ( TRIM ( temp1 )), ADJUSTL ( TRIM ( temp2 )) END IF END SUBROUTINE WriteMMLine_ff !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixMarketModule","tags":"","loc":"sourcefile/matrixmarketmodule.f90.html"},{"title":"MatrixConversionModule.F90 – NTPoly","text":"Contents Modules MatrixConversionModule Source Code MatrixConversionModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This module contains helper routines for converting an NTPoly matrix !> to data structures used in other programs. MODULE MatrixConversionModule USE DataTypesModule , ONLY : NTREAL USE PSMatrixModule , ONLY : Matrix_ps , ConvertMatrixToReal , CopyMatrix , & & DestructMatrix , MergeMatrixLocalBlocks , SplitMatrixToLocalBlocks USE PSMatrixAlgebraModule , ONLY : PairwiseMultiplyMatrix , ScaleMatrix , & & IncrementMatrix USE SMatrixModule , ONLY : Matrix_lsr , DestructMatrix IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SnapMatrixToSparsityPattern CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Some codes use a fixed sparsity pattern for a matrix instead of filtering !> small values. Using this routine, the matrix is filled to have the same !> pattern as the second matrix argument. Zeros of the sparsity pattern are !> left in, whereas values outside the sparsity are removed. This can !> faciliate conversion between formats. SUBROUTINE SnapMatrixToSparsityPattern ( mat , pattern ) !> The matrix to modify. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: mat !> The matrix which defines the sparsity pattern. TYPE ( Matrix_ps ), INTENT ( IN ) :: pattern !! Local Variables TYPE ( Matrix_ps ) :: filtered TYPE ( Matrix_ps ) :: pattern_1s TYPE ( Matrix_ps ) :: pattern_0s TYPE ( Matrix_lsr ) :: local_mat !! First we need to make sure that the sparsity pattern is all 1s. IF ( pattern % is_complex ) THEN CALL ConvertMatrixToReal ( pattern , pattern_1s ) ELSE CALL CopyMatrix ( pattern , pattern_1s ) END IF CALL MergeMatrixLocalBlocks ( pattern_1s , local_mat ) local_mat % values = 1.0_NTREAL CALL SplitMatrixToLocalBlocks ( pattern_1s , local_mat ) !! Then all zeros CALL CopyMatrix ( pattern_1s , pattern_0s ) CALL ScaleMatrix ( pattern_0s , 0.0_NTREAL ) !! Here we add in the zero values that were missing from the original !! matrix. The secret here is that if you use a negative threshold, we !! never filter a value. CALL IncrementMatrix ( pattern_0s , mat , threshold_in = - 1.0_NTREAL ) !! Next, we zero out values outside of the sparsity pattern. CALL CopyMatrix ( mat , filtered ) CALL PairwiseMultiplyMatrix ( pattern_1s , filtered , mat ) !! Cleanup CALL DestructMatrix ( pattern_1s ) CALL DestructMatrix ( pattern_0s ) CALL DestructMatrix ( filtered ) CALL DestructMatrix ( local_mat ) END SUBROUTINE SnapMatrixToSparsityPattern !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE MatrixConversionModule","tags":"","loc":"sourcefile/matrixconversionmodule.f90.html"},{"title":"PSMatrixModule.F90 – NTPoly","text":"Contents Modules PSMatrixModule Source Code PSMatrixModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Performing Distributed Sparse Matrix Operations. MODULE PSMatrixModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER , NTLONG , MPINTLONG USE ErrorModule , ONLY : Error_t , ConstructError , SetGenericError , & & CheckMPIError USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteListElement , WriteHeader USE MatrixMarketModule , ONLY : ParseMMHeader , MM_COMPLEX , WriteMMSize , & & WriteMMLine , MAX_LINE_LENGTH USE MatrixReduceModule , ONLY : ReduceHelper_t , ReduceAndComposeMatrix , & & ReduceAndSumMatrix USE PermutationModule , ONLY : Permutation_t , ConstructDefaultPermutation USE ProcessGridModule , ONLY : ProcessGrid_t , global_grid , IsRoot , & & SplitProcessGrid USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , & & PrintMatrix , TransposeMatrix , ConjugateMatrix , SplitMatrix , & & ComposeMatrix , ConvertMatrixType , MatrixToTripletList , & & ConstructMatrixFromTripletList , ConstructEmptyMatrix USE TripletModule , ONLY : Triplet_r , Triplet_c , GetMPITripletType_r , & & GetMPITripletType_c USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & ConstructTripletList , CopyTripletList , & & DestructTripletList , SortTripletList , AppendToTripletList , & & SymmetrizeTripletList , GetTripletAt , RedistributeTripletLists , & & ShiftTripletList USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype for a distributed blocked CSR matrix. TYPE , PUBLIC :: Matrix_ps !> Number of matrix rows/columns for full matrix, scaled for process grid. INTEGER :: logical_matrix_dimension !> Number of matrix rows/columns for the full matrix, unscaled. INTEGER :: actual_matrix_dimension !! Local Storage !> A 2D array of local CSR matrices. TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: local_data_r !> A 2D array of local CSC matrices. TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: local_data_c INTEGER :: start_column !< first column stored locally. INTEGER :: end_column !< last column stored locally  is less than this. INTEGER :: start_row !< first row stored locally. INTEGER :: end_row !< last row stored locally is less than this. INTEGER :: local_columns !< number of local columns. INTEGER :: local_rows !< number of local rows. TYPE ( ProcessGrid_t ), POINTER :: process_grid !< process grid to operate on LOGICAL :: is_complex !< true if the matrix data is true. END TYPE Matrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Constructors/Destructors PUBLIC :: ConstructEmptyMatrix PUBLIC :: DestructMatrix PUBLIC :: CopyMatrix PUBLIC :: SetMatrixProcessGrid !! File I/O PUBLIC :: ConstructMatrixFromMatrixMarket PUBLIC :: ConstructMatrixFromBinary PUBLIC :: WriteMatrixToMatrixMarket PUBLIC :: WriteMatrixToBinary !! Fill In Special Matrices PUBLIC :: FillMatrixFromTripletList PUBLIC :: FillMatrixIdentity PUBLIC :: FillMatrixPermutation PUBLIC :: FillMatrixDense !! Basic Accessors PUBLIC :: GetMatrixActualDimension PUBLIC :: GetMatrixLogicalDimension PUBLIC :: GetMatrixTripletList PUBLIC :: GetMatrixBlock PUBLIC :: GetMatrixSlice !! Printing To The Console PUBLIC :: PrintMatrix PUBLIC :: PrintMatrixInformation !! Utilities PUBLIC :: ConvertMatrixToReal PUBLIC :: ConvertMatrixToComplex PUBLIC :: GetMatrixLoadBalance PUBLIC :: GetMatrixSize PUBLIC :: FilterMatrix PUBLIC :: MergeMatrixLocalBlocks PUBLIC :: SplitMatrixToLocalBlocks PUBLIC :: TransposeMatrix PUBLIC :: ConjugateMatrix PUBLIC :: CommSplitMatrix PUBLIC :: ResizeMatrix PUBLIC :: GatherMatrixToProcess PUBLIC :: IsIdentity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructEmptyMatrix MODULE PROCEDURE ConstructEmptyMatrix_ps MODULE PROCEDURE ConstructEmptyMatrix_ps_cp END INTERFACE ConstructEmptyMatrix INTERFACE DestructMatrix MODULE PROCEDURE DestructMatrix_ps END INTERFACE DestructMatrix INTERFACE CopyMatrix MODULE PROCEDURE CopyMatrix_ps END INTERFACE CopyMatrix INTERFACE ConstructMatrixFromMatrixMarket MODULE PROCEDURE ConstructMatrixFromMatrixMarket_ps END INTERFACE ConstructMatrixFromMatrixMarket INTERFACE ConstructMatrixFromBinary MODULE PROCEDURE ConstructMatrixFromBinary_ps END INTERFACE ConstructMatrixFromBinary INTERFACE WriteMatrixToMatrixMarket MODULE PROCEDURE WriteMatrixToMatrixMarket_ps END INTERFACE WriteMatrixToMatrixMarket INTERFACE WriteMatrixToBinary MODULE PROCEDURE WriteMatrixToBinary_ps END INTERFACE WriteMatrixToBinary INTERFACE FillMatrixFromTripletList MODULE PROCEDURE FillMatrixFromTripletList_psr MODULE PROCEDURE FillMatrixFromTripletList_psc END INTERFACE FillMatrixFromTripletList INTERFACE FillMatrixIdentity MODULE PROCEDURE FillMatrixIdentity_ps END INTERFACE FillMatrixIdentity INTERFACE FillMatrixPermutation MODULE PROCEDURE FillMatrixPermutation_ps END INTERFACE FillMatrixPermutation INTERFACE FillMatrixDense MODULE PROCEDURE FillMatrixDense_ps END INTERFACE FillMatrixDense INTERFACE GetMatrixActualDimension MODULE PROCEDURE GetMatrixActualDimension_ps END INTERFACE GetMatrixActualDimension INTERFACE GetMatrixLogicalDimension MODULE PROCEDURE GetMatrixLogicalDimension_ps END INTERFACE GetMatrixLogicalDimension INTERFACE GetMatrixTripletList MODULE PROCEDURE GetMatrixTripletList_psr MODULE PROCEDURE GetMatrixTripletList_psc END INTERFACE GetMatrixTripletList INTERFACE GetMatrixBlock MODULE PROCEDURE GetMatrixBlock_psr MODULE PROCEDURE GetMatrixBlock_psc END INTERFACE GetMatrixBlock INTERFACE PrintMatrix MODULE PROCEDURE PrintMatrix_ps END INTERFACE PrintMatrix INTERFACE PrintMatrixInformation MODULE PROCEDURE PrintMatrixInformation_ps END INTERFACE PrintMatrixInformation INTERFACE GetMatrixLoadBalance MODULE PROCEDURE GetMatrixLoadBalance_ps END INTERFACE GetMatrixLoadBalance INTERFACE GetMatrixSize MODULE PROCEDURE GetMatrixSize_ps END INTERFACE GetMatrixSize INTERFACE FilterMatrix MODULE PROCEDURE FilterMatrix_ps END INTERFACE FilterMatrix INTERFACE RedistributeData MODULE PROCEDURE RedistributeData_psr MODULE PROCEDURE RedistributeData_psc END INTERFACE RedistributeData INTERFACE MergeMatrixLocalBlocks MODULE PROCEDURE MergeMatrixLocalBlocks_psr MODULE PROCEDURE MergeMatrixLocalBlocks_psc END INTERFACE MergeMatrixLocalBlocks INTERFACE SplitMatrixToLocalBlocks MODULE PROCEDURE SplitMatrixToLocalBlocks_psr MODULE PROCEDURE SplitMatrixToLocalBlocks_psc END INTERFACE SplitMatrixToLocalBlocks INTERFACE TransposeMatrix MODULE PROCEDURE TransposeMatrix_ps END INTERFACE TransposeMatrix INTERFACE ConjugateMatrix MODULE PROCEDURE ConjugateMatrix_ps END INTERFACE ConjugateMatrix INTERFACE CommSplitMatrix MODULE PROCEDURE CommSplitMatrix_ps END INTERFACE CommSplitMatrix INTERFACE GatherMatrixToProcess MODULE PROCEDURE GatherMatrixToProcess_psr_id MODULE PROCEDURE GatherMatrixToProcess_psr_all MODULE PROCEDURE GatherMatrixToProcess_psc_id MODULE PROCEDURE GatherMatrixToProcess_psc_all END INTERFACE GatherMatrixToProcess CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty sparse, distributed, matrix. SUBROUTINE ConstructEmptyMatrix_ps ( this , matrix_dim , process_grid_in , & & is_complex_in ) !> The matrix to be constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The dimension of the full matrix. INTEGER , INTENT ( IN ) :: matrix_dim !> True if you want to use complex numbers. LOGICAL , INTENT ( IN ), OPTIONAL :: is_complex_in !> A process grid to host the matrix. TYPE ( ProcessGrid_t ), INTENT ( IN ), TARGET , OPTIONAL :: process_grid_in !! Local Variables TYPE ( Matrix_lsr ) :: zeromatrix_r TYPE ( Matrix_lsc ) :: zeromatrix_c CALL DestructMatrix ( this ) !! Process Grid IF ( PRESENT ( process_grid_in )) THEN this % process_grid => process_grid_in ELSE this % process_grid => global_grid END IF !! Complex determination IF ( PRESENT ( is_complex_in )) THEN this % is_complex = is_complex_in ELSE this % is_complex = . FALSE . END IF !! Matrix Dimensions this % actual_matrix_dimension = matrix_dim this % logical_matrix_dimension = CalculateScaledDimension ( this , matrix_dim ) !! Full Local Data Size Description this % local_rows = & & this % logical_matrix_dimension / this % process_grid % num_process_rows this % local_columns = & & this % logical_matrix_dimension / this % process_grid % num_process_columns !! Which Block Does This Process Hold? this % start_row = this % local_rows * this % process_grid % my_row + 1 this % end_row = this % start_row + this % local_rows this % start_column = this % local_columns * this % process_grid % my_column + 1 this % end_column = this % start_column + this % local_columns !! Build local storage IF ( this % is_complex ) THEN ALLOCATE ( this % local_data_c ( this % process_grid % number_of_blocks_rows , & & this % process_grid % number_of_blocks_columns )) CALL ConstructEmptyMatrix ( zeromatrix_c , this % local_rows , & & this % local_columns ) CALL SplitMatrixToLocalBlocks ( this , zeromatrix_c ) CALL DestructMatrix ( zeromatrix_c ) ELSE ALLOCATE ( this % local_data_r ( this % process_grid % number_of_blocks_rows , & & this % process_grid % number_of_blocks_columns )) CALL ConstructEmptyMatrix ( zeromatrix_r , this % local_rows , & & this % local_columns ) CALL SplitMatrixToLocalBlocks ( this , zeromatrix_r ) CALL DestructMatrix ( zeromatrix_r ) END IF END SUBROUTINE ConstructEmptyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct an empty sparse, distributed, matrix using another matrix !> to determine the parameters. Note that no data is copied, the matrix !> will be empty. SUBROUTINE ConstructEmptyMatrix_ps_cp ( this , reference_matrix ) !! Parameters !> The matrix to be constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The reference matrix to take parameters from. TYPE ( Matrix_ps ), INTENT ( IN ) :: reference_matrix CALL ConstructEmptyMatrix ( this , reference_matrix % actual_matrix_dimension , & & reference_matrix % process_grid , reference_matrix % is_complex ) END SUBROUTINE ConstructEmptyMatrix_ps_cp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a distributed sparse matrix. PURE SUBROUTINE DestructMatrix_ps ( this ) !> The matrix to destruct. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data INTEGER :: II , JJ IF ( ALLOCATED ( this % local_data_r )) THEN DO II = 1 , SIZE ( this % local_data_r , DIM = 1 ) DO JJ = 1 , SIZE ( this % local_data_r , DIM = 2 ) CALL DestructMatrix ( this % local_data_r ( II , JJ )) END DO END DO DEALLOCATE ( this % local_data_r ) END IF IF ( ALLOCATED ( this % local_data_c )) THEN DO II = 1 , SIZE ( this % local_data_c , DIM = 1 ) DO JJ = 1 , SIZE ( this % local_data_c , DIM = 2 ) CALL DestructMatrix ( this % local_data_c ( II , JJ )) END DO END DO DEALLOCATE ( this % local_data_c ) END IF END SUBROUTINE DestructMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a distributed sparse matrix in a safe way. SUBROUTINE CopyMatrix_ps ( matA , matB ) !> The matrix to copy. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> matB = matA. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matB CALL DestructMatrix ( matB ) matB = matA END SUBROUTINE CopyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> When you want to change the process grid of a matrix, you can call !> this routine with the new process grid value. Data will be automatically !> redistributed. SUBROUTINE SetMatrixProcessGrid ( this , grid ) !> The matrix to set the grid of. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The grid to set it to. TYPE ( ProcessGrid_t ), INTENT ( IN ) :: grid !! Local variables TYPE ( TripletList_r ) :: tlist_r TYPE ( TripletList_c ) :: tlist_c TYPE ( Matrix_ps ) :: new_mat !! Get the data in a triplet list CALL ConstructTripletList ( tlist_c ) CALL ConstructTripletList ( tlist_r ) IF ( this % process_grid % my_slice . EQ . 0 ) THEN IF ( this % is_complex ) THEN CALL GetMatrixTripletList ( this , tlist_c ) ELSE CALL GetMatrixTripletList ( this , tlist_r ) END IF END IF !! Fill The New Matrix CALL ConstructEmptyMatrix ( new_mat , this % actual_matrix_dimension , grid , & & this % is_complex ) IF ( this % is_complex ) THEN CALL FillMatrixFromTripletList ( new_mat , tlist_c ) ELSE CALL FillMatrixFromTripletList ( new_mat , tlist_r ) END IF !! Copy back to finish CALL CopyMatrix ( new_mat , this ) !! Cleanup CALL DestructMatrix ( new_mat ) CALL DestructTripletList ( tlist_c ) CALL DestructTripletList ( tlist_r ) END SUBROUTINE SetMatrixProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct distributed sparse matrix from a matrix market file in parallel. !> Read \\cite boisvert1996matrix for the details. RECURSIVE SUBROUTINE ConstructMatrixFromMatrixMarket_ps ( this , file_name , & & process_grid_in ) !> The file being constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Grid to distribute the matrix on. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: process_grid_in !> The name of the file to read. CHARACTER ( LEN = * ), INTENT ( IN ) :: file_name INTEGER , PARAMETER :: MAX_LINE_LENGTH = 100 !! File Handles INTEGER :: local_file_handler INTEGER :: mpi_file_handler !! About the matrix market file. INTEGER :: sparsity_type , data_type , pattern_type !! Reading The File TYPE ( TripletList_r ) :: tlist_r TYPE ( Triplet_r ) :: temp_triplet_r TYPE ( TripletList_c ) :: tlist_c TYPE ( Triplet_c ) :: temp_triplet_c INTEGER :: matrix_rows , matrix_columns INTEGER ( NTLONG ) :: total_values !! Length Variables INTEGER :: header_length INTEGER ( KIND = MPI_OFFSET_KIND ) :: total_file_size INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_offset INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_data_size INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_data_size_plus_buffer INTEGER :: current_line_length !! Input Buffers CHARACTER ( LEN = MAX_LINE_LENGTH ) :: input_buffer CHARACTER ( LEN = :), ALLOCATABLE :: mpi_input_buffer CHARACTER ( LEN = MAX_LINE_LENGTH ) :: temp_substring !! Temporary Variables REAL ( NTREAL ) :: realval , cval INTEGER :: bytes_per_character LOGICAL :: found_comment_line INTEGER :: message_status ( MPI_STATUS_SIZE ) INTEGER :: full_buffer_counter LOGICAL :: end_of_buffer LOGICAL :: header_success INTEGER :: ierr TYPE ( Error_t ) :: err IF (. NOT . PRESENT ( process_grid_in )) THEN CALL ConstructMatrixFromMatrixMarket ( this , file_name , global_grid ) ELSE CALL ConstructError ( err ) !! Setup Involves Just The Root Opening And Reading Parameter Data CALL MPI_Type_size ( MPI_CHARACTER , bytes_per_character , ierr ) IF ( IsRoot ( process_grid_in )) THEN header_length = 0 local_file_handler = 16 OPEN ( local_file_handler , file = file_name , iostat = ierr , & & status = \"old\" ) IF ( ierr . NE . 0 ) THEN CALL SetGenericError ( err , TRIM ( file_name ) // \" doesn't exist\" , & & . TRUE .) END IF !! Parse the header. READ ( local_file_handler , fmt = '(A)' ) input_buffer header_success = ParseMMHeader ( input_buffer , sparsity_type , & & data_type , pattern_type ) IF (. NOT . header_success ) THEN CALL SetGenericError ( err , \"Invalid File Header\" , . TRUE .) END IF header_length = header_length + LEN_TRIM ( input_buffer ) + 1 !! First Read In The Comment Lines found_comment_line = . TRUE . DO WHILE ( found_comment_line ) READ ( local_file_handler , fmt = '(A)' ) input_buffer !! +1 for newline header_length = header_length + LEN_TRIM ( input_buffer ) + 1 IF (. NOT . input_buffer ( 1 : 1 ) . EQ . '%' ) THEN found_comment_line = . FALSE . END IF END DO !! Get The Matrix Parameters READ ( input_buffer , * ) matrix_rows , matrix_columns , total_values CLOSE ( local_file_handler ) END IF !! Broadcast Parameters CALL MPI_Bcast ( matrix_rows , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( matrix_columns , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( total_values , 1 , MPINTLONG , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( header_length , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( sparsity_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( data_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( pattern_type , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) !! Build Local Storage CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = ( data_type . EQ . MM_COMPLEX )) !! Global read CALL MPI_File_open ( this % process_grid % global_comm , file_name , & & MPI_MODE_RDONLY , MPI_INFO_NULL , mpi_file_handler , ierr ) CALL MPI_File_get_size ( mpi_file_handler , total_file_size , ierr ) !! Compute Offsets And Data Size local_data_size = & & ( total_file_size - bytes_per_character * header_length ) / & & this % process_grid % total_processors IF ( local_data_size . LT . 2 * MAX_LINE_LENGTH ) THEN local_data_size = 2 * MAX_LINE_LENGTH END IF local_offset = bytes_per_character * header_length + & local_data_size * this % process_grid % global_rank !! Check if this processor has any work to do, and set the appropriate !! buffer size. We also add some buffer space, so you can read beyond !! your local data size in case the local data read ends in the middle !! of a line. IF ( local_offset . LT . total_file_size ) THEN local_data_size_plus_buffer = local_data_size + & & MAX_LINE_LENGTH * bytes_per_character IF ( local_offset + local_data_size_plus_buffer . GT . & & total_file_size ) THEN local_data_size_plus_buffer = total_file_size - local_offset END IF IF ( this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN local_data_size_plus_buffer = total_file_size - local_offset END IF ELSE local_data_size_plus_buffer = 0 END IF !! A buffer to read the data into. ALLOCATE ( CHARACTER ( LEN = local_data_size_plus_buffer ) :: & & mpi_input_buffer ) !! Do Actual Reading CALL MPI_File_read_at_all ( mpi_file_handler , local_offset , & & mpi_input_buffer , INT ( local_data_size_plus_buffer ), & & MPI_CHARACTER , message_status , ierr ) !! Trim Off The Half Read Line At The Start IF (. NOT . this % process_grid % global_rank . EQ . & & this % process_grid % RootID ) THEN full_buffer_counter = INDEX ( mpi_input_buffer , new_LINE ( 'A' )) + 1 ELSE full_buffer_counter = 1 END IF !! Read By Line end_of_buffer = . FALSE . IF ( local_data_size_plus_buffer . EQ . 0 ) THEN end_of_buffer = . TRUE . END IF IF ( this % is_complex ) THEN CALL ConstructTripletList ( tlist_c ) ELSE CALL ConstructTripletList ( tlist_r ) END IF DO WHILE (. NOT . end_of_buffer ) current_line_length = INDEX ( mpi_input_buffer ( full_buffer_counter :),& new_LINE ( 'A' )) IF ( current_line_length . EQ . 0 ) THEN !! Hit The End Of The Buffer end_of_buffer = . TRUE . ELSE temp_substring = mpi_input_buffer ( full_buffer_counter : & & full_buffer_counter + current_line_length - 1 ) IF ( current_line_length . GT . 1 ) THEN IF ( data_type . EQ . MM_COMPLEX ) THEN READ ( temp_substring (: current_line_length - 1 ), * ) & & temp_triplet_c % index_row , & & temp_triplet_c % index_column , & & realval , cval temp_triplet_c % point_value = & & CMPLX ( realval , cval , KIND = NTCOMPLEX ) CALL AppendToTripletList ( tlist_c , temp_triplet_c ) ELSE READ ( temp_substring (: current_line_length - 1 ), * ) & & temp_triplet_r % index_row , & & temp_triplet_r % index_column , & & temp_triplet_r % point_value CALL AppendToTripletList ( tlist_r , temp_triplet_r ) END IF END IF IF ( full_buffer_counter + current_line_length . GE . & & local_data_size + 2 ) THEN IF (. NOT . this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN end_of_buffer = . TRUE . END IF END IF full_buffer_counter = full_buffer_counter + current_line_length END IF END DO !! Cleanup CALL MPI_File_close ( mpi_file_handler , ierr ) CALL MPI_Barrier ( this % process_grid % global_comm , ierr ) !! Redistribute The Matrix IF ( this % is_complex ) THEN CALL SymmetrizeTripletList ( tlist_c , pattern_type ) CALL FillMatrixFromTripletList ( this , tlist_c ) CALL DestructTripletList ( tlist_c ) ELSE CALL SymmetrizeTripletList ( tlist_r , pattern_type ) CALL FillMatrixFromTripletList ( this , tlist_r ) CALL DestructTripletList ( tlist_r ) END IF DEALLOCATE ( mpi_input_buffer ) END IF END SUBROUTINE ConstructMatrixFromMatrixMarket_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a distributed sparse matrix from a binary file in parallel. !> Faster than text, so this is good for check pointing. RECURSIVE SUBROUTINE ConstructMatrixFromBinary_ps ( this , file_name , & & process_grid_in ) !> The file being constructed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Grid to distribute the matrix on. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: process_grid_in !> The name of the file to read. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data INTEGER :: triplet_mpi_type TYPE ( TripletList_r ) :: tlist_r TYPE ( TripletList_c ) :: tlist_c !! File Handles INTEGER :: mpi_file_handler !! Reading The File INTEGER :: matrix_rows , matrix_columns , complex_flag INTEGER ( NTLONG ) :: total_values INTEGER , DIMENSION ( 3 ) :: matrix_information INTEGER :: local_triplets INTEGER ( KIND = MPI_OFFSET_KIND ) :: local_offset INTEGER ( KIND = MPI_OFFSET_KIND ) :: header_size INTEGER :: bytes_per_int , bytes_per_data , bytes_per_long !! Temporary variables INTEGER :: message_status ( MPI_STATUS_SIZE ) INTEGER :: ierr TYPE ( Error_t ) :: err LOGICAL :: error_occured IF (. NOT . PRESENT ( process_grid_in )) THEN CALL ConstructMatrixFromBinary ( this , file_name , global_grid ) ELSE CALL ConstructError ( err ) CALL MPI_File_open ( process_grid_in % global_comm , file_name , & & MPI_MODE_RDONLY , MPI_INFO_NULL , mpi_file_handler , ierr ) error_occured = CheckMPIError ( err , TRIM ( file_name ) // \" doesn't exist\" , & & ierr , . TRUE .) !! General Sizes CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) CALL MPI_Type_extent ( MPINTLONG , bytes_per_long , ierr ) !! Get The Matrix Parameters IF ( IsRoot ( process_grid_in )) THEN local_offset = 0 CALL MPI_File_read_at ( mpi_file_handler , local_offset , & & matrix_information , 3 , MPINTINTEGER , message_status , ierr ) matrix_rows = matrix_information ( 1 ) matrix_columns = matrix_information ( 2 ) complex_flag = matrix_information ( 3 ) local_offset = 3 * bytes_per_int CALL MPI_File_read_at ( mpi_file_handler , local_offset , & & total_values , 1 , MPINTLONG , message_status , ierr ) END IF !! Broadcast Parameters CALL MPI_Bcast ( matrix_rows , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( matrix_columns , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( total_values , 1 , MPINTLONG , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) CALL MPI_Bcast ( complex_flag , 1 , MPINTINTEGER , process_grid_in % RootID , & & process_grid_in % global_comm , ierr ) !! Build Local Storage IF ( complex_flag . EQ . 1 ) THEN CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = . TRUE .) ELSE CALL ConstructEmptyMatrix ( this , matrix_rows , process_grid_in , & & is_complex_in = . FALSE .) END IF !! Sizes specific to the type IF ( this % is_complex ) THEN CALL MPI_Type_extent ( MPINTCOMPLEX , bytes_per_data , ierr ) triplet_mpi_type = GetMPITripletType_c () ELSE CALL MPI_Type_extent ( MPINTREAL , bytes_per_data , ierr ) triplet_mpi_type = GetMPITripletType_r () END IF !! Compute Offset local_triplets = total_values / this % process_grid % total_processors local_offset = local_triplets * this % process_grid % global_rank header_size = 3 * bytes_per_int + bytes_per_long IF ( this % process_grid % global_rank . EQ . & & this % process_grid % total_processors - 1 ) THEN local_triplets = INT ( total_values ) - INT ( local_offset ) END IF local_offset = local_offset * ( bytes_per_int * 2 + bytes_per_data ) + & & header_size !! Do The Actual Reading CALL MPI_File_set_view ( mpi_file_handler , local_offset , & & triplet_mpi_type , triplet_mpi_type , \"native\" , MPI_INFO_NULL , & & ierr ) IF ( this % is_complex ) THEN CALL ConstructTripletList ( tlist_c , local_triplets ) CALL MPI_File_read_all ( mpi_file_handler , tlist_c % DATA , & & local_triplets , triplet_mpi_type , message_status , ierr ) ELSE CALL ConstructTripletList ( tlist_r , local_triplets ) CALL MPI_File_read_all ( mpi_file_handler , tlist_r % DATA , & & local_triplets , triplet_mpi_type , message_status , ierr ) END IF CALL MPI_File_close ( mpi_file_handler , ierr ) IF ( this % is_complex ) THEN CALL FillMatrixFromTripletList ( this , tlist_c ) CALL DestructTripletList ( tlist_c ) ELSE CALL FillMatrixFromTripletList ( this , tlist_r ) CALL DestructTripletList ( tlist_r ) END IF END IF END SUBROUTINE ConstructMatrixFromBinary_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Save a distributed sparse matrix to a binary file. !> Faster than text, so this is good for check pointing. SUBROUTINE WriteMatrixToBinary_ps ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data INTEGER :: triplet_mpi_type IF ( this % is_complex ) THEN triplet_mpi_type = GetMPITripletType_c () CALL WriteMatrixToBinary_psc ( this , file_name , triplet_mpi_type ) ELSE triplet_mpi_type = GetMPITripletType_r () CALL WriteMatrixToBinary_psr ( this , file_name , triplet_mpi_type ) END IF END SUBROUTINE WriteMatrixToBinary_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implementation of write to binary. SUBROUTINE WriteMatrixToBinary_psr ( this , file_name , triplet_mpi_type ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !> The triplet type, which distinguishes real and complex triplets. INTEGER , INTENT ( IN ) :: triplet_mpi_type !! Local Data TYPE ( TripletList_r ) :: tlist TYPE ( Matrix_lsr ) :: merged_local_data #include \"distributed_includes/WriteMatrixToBinary.f90\" END SUBROUTINE WriteMatrixToBinary_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implementation of write to binary. SUBROUTINE WriteMatrixToBinary_psc ( this , file_name , triplet_mpi_type ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !> The triplet type, which distinguishes real and complex triplets. INTEGER , INTENT ( IN ) :: triplet_mpi_type !! Local Data TYPE ( TripletList_c ) :: tlist TYPE ( Matrix_lsc ) :: merged_local_data #include \"distributed_includes/WriteMatrixToBinary.f90\" END SUBROUTINE WriteMatrixToBinary_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write a distributed sparse matrix to a matrix market file. !> Read \\cite boisvert1996matrix for the details. SUBROUTINE WriteMatrixToMatrixMarket_ps ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name IF ( this % is_complex ) THEN CALL WriteMatrixToMatrixMarket_psc ( this , file_name ) ELSE CALL WriteMatrixToMatrixMarket_psr ( this , file_name ) END IF END SUBROUTINE WriteMatrixToMatrixMarket_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write to matrix market implementation for real data. SUBROUTINE WriteMatrixToMatrixMarket_psr ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data TYPE ( TripletList_r ) :: tlist TYPE ( Matrix_lsr ) :: merged_local_data #include \"distributed_includes/WriteToMatrixMarket.f90\" END SUBROUTINE WriteMatrixToMatrixMarket_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write to matrix market implementation for complex data. SUBROUTINE WriteMatrixToMatrixMarket_psc ( this , file_name ) !> The Matrix to write. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The name of the file to write to. CHARACTER ( len =* ), INTENT ( IN ) :: file_name !! Local Data TYPE ( TripletList_c ) :: tlist TYPE ( Matrix_lsc ) :: merged_local_data #define ISCOMPLEX #include \"distributed_includes/WriteToMatrixMarket.f90\" #undef ISCOMPLEX END SUBROUTINE WriteMatrixToMatrixMarket_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine fills in a matrix based on local triplet lists. Each process !> should pass in triplet lists with global coordinates. It does not matter !> where each triplet is stored, as long as global coordinates are given. !> However, if you explicitly set prepartitioned_in to True, all data must be !> on the correct process. In that case, there is no communication required. SUBROUTINE FillMatrixFromTripletList_psr ( this , triplet_list , & & preduplicated_in , prepartitioned_in ) !> The matrix to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The triplet list of values. TYPE ( TripletList_r ), INTENT ( IN ) :: triplet_list !> If lists are preduplicated across slices set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: preduplicated_in !> If all lists only contain local matrix elements set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: prepartitioned_in !! Local Data TYPE ( Matrix_ps ) :: temp_matrix TYPE ( TripletList_r ) :: shifted TYPE ( TripletList_r ) :: sorted_tlist TYPE ( Matrix_lsr ) :: local_matrix TYPE ( Matrix_lsr ) :: gathered_matrix !! Local Data TYPE ( Permutation_t ) :: basic_permutation REAL ( NTREAL ), PARAMETER :: threshold = 0.0_NTREAL LOGICAL :: preduplicated LOGICAL :: prepartitioned IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , temp_matrix ) CALL CopyMatrix ( temp_matrix , this ) CALL DestructMatrix ( temp_matrix ) END IF #include \"distributed_includes/FillMatrixFromTripletList.f90\" END SUBROUTINE FillMatrixFromTripletList_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine fills in a matrix based on local triplet lists. Each process !> should pass in triplet lists with global coordinates. It does not matter !> where each triplet is stored, as long as global coordinates are given. !> However, if you explicitly set prepartitioned_in to True, all data must be !> on the correct process. In that case, there is no communication required. SUBROUTINE FillMatrixFromTripletList_psc ( this , triplet_list , & & preduplicated_in , prepartitioned_in ) !> The matrix to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The triplet list of values. TYPE ( TripletList_c ), INTENT ( IN ) :: triplet_list !> If lists are preduplicated across slices set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: preduplicated_in !> If all lists only contain local matrix elements set this to true. LOGICAL , INTENT ( IN ), OPTIONAL :: prepartitioned_in !! Local Data TYPE ( TripletList_c ) :: shifted TYPE ( TripletList_c ) :: sorted_tlist TYPE ( Matrix_lsc ) :: local_matrix TYPE ( Matrix_lsc ) :: gathered_matrix !! Local Data TYPE ( Matrix_ps ) :: temp_matrix TYPE ( Permutation_t ) :: basic_permutation REAL ( NTREAL ), PARAMETER :: threshold = 0.0_NTREAL LOGICAL :: preduplicated LOGICAL :: prepartitioned IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , temp_matrix ) CALL CopyMatrix ( temp_matrix , this ) CALL DestructMatrix ( temp_matrix ) END IF #include \"distributed_includes/FillMatrixFromTripletList.f90\" END SUBROUTINE FillMatrixFromTripletList_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_ps ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this IF ( this % is_complex ) THEN CALL FillMatrixIdentity_psc ( this ) ELSE CALL FillMatrixIdentity_psr ( this ) END IF END SUBROUTINE FillMatrixIdentity_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_psr ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_r ) :: tlist #include \"distributed_includes/FillMatrixIdentity.f90\" END SUBROUTINE FillMatrixIdentity_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with the identity matrix. SUBROUTINE FillMatrixIdentity_psc ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_c ) :: tlist #include \"distributed_includes/FillMatrixIdentity.f90\" END SUBROUTINE FillMatrixIdentity_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill in the values of a distributed matrix with a permutation. !> If you do not specify permuterows, will default to permuting rows. SUBROUTINE FillMatrixPermutation_ps ( this , permutation_vector , permute_rows_in ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , OPTIONAL , INTENT ( IN ) :: permute_rows_in !! Local Data LOGICAL :: permute_rows !! Figure out what type of permutation IF ( PRESENT ( permute_rows_in ) . AND . permute_rows_in . EQV . . FALSE .) THEN permute_rows = . FALSE . ELSE permute_rows = . TRUE . END IF IF ( this % is_complex ) THEN CALL FillMatrixPermutation_psc ( this , permutation_vector , permute_rows ) ELSE CALL FillMatrixPermutation_psr ( this , permutation_vector , permute_rows ) END IF END SUBROUTINE FillMatrixPermutation_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill permutation implementation. SUBROUTINE FillMatrixPermutation_psr ( this , permutation_vector , rows ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , INTENT ( IN ) :: rows !! Local Data TYPE ( TripletList_r ) :: tlist #include \"distributed_includes/FillMatrixPermutation.f90\" END SUBROUTINE FillMatrixPermutation_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill permutation implementation. SUBROUTINE FillMatrixPermutation_psc ( this , permutation_vector , rows ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Describes for each row/column, where it goes. INTEGER , DIMENSION (:), INTENT ( IN ) :: permutation_vector !> If true permute rows, false permute columns. LOGICAL , INTENT ( IN ) :: rows !! Local Data TYPE ( TripletList_c ) :: tlist #include \"distributed_includes/FillMatrixPermutation.f90\" END SUBROUTINE FillMatrixPermutation_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine will fill a dense matrix so that every element has a given !! a value of 1. This is useful as a starting point for further filtering !! or mapping operations. SUBROUTINE FillMatrixDense_ps ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this IF ( this % is_complex ) THEN CALL FillMatrixDense_psc ( this ) ELSE CALL FillMatrixDense_psr ( this ) END IF END SUBROUTINE FillMatrixDense_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill dense implementation (real). SUBROUTINE FillMatrixDense_psr ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_r ) :: tlist #include \"distributed_includes/FillMatrixDense.f90\" END SUBROUTINE FillMatrixDense_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Fill dense implementation (complex). SUBROUTINE FillMatrixDense_psc ( this ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Data TYPE ( TripletList_c ) :: tlist #include \"distributed_includes/FillMatrixDense.f90\" END SUBROUTINE FillMatrixDense_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extracts a triplet list of the data that is stored on this process. !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixTripletList_psr ( this , triplet_list ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsr ) :: merged_local_data IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #include \"distributed_includes/GetMatrixTripletList.f90\" END SUBROUTINE GetMatrixTripletList_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extracts a triplet list of the data that is stored on this process. !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixTripletList_psc ( this , triplet_list ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsc ) :: merged_local_data IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #include \"distributed_includes/GetMatrixTripletList.f90\" END SUBROUTINE GetMatrixTripletList_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract an arbitrary block of a matrix into a triplet list. Block is !> defined by the row/column start/end values. !> This is slower than GetMatrixTripletList, because communication is required !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixBlock_psr ( this , triplet_list , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_r ), INTENT ( INOUT ) :: triplet_list !> The starting row for data to store on this process. INTEGER , INTENT ( IN ) :: start_row !> The ending row for data to store on this process. INTEGER , INTENT ( IN ) :: end_row !> The starting col for data to store on this process INTEGER , INTENT ( IN ) :: start_column !> The ending col for data to store on this process INTEGER , INTENT ( IN ) :: end_column !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsr ) :: merged_local_data TYPE ( TripletList_r ) :: local_triplet_list !! Send Buffer REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: send_buffer_val !! Receive Buffer REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val !! Temp Values TYPE ( Triplet_r ) :: temp_triplet !! Local Data INTEGER , DIMENSION (:), ALLOCATABLE :: row_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: row_end_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_end_list !! Send Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: send_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_col !! Receive Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: recv_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_col !! Temporary INTEGER :: II , PP INTEGER :: ierr IF ( this % is_complex ) THEN CALL ConvertMatrixToReal ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #define MPIDATATYPE MPINTREAL #include \"distributed_includes/GetMatrixBlock.f90\" #undef MPIDATATYPE END SUBROUTINE GetMatrixBlock_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Extract an arbitrary block of a matrix into a triplet list. Block is !> defined by the row/column start/end values. !> This is slower than GetMatrixTripletList, because communication is required !> Data is returned with absolute coordinates. SUBROUTINE GetMatrixBlock_psc ( this , triplet_list , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The list to fill. TYPE ( TripletList_c ), INTENT ( INOUT ) :: triplet_list !> The starting row for data to store on this process. INTEGER , INTENT ( IN ) :: start_row !> The ending row for data to store on this process. INTEGER , INTENT ( IN ) :: end_row !> The starting col for data to store on this process INTEGER , INTENT ( IN ) :: start_column !> The ending col for data to store on this process INTEGER , INTENT ( IN ) :: end_column !! Local Data TYPE ( Matrix_ps ) :: working_matrix TYPE ( Matrix_lsc ) :: merged_local_data TYPE ( TripletList_c ) :: local_triplet_list !! Send Buffer COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: send_buffer_val !! Receive Buffer COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: recv_buffer_val !! Temp Values TYPE ( Triplet_c ) :: temp_triplet !! Local Data INTEGER , DIMENSION (:), ALLOCATABLE :: row_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_start_list INTEGER , DIMENSION (:), ALLOCATABLE :: row_end_list INTEGER , DIMENSION (:), ALLOCATABLE :: column_end_list !! Send Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: send_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: send_buffer_col !! Receive Buffer INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_offsets INTEGER , DIMENSION (:), ALLOCATABLE :: recv_per_proc INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_row INTEGER , DIMENSION (:), ALLOCATABLE :: recv_buffer_col !! Temporary INTEGER :: II , PP INTEGER :: ierr IF (. NOT . this % is_complex ) THEN CALL ConvertMatrixToComplex ( this , working_matrix ) ELSE CALL CopyMatrix ( this , working_matrix ) END IF #define MPIDATATYPE MPINTCOMPLEX #include \"distributed_includes/GetMatrixBlock.f90\" #undef MPIDATATYPE END SUBROUTINE GetMatrixBlock_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy an arbitrary slice from a matrix into a new smaller matrix. !> NTPoly only works with square matrices, so if the number of rows and !> columns is different the matrix is resized to the maximum size. SUBROUTINE GetMatrixSlice ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER , INTENT ( IN ) :: start_row !> The ending row to include in this matrix. INTEGER , INTENT ( IN ) :: end_row !> The starting column to include in this matrix. INTEGER , INTENT ( IN ) :: start_column !> The last column to include in this matrix. INTEGER , INTENT ( IN ) :: end_column !! Get a triplet list with the values IF ( this % is_complex ) THEN CALL GetMatrixSlice_psc ( this , submatrix , start_row , end_row , & & start_column , end_column ) ELSE CALL GetMatrixSlice_psr ( this , submatrix , start_row , end_row , & & start_column , end_column ) END IF END SUBROUTINE GetMatrixSlice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implements slice matrix for real types. SUBROUTINE GetMatrixSlice_psr ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER , INTENT ( IN ) :: start_row !> The ending row to include in this matrix. INTEGER , INTENT ( IN ) :: end_row !> The starting column to include in this matrix. INTEGER , INTENT ( IN ) :: start_column !> The last column to include in this matrix. INTEGER , INTENT ( IN ) :: end_column #define TLISTTYPE TripletList_r #define TTYPE Triplet_r #include \"distributed_includes/SliceMatrix.f90\" #undef TLISTTYPE #undef TTYPE END SUBROUTINE GetMatrixSlice_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Implements slice matrix for complex types. SUBROUTINE GetMatrixSlice_psc ( this , submatrix , start_row , end_row , & & start_column , end_column ) !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The slice to fill. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: submatrix !> The starting row to include in this matrix. INTEGER , INTENT ( IN ) :: start_row !> The ending row to include in this matrix. INTEGER , INTENT ( IN ) :: end_row !> The starting column to include in this matrix. INTEGER , INTENT ( IN ) :: start_column !> The last column to include in this matrix. INTEGER , INTENT ( IN ) :: end_column #define TLISTTYPE TripletList_c #define TTYPE Triplet_c #include \"distributed_includes/SliceMatrix.f90\" #undef TLISTTYPE #undef TTYPE END SUBROUTINE GetMatrixSlice_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the actual dimension of the matrix. PURE FUNCTION GetMatrixActualDimension_ps ( this ) RESULT ( DIMENSION ) !> The matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Dimension of the matrix INTEGER :: DIMENSION DIMENSION = this % actual_matrix_dimension END FUNCTION GetMatrixActualDimension_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the logical dimension of the matrix. !> Includes padding. PURE FUNCTION GetMatrixLogicalDimension_ps ( this ) RESULT ( DIMENSION ) !> The matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Dimension of the matrix INTEGER :: DIMENSION DIMENSION = this % logical_matrix_dimension END FUNCTION GetMatrixLogicalDimension_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out information about a distributed sparse matrix. !> Sparsity, and load balancing information. SUBROUTINE PrintMatrixInformation_ps ( this ) !> This the matrix to print information about. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !! Local Data INTEGER :: min_size , max_size REAL ( NTREAL ) :: sparsity CALL GetMatrixLoadBalance ( this , min_size , max_size ) sparsity = REAL ( GetMatrixSize ( this ), KIND = NTREAL ) / & & ( REAL ( this % actual_matrix_dimension , KIND = NTREAL ) ** 2 ) CALL WriteHeader ( \"Load_Balance\" ) CALL EnterSubLog CALL WriteListElement ( key = \"min_size\" , VALUE = min_size ) CALL WriteListElement ( key = \"max_size\" , VALUE = max_size ) CALL ExitSubLog CALL WriteElement ( key = \"Dimension\" , VALUE = this % actual_matrix_dimension ) CALL WriteElement ( key = \"Sparsity\" , VALUE = sparsity ) END SUBROUTINE PrintMatrixInformation_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out a distributed sparse matrix. !> This is a serial print routine, and should probably only be used for debug !> purposes. SUBROUTINE PrintMatrix_ps ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in IF ( this % is_complex ) THEN IF ( PRESENT ( file_name_in )) THEN CALL PrintMatrix_psc ( this , file_name_in ) ELSE CALL PrintMatrix_psc ( this ) END IF ELSE IF ( PRESENT ( file_name_in )) THEN CALL PrintMatrix_psr ( this , file_name_in ) ELSE CALL PrintMatrix_psr ( this ) END IF END IF END SUBROUTINE PrintMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print matrix implementation (real). SUBROUTINE PrintMatrix_psr ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Temporary Variables TYPE ( Matrix_lsr ) :: local_mat #include \"distributed_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print matrix implementation (complex). SUBROUTINE PrintMatrix_psc ( this , file_name_in ) !> The matrix to print. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Optionally, you can pass a file to print to instead of the console. CHARACTER ( len =* ), OPTIONAL , INTENT ( IN ) :: file_name_in !! Temporary Variables TYPE ( Matrix_lsc ) :: local_mat #include \"distributed_includes/PrintMatrix.f90\" END SUBROUTINE PrintMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A utility routine that filters a sparse matrix. !> All (absolute) values below the threshold are set to zero. SUBROUTINE FilterMatrix_ps ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold IF ( this % is_complex ) THEN CALL FilterMatrix_psc ( this , threshold ) ELSE CALL FilterMatrix_psr ( this , threshold ) END IF END SUBROUTINE FilterMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Filter matrix implementation (real). SUBROUTINE FilterMatrix_psr ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Variables TYPE ( TripletList_r ) :: tlist TYPE ( TripletList_r ) :: new_list TYPE ( Triplet_r ) :: trip #include \"distributed_includes/FilterMatrix.f90\" END SUBROUTINE FilterMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Filter matrix implementation (real). SUBROUTINE FilterMatrix_psc ( this , threshold ) !> The matrix to filter. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Threshold (absolute) values below this are filtered REAL ( NTREAL ), INTENT ( IN ) :: threshold !! Local Variables TYPE ( TripletList_c ) :: tlist TYPE ( TripletList_c ) :: new_list TYPE ( Triplet_c ) :: trip #include \"distributed_includes/FilterMatrix.f90\" END SUBROUTINE FilterMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the total number of non-zero entries in the distributed sparse matrix. FUNCTION GetMatrixSize_ps ( this ) RESULT ( total_size ) !> The matrix to calculate the number of non-zero entries of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The number of non-zero entries in the matrix. INTEGER ( NTLONG ) :: total_size !! Local Data REAL ( NTREAL ) :: local_size REAL ( NTREAL ) :: temp_size TYPE ( Matrix_lsc ) :: merged_local_data_c TYPE ( Matrix_lsr ) :: merged_local_data_r INTEGER :: ierr !! Merge all the local data IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , merged_local_data_c ) local_size = SIZE ( merged_local_data_c % values ) CALL DestructMatrix ( merged_local_data_c ) ELSE CALL MergeMatrixLocalBlocks ( this , merged_local_data_r ) local_size = SIZE ( merged_local_data_r % values ) CALL DestructMatrix ( merged_local_data_r ) END IF !! Global Sum CALL MPI_Allreduce ( local_size , temp_size , 1 , MPINTREAL , MPI_SUM , & & this % process_grid % within_slice_comm , ierr ) total_size = INT ( temp_size , KIND = NTLONG ) END FUNCTION GetMatrixSize_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get a measure of how load balanced this matrix is. For each process, the !> number of non-zero entries is calculated. Then, this function returns !> the max and min of those values. SUBROUTINE GetMatrixLoadBalance_ps ( this , min_size , max_size ) !> The matrix to compute the measure on. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The minimum entries contained on a single process. INTEGER , INTENT ( OUT ) :: min_size !> The maximum entries contained on a single process. INTEGER , INTENT ( OUT ) :: max_size !! Local Data INTEGER :: local_size TYPE ( Matrix_lsc ) :: merged_local_data_c TYPE ( Matrix_lsr ) :: merged_local_data_r INTEGER :: ierr !! Merge all the local data IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , merged_local_data_c ) local_size = SIZE ( merged_local_data_c % values ) CALL DestructMatrix ( merged_local_data_c ) ELSE CALL MergeMatrixLocalBlocks ( this , merged_local_data_r ) local_size = SIZE ( merged_local_data_r % values ) CALL DestructMatrix ( merged_local_data_r ) END IF !! Global Reduce CALL MPI_Allreduce ( local_size , max_size , 1 , MPINTINTEGER , MPI_MAX ,& & this % process_grid % within_slice_comm , ierr ) CALL MPI_Allreduce ( local_size , min_size , 1 , MPINTINTEGER , MPI_MIN ,& & this % process_grid % within_slice_comm , ierr ) END SUBROUTINE GetMatrixLoadBalance_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose a sparse matrix. Note that this is a pure transpose, there is !> no complex conjugate performed. SUBROUTINE TransposeMatrix_ps ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( INOUT ) :: TransMat IF ( AMat % is_complex ) THEN CALL TransposeMatrix_psc ( AMat , TransMat ) ELSE CALL TransposeMatrix_psr ( AMat , TransMat ) END IF END SUBROUTINE TransposeMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose implementation (real). SUBROUTINE TransposeMatrix_psr ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( INOUT ) :: TransMat !! Local Variables TYPE ( TripletList_r ) :: tlist TYPE ( TripletList_r ) :: new_list TYPE ( Triplet_r ) :: trip , trip_t #include \"distributed_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transpose implementation (complex). SUBROUTINE TransposeMatrix_psc ( AMat , TransMat ) !> The matrix to transpose. TYPE ( Matrix_ps ), INTENT ( IN ) :: AMat !> TransMat = A&#94;T . TYPE ( Matrix_ps ), INTENT ( INOUT ) :: TransMat !! Local Variables TYPE ( TripletList_c ) :: tlist TYPE ( TripletList_c ) :: new_list TYPE ( Triplet_c ) :: trip , trip_t #include \"distributed_includes/TransposeMatrix.f90\" END SUBROUTINE TransposeMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Every value in the matrix is changed into its complex conjugate. PURE SUBROUTINE ConjugateMatrix_ps ( this ) !> The matrix to compute the complex conjugate of. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !! Local Variables TYPE ( Matrix_lsc ) :: local_matrix IF ( this % is_complex ) THEN CALL MergeMatrixLocalBlocks ( this , local_matrix ) CALL ConjugateMatrix ( local_matrix ) CALL SplitMatrixToLocalBlocks ( this , local_matrix ) CALL DestructMatrix ( local_matrix ) END IF END SUBROUTINE ConjugateMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split the current communicator, and give each group a complete copy of this SUBROUTINE CommSplitMatrix_ps ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True LOGICAL , INTENT ( OUT ) :: split_slice IF ( this % is_complex ) THEN CALL CommSplitMatrix_psc ( this , split_mat , my_color , split_slice ) ELSE CALL CommSplitMatrix_psr ( this , split_mat , my_color , split_slice ) END IF END SUBROUTINE CommSplitMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split implementation for real data. SUBROUTINE CommSplitMatrix_psr ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True. LOGICAL , INTENT ( OUT ) :: split_slice !! For Data Redistribution TYPE ( TripletList_r ) :: full_list , new_list TYPE ( TripletList_r ), DIMENSION (:), ALLOCATABLE :: send_list #include \"distributed_includes/CommSplitMatrix.f90\" END SUBROUTINE CommSplitMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Split implementation for complex data. SUBROUTINE CommSplitMatrix_psc ( this , split_mat , my_color , split_slice ) !> The matrix to split. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A copy of the matrix hosted on a small process grid. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: split_mat !> Distinguishes between the two groups. INTEGER , INTENT ( OUT ) :: my_color !> If we split along the slice direction, this is True. LOGICAL , INTENT ( OUT ) :: split_slice !! For Data Redistribution TYPE ( TripletList_c ) :: full_list , new_list TYPE ( TripletList_c ), DIMENSION (:), ALLOCATABLE :: send_list #include \"distributed_includes/CommSplitMatrix.f90\" END SUBROUTINE CommSplitMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute the data in a matrix based on row, column list !> This will redistribute the data so that the local data are entries in !> the rows and columns list. The order of the row list and column list matter !> because local data is filled in the same order. SUBROUTINE RedistributeData_psr ( this , index_lookup , reverse_index_lookup ,& & initial_triplet_list , sorted_triplet_list ) !> The matrix to redistribute TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: index_lookup !> Reverse Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: reverse_index_lookup !> The current triplet list of global coordinates. TYPE ( TripletList_r ), INTENT ( IN ) :: initial_triplet_list !> returns an allocated triplet list with local coordinates in sorted order. TYPE ( TripletList_r ), INTENT ( OUT ) :: sorted_triplet_list !! Local Data TYPE ( TripletList_r ) :: gathered_list TYPE ( TripletList_r ), DIMENSION ( this % process_grid % slice_size ) :: & & send_triplet_lists TYPE ( Triplet_r ) :: temp_triplet #include \"distributed_includes/RedistributeData.f90\" END SUBROUTINE RedistributeData_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Redistribute the data in a matrix based on row, column list !> This will redistribute the data so that the local data are entries in !> the rows and columns list. The order of the row list and column list matter !> because local data is filled in the same order. SUBROUTINE RedistributeData_psc ( this , index_lookup , reverse_index_lookup ,& & initial_triplet_list , sorted_triplet_list ) !> The matrix to redistribute TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: index_lookup !> Reverse Lookup describing how data is distributed. INTEGER , DIMENSION (:), INTENT ( IN ) :: reverse_index_lookup !> The current triplet list of global coordinates. TYPE ( TripletList_c ), INTENT ( IN ) :: initial_triplet_list !> returns an allocated triplet list with local coordinates in sorted order. TYPE ( TripletList_c ), INTENT ( OUT ) :: sorted_triplet_list !! Local Data TYPE ( TripletList_c ) :: gathered_list TYPE ( TripletList_c ), DIMENSION ( this % process_grid % slice_size ) :: & & send_triplet_lists TYPE ( Triplet_c ) :: temp_triplet #include \"distributed_includes/RedistributeData.f90\" END SUBROUTINE RedistributeData_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Calculate a matrix size that can be divided by the number of processors. PURE FUNCTION CalculateScaledDimension ( this , matrix_dim ) RESULT ( scaled_dim ) !> The matrix we are calculating for. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The dimension of the actual matrix. INTEGER , INTENT ( IN ) :: matrix_dim !> A new dimension which includes padding. INTEGER :: scaled_dim !! Local Data INTEGER :: size_ratio INTEGER :: lcm lcm = this % process_grid % block_multiplier * & & this % process_grid % num_process_slices * & & this % process_grid % num_process_columns * & & this % process_grid % num_process_rows size_ratio = matrix_dim / lcm IF ( size_ratio * lcm . EQ . matrix_dim ) THEN scaled_dim = matrix_dim ELSE scaled_dim = ( size_ratio + 1 ) * lcm END IF END FUNCTION CalculateScaledDimension !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take a local matrix, and use it to fill the local block matrix structure. PURE SUBROUTINE SplitMatrixToLocalBlocks_psr ( this , matrix_to_split ) !> The distributed sparse matrix to split into. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The matrix to split up. TYPE ( Matrix_lsr ), INTENT ( IN ) :: matrix_to_split #define LOCALMATRIX this%local_data_r #include \"distributed_includes/SplitMatrixToLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE SplitMatrixToLocalBlocks_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Take a local matrix, and use it to fill the local block matrix structure. PURE SUBROUTINE SplitMatrixToLocalBlocks_psc ( this , matrix_to_split ) !> The distributed sparse matrix to split into. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The matrix to split up. TYPE ( Matrix_lsc ), INTENT ( IN ) :: matrix_to_split #define LOCALMATRIX this%local_data_c #include \"distributed_includes/SplitMatrixToLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE SplitMatrixToLocalBlocks_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Merge together the local matrix blocks into one big matrix. PURE SUBROUTINE MergeMatrixLocalBlocks_psr ( this , merged_matrix ) !> The distributed sparse matrix to merge from. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The merged matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: merged_matrix #define LOCALMATRIX this%local_data_r #include \"distributed_includes/MergeMatrixLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE MergeMatrixLocalBlocks_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Merge together the local matrix blocks into one big matrix. PURE SUBROUTINE MergeMatrixLocalBlocks_psc ( this , merged_matrix ) !> The distributed sparse matrix to merge from. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The merged matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: merged_matrix #define LOCALMATRIX this%local_data_c #include \"distributed_includes/MergeMatrixLocalBlocks.f90\" #undef LOCALMATRIX END SUBROUTINE MergeMatrixLocalBlocks_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the current matrix to a real type matrix. SUBROUTINE ConvertMatrixToReal ( in , out ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: in !> Real version of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: out LOGICAL , PARAMETER :: convert_to_complex = . FALSE . !! Local Variables TYPE ( Matrix_lsc ) :: local_matrix TYPE ( Matrix_lsr ) :: converted_matrix #include \"distributed_includes/ConvertMatrixType.f90\" END SUBROUTINE ConvertMatrixToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the current matrix to a complex type matrix. SUBROUTINE ConvertMatrixToComplex ( in , out ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: in !> Complex version of the matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: out LOGICAL , PARAMETER :: convert_to_complex = . TRUE . !! Local Variables TYPE ( Matrix_lsr ) :: local_matrix TYPE ( Matrix_lsc ) :: converted_matrix #include \"distributed_includes/ConvertMatrixType.f90\" END SUBROUTINE ConvertMatrixToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix. !> If the new size is smaller, then values outside that range are deleted. !> IF the new size is bigger, zero padding is applied. !> Warning: this requires a full data redistribution. SUBROUTINE ResizeMatrix ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size IF ( this % is_complex ) THEN CALL ResizeMatrix_psc ( this , new_size ) ELSE CALL ResizeMatrix_psr ( this , new_size ) END IF END SUBROUTINE ResizeMatrix !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix implementation (real). SUBROUTINE ResizeMatrix_psr ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size !! Local Variables TYPE ( TripletList_r ) :: tlist , pruned TYPE ( Triplet_r ) :: temp #include \"distributed_includes/ResizeMatrix.f90\" END SUBROUTINE ResizeMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Change the size of a matrix implementation (real). SUBROUTINE ResizeMatrix_psc ( this , new_size ) !> The matrix to resize. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> The new size of the matrix. INTEGER , INTENT ( IN ) :: new_size !! Local Variables TYPE ( TripletList_c ) :: tlist , pruned TYPE ( Triplet_c ) :: temp #include \"distributed_includes/ResizeMatrix.f90\" END SUBROUTINE ResizeMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on the !> given process. The process id is a within_slice id, so the data will !> still be replicated across slices. SUBROUTINE GatherMatrixToProcess_psr_id ( this , local_mat , within_slice_id ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: local_mat !> Which process to gather on. INTEGER , INTENT ( IN ) :: within_slice_id !! Local Variables TYPE ( TripletList_r ) :: tlist , sorted TYPE ( TripletList_r ), DIMENSION (:), ALLOCATABLE :: slist #include \"distributed_includes/GatherMatrixToProcess.f90\" END SUBROUTINE GatherMatrixToProcess_psr_id !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on to !> every process. SUBROUTINE GatherMatrixToProcess_psr_all ( this , local_mat ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsr ), INTENT ( INOUT ) :: local_mat !! Local Variables TYPE ( Matrix_lsr ) :: local , localT TYPE ( Matrix_lsr ) :: merged_columns TYPE ( Matrix_lsr ) :: merged_columnsT TYPE ( Matrix_lsr ) :: gathered #include \"distributed_includes/GatherMatrixToAll.f90\" END SUBROUTINE GatherMatrixToProcess_psr_all !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on the !> given process. The process id is a within_slice id, so the data will !> still be replicated across slices. SUBROUTINE GatherMatrixToProcess_psc_id ( this , local_mat , within_slice_id ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: local_mat !> Which process to gather on. INTEGER , INTENT ( IN ) :: within_slice_id !! Local Variables TYPE ( TripletList_c ) :: tlist , sorted TYPE ( TripletList_c ), DIMENSION (:), ALLOCATABLE :: slist #include \"distributed_includes/GatherMatrixToProcess.f90\" END SUBROUTINE GatherMatrixToProcess_psc_id !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This subroutine gathers the entire matrix into a local matrix on to !> every process. SUBROUTINE GatherMatrixToProcess_psc_all ( this , local_mat ) !> The matrix to gather. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The full matrix, stored in a local matrix. TYPE ( Matrix_lsc ), INTENT ( INOUT ) :: local_mat !! Local Variables TYPE ( Matrix_lsc ) :: local , localT TYPE ( Matrix_lsc ) :: merged_columns TYPE ( Matrix_lsc ) :: merged_columnsT TYPE ( Matrix_lsc ) :: gathered #include \"distributed_includes/GatherMatrixToAll.f90\" END SUBROUTINE GatherMatrixToProcess_psc_all !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Determine if this is the identity matrix. FUNCTION IsIdentity ( this ) RESULT ( is_identity ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Result stored here. LOGICAL :: is_identity IF ( this % is_complex ) THEN is_identity = IsIdentity_psc ( this ) ELSE is_identity = IsIdentity_psr ( this ) END IF END FUNCTION IsIdentity !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Determine if this is the identity matrix (real implementation). FUNCTION IsIdentity_psr ( this ) RESULT ( is_identity ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Result stored here. LOGICAL :: is_identity !! Local Data TYPE ( TripletList_r ) :: tlist TYPE ( Triplet_r ) :: trip #include \"distributed_includes/IsIdentity.f90\" END FUNCTION IsIdentity_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Determine if this is the identity matrix (complex implementation). FUNCTION IsIdentity_psc ( this ) RESULT ( is_identity ) !> The matrix being filled. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Result stored here. LOGICAL :: is_identity !! Local Data TYPE ( TripletList_c ) :: tlist TYPE ( Triplet_c ) :: trip #include \"distributed_includes/IsIdentity.f90\" END FUNCTION IsIdentity_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PSMatrixModule","tags":"","loc":"sourcefile/psmatrixmodule.f90.html"},{"title":"EigenExaModule.F90 – NTPoly","text":"Contents Modules EigenExaModule Source Code EigenExaModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for calling eigenexa MODULE EigenExaModule #if EIGENEXA USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteElement , & & WriteHeader , WriteListElement USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , & & FillMatrixFromTripletList , GetMatrixTripletList , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE TripletModule , ONLY : Triplet_r , Triplet_c , SetTriplet USE TripletListModule , ONLY : TripletList_r , TripletList_c , & & AppendToTripletList , GetTripletAt , ConstructTripletList , & & DestructTripletList , RedistributeTripletLists USE eigen_libs_mod USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: EigenExa_s !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! TYPE , PRIVATE :: ExaHelper_t !> The number of processors involved. INTEGER :: num_procs !> The number of rows for the eigenexa comm. INTEGER :: proc_rows !> The number of columns for the eigenexa comm. INTEGER :: proc_cols !> Which process this is. INTEGER :: procid !> The global rank INTEGER :: global_rank !> Which row is this process in. INTEGER :: rowid !> Which column is this process in. INTEGER :: colid !> The number of rows for the local matrix. INTEGER :: local_rows !> The number of columns for the local matrix. INTEGER :: local_cols !> The dimension fo the matrix. INTEGER :: mat_dim !> The communicator for this calculation. INTEGER :: comm !> Householder transform block size INTEGER :: MB !> Householder backward transformation block size INTEGER :: M !> Mode of the solver CHARACTER :: MODE !> For block cyclic indexing. INTEGER :: offset !> Number of values to compute. INTEGER :: nvals END TYPE ExaHelper_t CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigenvectors of a matrix using EigenExa. SUBROUTINE EigenExa_s ( A , eigenvalues , nvals , & & eigenvectors_in , solver_parameters_in ) !> The matrix to decompose. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The eigenvalues computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> The number of eigenvalues to compute. INTEGER , INTENT ( IN ) :: nvals !> The eigenvectors computed. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !> The parameters for this solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Optional Parameters TYPE ( SolverParameters_t ) :: params !! Process Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Write info about the solver IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Eigen Solver\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"EigenExa\" ) CALL WriteElement ( key = \"NVALS\" , VALUE = nvals ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"imamura2011development\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Select Based on Type IF ( A % is_complex ) THEN IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenExa_c ( A , eigenvalues , nvals , params , & & eigenvectors_in ) ELSE CALL EigenExa_c ( A , eigenvalues , nvals , params ) END IF ELSE IF ( PRESENT ( eigenvectors_in )) THEN CALL EigenExa_r ( A , eigenvalues , nvals , params , & & eigenvectors_in ) ELSE CALL EigenExa_r ( A , eigenvalues , nvals , params ) END IF END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE EigenExa_s !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigenvectors of a matrix using EigenExa (real). SUBROUTINE EigenExa_r ( A , eigenvalues , nvals , params , eigenvectors_in ) !> The matrix to decompose. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The eigenvalues computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> The number of eigenvalues to compute. INTEGER , INTENT ( IN ) :: nvals !> The parameters for this solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> The eigenvectors computed. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !! Helper TYPE ( ExaHelper_t ) :: exa !! Dense Matrices REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: AD REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE :: VD REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: WD #include \"eigenexa_includes/EigenExa_s.F90\" END SUBROUTINE EigenExa_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the eigenvectors of a matrix using EigenExa (complex). SUBROUTINE EigenExa_c ( A , eigenvalues , nvals , params , eigenvectors_in ) !> The matrix to decompose. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The eigenvalues computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: eigenvalues !> The number of eigenvalues to compute. INTEGER , INTENT ( IN ) :: nvals !> The parameters for this solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> The eigenvectors computed. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: eigenvectors_in !! Helper TYPE ( ExaHelper_t ) :: exa !! Dense Matrices COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: AD COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE :: VD REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: WD #define ISCOMPLEX #include \"eigenexa_includes/EigenExa_s.F90\" #undef ISCOMPLEX END SUBROUTINE EigenExa_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup the eigen exa data structures. SUBROUTINE InitializeEigenExa ( A , nvals , eigenvectors , exa ) !> The matrix we're working on. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> Number of eigenvalues to compute. INTEGER , INTENT ( IN ) :: nvals !> Whether to compute eigenvectors. LOGICAL , INTENT ( IN ) :: eigenvectors !> Stores info about the calculation. TYPE ( ExaHelper_t ), INTENT ( INOUT ) :: exa !! Local Variables INTEGER :: ICTXT , INFO INTEGER , DIMENSION ( 9 ) :: DESCA INTEGER :: ierr !! Number of values to compute. exa % nvals = nvals !! Setup the MPI Communicator CALL MPI_Comm_dup ( A % process_grid % global_comm , exa % comm , ierr ) CALL MPI_Comm_rank ( exa % comm , exa % global_rank , ierr ) !! Build EigenExa Process Grid CALL eigen_init ( exa % comm ) CALL eigen_get_procs ( exa % num_procs , exa % proc_rows , exa % proc_cols ) CALL eigen_get_id ( exa % procid , exa % rowid , exa % colid ) !! Allocate Dense Matrices exa % mat_dim = A % actual_matrix_dimension CALL eigen_get_matdims ( exa % mat_dim , exa % local_rows , exa % local_cols ) !> Default blocking parameters exa % MB = 128 exa % M = 48 IF ( eigenvectors ) THEN exa % MODE = 'A' ELSE exa % MODE = 'N' END IF !! Blacs gives us the blocking info. ICTXT = eigen_get_blacs_context () CALL DESCINIT ( DESCA , exa % mat_dim , exa % mat_dim , 1 , 1 , 0 , 0 , ICTXT , & & exa % local_rows , INFO ) exa % offset = DESCA ( 9 ) END SUBROUTINE InitializeEigenExa !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the distributed sparse matrix to a dense matrix in block-cyclic !> distribution (real). SUBROUTINE NTToEigen_r ( A , AD , exa ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The dense, block-cyclic version. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( INOUT ) :: AD !> Info about the calculation. TYPE ( ExaHelper_t ), INTENT ( INOUT ) :: exa !! Local Variables TYPE ( TripletList_r ) :: triplet_a TYPE ( TripletList_r ), DIMENSION (:), ALLOCATABLE :: send_list TYPE ( TripletList_r ) :: recv_list TYPE ( Triplet_r ) :: trip , shifted_trip #include \"eigenexa_includes/NTToEigen.f90\" END SUBROUTINE NTToEigen_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the distributed sparse matrix to a dense matrix in block-cyclic !> distribution (complex). SUBROUTINE NTToEigen_c ( A , AD , exa ) !> The matrix to convert. TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The dense, block-cyclic version. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), INTENT ( INOUT ) :: AD !> Info about the calculation. TYPE ( ExaHelper_t ), INTENT ( INOUT ) :: exa !! Local Variables TYPE ( TripletList_c ) :: triplet_a TYPE ( TripletList_c ), DIMENSION (:), ALLOCATABLE :: send_list TYPE ( TripletList_c ) :: recv_list TYPE ( Triplet_c ) :: trip , shifted_trip #include \"eigenexa_includes/NTToEigen.f90\" END SUBROUTINE NTToEigen_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the dense eigenvector matrix stored block-cyclicly back to !> a distributed sparse matrix (real). SUBROUTINE EigenToNT_r ( VD , V , params , exa ) !> The dense eigenvector matrix. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( IN ) :: VD !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: V !> Parameters for thresholding small values. TYPE ( SolverParameters_t ) :: params !> Info about the calculation. TYPE ( ExaHelper_t ) :: exa !! Local Variables TYPE ( TripletList_r ) :: triplet_v TYPE ( Triplet_r ) :: trip REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: VD1 #include \"eigenexa_includes/EigenToNT.f90\" END SUBROUTINE EigenToNT_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the dense eigenvector matrix stored block-cyclicly back to !> a distributed sparse matrix (complex). SUBROUTINE EigenToNT_c ( VD , V , params , exa ) !> The dense eigenvector matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), INTENT ( IN ) :: VD !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: V !> Parameters for thresholding small values. TYPE ( SolverParameters_t ) :: params !> Info about the calculation. TYPE ( ExaHelper_t ) :: exa !! Local Variables TYPE ( TripletList_c ) :: triplet_v TYPE ( Triplet_c ) :: trip COMPLEX ( NTCOMPLEX ), DIMENSION (:), ALLOCATABLE :: VD1 #include \"eigenexa_includes/EigenToNT.f90\" END SUBROUTINE EigenToNT_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Converts the dense eigenvalue matrix stored duplicated across processes. SUBROUTINE ExtractEigenvalues ( WD , W , exa ) !> The dense eigenvalue matrix. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: WD !> The distributed sparse matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: W !> Info about the calculation. TYPE ( ExaHelper_t ) :: exa !! Local Variables TYPE ( TripletList_r ) :: triplet_w TYPE ( Triplet_r ) :: trip INTEGER :: wstart , wend , wsize INTEGER :: II !! Copy To Triplet List wsize = MAX ( CEILING (( 1.0 * exa % mat_dim ) / exa % num_procs ), 1 ) wstart = wsize * exa % global_rank + 1 wend = MIN ( wsize * ( exa % global_rank + 1 ), exa % mat_dim ) CALL ConstructTripletList ( triplet_w ) DO II = wstart , wend IF ( II . GT . exa % nvals ) THEN EXIT END IF CALL SetTriplet ( trip , II , II , WD ( II )) CALL AppendToTripletList ( triplet_w , trip ) END DO !! Go to global matrix CALL FillMatrixFromTripletList ( W , triplet_w ) !! Cleanup CALL DestructTripletList ( triplet_w ) END SUBROUTINE ExtractEigenvalues !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The routine which calls the eigenexa driver. SUBROUTINE Compute_r ( A , V , W , exa ) !> The matrix to decompose. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( INOUT ) :: A !> The eigenvectors. REAL ( NTREAL ), DIMENSION (:,:), INTENT ( INOUT ) :: V !> The eigenvalues. REAL ( NTREAL ), DIMENSION (:), INTENT ( INOUT ) :: W !> Calculation parameters. TYPE ( ExaHelper_t ), INTENT ( IN ) :: exa #include \"eigenexa_includes/Compute.f90\" !! Call CALL eigen_sx ( N , exa % nvals , A , LDA , W , V , LDZ , mode = exa % MODE ) END SUBROUTINE Compute_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The routine which calls the eigenexa driver. SUBROUTINE Compute_c ( A , V , W , exa ) !> The matrix to decompose. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), INTENT ( INOUT ) :: A !> The eigenvectors. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), INTENT ( INOUT ) :: V !> The eigenvalues. REAL ( NTREAL ), DIMENSION (:), INTENT ( INOUT ) :: W !> Calculation parameters. TYPE ( ExaHelper_t ), INTENT ( IN ) :: exa #include \"eigenexa_includes/Compute.f90\" !! Call CALL eigen_h ( N , exa % nvals , A , LDA , W , V , LDZ , mode = exa % MODE ) END SUBROUTINE Compute_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocates and shuts down eigenexa (real) SUBROUTINE CleanUp_r ( AD , VD , WD ) !> The matrix._r REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: AD !> The eigenvectors. REAL ( NTREAL ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: VD !> The eigenvalues. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: WD #include \"eigenexa_includes/Cleanup.f90\" END SUBROUTINE CleanUp_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deallocates and shuts down eigenexa (complex) SUBROUTINE CleanUp_c ( AD , VD , WD ) !> The matrix. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: AD !> The eigenvectors. COMPLEX ( NTCOMPLEX ), DIMENSION (:,:), ALLOCATABLE , INTENT ( INOUT ) :: VD !> The eigenvalues. REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE , INTENT ( INOUT ) :: WD #include \"eigenexa_includes/Cleanup.f90\" END SUBROUTINE CleanUp_c #endif !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE EigenExaModule","tags":"","loc":"sourcefile/eigenexamodule.f90.html"},{"title":"SignSolversModule.F90 – NTPoly","text":"Contents Modules SignSolversModule Source Code SignSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Matrix Sign Function. MODULE SignSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE EigenSolversModule , ONLY : DenseMatrixFunction USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteListElement , WriteElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & MatrixNorm , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , CopyMatrix , DestructMatrix , & & FillMatrixIdentity , PrintMatrixInformation , TransposeMatrix , & & ConjugateMatrix , ConstructEmptyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SignFunction PUBLIC :: DenseSignFunction PUBLIC :: PolarDecomposition CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the matrix sign function. SUBROUTINE SignFunction ( InMat , OutMat , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> The sign of Mat. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Sign Function Solver\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"nicholas2008functions\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF CALL CoreComputation ( InMat , OutMat , params , . FALSE .) !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE SignFunction !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the matrix sign function (dense version). SUBROUTINE DenseSignFunction ( InMat , OutputMat , solver_parameters_in ) !> The matrix to compute the sign of. TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> The sign of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Sign Function Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( InMat , OutputMat , SignLambda , params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF END SUBROUTINE DenseSignFunction !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the polar decomposition of a matrix Mat = U*H. SUBROUTINE PolarDecomposition ( InMat , Umat , Hmat , solver_parameters_in ) !> The input matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> The unitary polar factor. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: Umat !> The hermitian matrix factor. TYPE ( Matrix_ps ), INTENT ( INOUT ), OPTIONAL :: Hmat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params TYPE ( Matrix_ps ) :: UmatT !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Polar Decomposition Solver\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"nicholas2008functions\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF CALL CoreComputation ( InMat , Umat , params , . TRUE .) IF ( PRESENT ( Hmat )) THEN CALL TransposeMatrix ( Umat , UmatT ) IF ( UmatT % is_complex ) THEN CALL ConjugateMatrix ( UmatT ) END IF CALL MatrixMultiply ( UmatT , InMat , Hmat , & & threshold_in = params % threshold ) CALL DestructMatrix ( UmatT ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructSolverParameters ( params ) END SUBROUTINE PolarDecomposition !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This is the implementation routine for both the sign function and !> polar decomposition. SUBROUTINE CoreComputation ( InMat , OutMat , params , needs_transpose ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> Output of the routine. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> Whether we need to perform transposes in this routine (for polar). LOGICAL , INTENT ( IN ) :: needs_transpose !! Local Matrices TYPE ( Matrix_ps ) :: Identity TYPE ( Matrix_ps ) :: Temp1 TYPE ( Matrix_ps ) :: Temp2 TYPE ( Matrix_ps ) :: OutMatT TYPE ( MatrixMemoryPool_p ) :: pool !! Local Data REAL ( NTREAL ), PARAMETER :: alpha = 1.69770248526_NTREAL REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: alpha_k REAL ( NTREAL ) :: xk REAL ( NTREAL ) :: norm_value INTEGER :: II !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( Identity , InMat ) CALL ConstructEmptyMatrix ( Temp1 , InMat ) CALL ConstructEmptyMatrix ( Temp2 , InMat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN !! Permute Matrices CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( InMat , OutMat , & & params % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( InMat , OutMat ) END IF !! Initialize CALL GershgorinBounds ( InMat , e_min , e_max ) xk = ABS ( e_min / e_max ) CALL ScaleMatrix ( OutMat , 1.0_NTREAL / ABS ( e_max )) !! Iterate. IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL iterate : DO II = 1 , params % max_iterations IF ( params % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF !! Update Scaling Factors alpha_k = MIN ( SQRT ( 3.0_NTREAL / ( 1.0_NTREAL + xk + xk ** 2 )), alpha ) xk = 0.5_NTREAL * alpha_k * xk * ( 3.0_NTREAL - ( alpha_k ** 2 ) * xk ** 2 ) IF ( needs_transpose ) THEN CALL TransposeMatrix ( OutMat , OutMatT ) IF ( OutMatT % is_complex ) THEN CALL ConjugateMatrix ( OutMatT ) END IF CALL MatrixMultiply ( OutMatT , OutMat , Temp1 , & & alpha_in = - 1.0_NTREAL * alpha_k ** 2 , & & threshold_in = params % threshold , memory_pool_in = pool ) ELSE CALL MatrixMultiply ( OutMat , OutMat , Temp1 , & & alpha_in = - 1.0_NTREAL * alpha_k ** 2 , & & threshold_in = params % threshold , memory_pool_in = pool ) END IF CALL IncrementMatrix ( Identity , Temp1 , alpha_in = 3.0_NTREAL ) CALL MatrixMultiply ( OutMat , Temp1 , Temp2 , & & alpha_in = 0.5_NTREAL * alpha_k , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL IncrementMatrix ( Temp2 , OutMat , alpha_in = - 1.0_NTREAL ) norm_value = MatrixNorm ( OutMat ) CALL CopyMatrix ( Temp2 , OutMat ) IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO iterate IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) CALL PrintMatrixInformation ( OutMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & params % BalancePermutation , memorypool_in = pool ) END IF CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( OutMatT ) CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE CoreComputation !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical sign function for mapping. FUNCTION SignLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval IF ( val . LT . 0.0_NTREAL ) THEN outval = - 1.0_NTREAL ELSE outval = 1.0_NTREAL END IF END FUNCTION SignLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SignSolversModule","tags":"","loc":"sourcefile/signsolversmodule.f90.html"},{"title":"GeometryOptimizationModule.F90 – NTPoly","text":"Contents Modules GeometryOptimizationModule Source Code GeometryOptimizationModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Geometry Optimization MODULE GeometryOptimizationModule USE DataTypesModule , ONLY : NTREAL USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement , WriteListElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , ScaleMatrix , DotMatrix , SimilarityTransform , & & MatrixTrace USE PSMatrixModule , ONLY : Matrix_ps , DestructMatrix , ConstructEmptyMatrix , & & PrintMatrixInformation , CopyMatrix USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters USE SquareRootSolversModule , ONLY : SquareRoot , InverseSquareRoot IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: PurificationExtrapolate PUBLIC :: LowdinExtrapolate CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a new guess at the Density Matrix after updating the geometry. !> Based on the purification algorithm in \\cite niklasson2010trace . SUBROUTINE PurificationExtrapolate ( PreviousDensity , Overlap , trace , & & NewDensity , solver_parameters_in ) !> Previous density to extrapolate from. TYPE ( Matrix_ps ), INTENT ( IN ) :: PreviousDensity !> The overlap matrix of the new geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: Overlap !> The trace of the density matrix (usually the number of electrons). REAL ( NTREAL ), INTENT ( IN ) :: trace !> The extrapolated density. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: NewDensity !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: WorkingDensity TYPE ( Matrix_ps ) :: WorkingOverlap TYPE ( Matrix_ps ) :: TempMat !! Local Variables REAL ( NTREAL ) :: trace_value REAL ( NTREAL ) :: norm_value !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool INTEGER :: II !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Extrapolator\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Purification\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"niklasson2010trace\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( NewDensity , PreviousDensity ) CALL ConstructEmptyMatrix ( WorkingDensity , PreviousDensity ) CALL ConstructEmptyMatrix ( WorkingOverlap , PreviousDensity ) !! Compute the working hamiltonian. CALL CopyMatrix ( PreviousDensity , WorkingDensity ) CALL CopyMatrix ( Overlap , WorkingOverlap ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( WorkingDensity , WorkingDensity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( WorkingOverlap , WorkingOverlap , & & params % BalancePermutation , memorypool_in = pool ) END IF !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 DO II = 1 , params % max_iterations !! Xn+1 = Xn S1 Xn CALL MatrixMultiply ( WorkingDensity , WorkingOverlap , TempMat , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , WorkingDensity , NewDensity , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Figure Out Sigma Value CALL DotMatrix ( WorkingDensity , WorkingOverlap , trace_value ) !! Xn+1 = 2 Xn - Xn S1 Xn IF ( trace . GT . trace_value ) THEN CALL ScaleMatrix ( NewDensity , - 1.0_NTREAL ) CALL IncrementMatrix ( WorkingDensity , NewDensity , 2.0_NTREAL ) END IF !! Check Convergence CALL IncrementMatrix ( NewDensity , WorkingDensity , - 1.0_NTREAL ) norm_value = MatrixNorm ( WorkingDensity ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) CALL EnterSubLog CALL WriteElement ( key = \"Trace\" , VALUE = trace_value ) CALL ExitSubLog END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF !! Xn = Xn+1 CALL CopyMatrix ( NewDensity , WorkingDensity ) END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( NewDensity ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( NewDensity , NewDensity , & & params % BalancePermutation , memorypool_in = pool ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( WorkingDensity ) CALL DestructMatrix ( WorkingOverlap ) CALL DestructMatrix ( TempMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE PurificationExtrapolate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Create a new guess at the Density Matrix after updating the geometry. !> Based on the lowdin algorithm in \\cite exner2002comparison . SUBROUTINE LowdinExtrapolate ( PreviousDensity , OldOverlap , NewOverlap , & & NewDensity , solver_parameters_in ) !> THe previous density to extrapolate from. TYPE ( Matrix_ps ), INTENT ( IN ) :: PreviousDensity !> The old overlap matrix from the previous geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: OldOverlap !> The new overlap matrix from the current geometry. TYPE ( Matrix_ps ), INTENT ( IN ) :: NewOverlap !> The extrapolated density. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: NewDensity !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Matrices TYPE ( Matrix_ps ) :: SQRMat TYPE ( Matrix_ps ) :: ISQMat TYPE ( Matrix_ps ) :: TempMat !! Temporary Variables TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Density Matrix Extrapolator\" ) CALL EnterSubLog CALL WriteElement ( key = \"Method\" , VALUE = \"Lowdin\" ) CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"exner2002comparison\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF CALL SquareRoot ( OldOverlap , SQRMat , params ) CALL InverseSquareRoot ( NewOverlap , ISQMat , params ) CALL SimilarityTransform ( PreviousDensity , SQRMat , SQRMat , TempMat , & & pool_in = pool , threshold_in = params % threshold ) CALL SimilarityTransform ( TempMat , ISQMat , ISQMat , NewDensity , & & pool_in = pool , threshold_in = params % threshold ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( SQRMat ) CALL DestructMatrix ( ISQMat ) CALL DestructMatrix ( TempMat ) CALL DestructSolverParameters ( params ) CALL DestructMatrixMemoryPool ( pool ) END SUBROUTINE LowdinExtrapolate !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE GeometryOptimizationModule","tags":"","loc":"sourcefile/geometryoptimizationmodule.f90.html"},{"title":"ProcessGridModule.F90 – NTPoly","text":"Contents Modules ProcessGridModule Source Code ProcessGridModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to manage the process grid. MODULE ProcessGridModule USE ErrorModule , ONLY : Error_t , ConstructError , SetGenericError USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , & & WriteHeader , WriteListElement USE NTMPIModule #ifdef _OPENMP USE omp_lib , ONLY : omp_get_num_threads , omp_get_max_threads #endif IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A datatype which stores a process grid and all its communicators. TYPE , PUBLIC :: ProcessGrid_t !! Describe the grid INTEGER , PUBLIC :: total_processors !< total processors in the grid. INTEGER , PUBLIC :: num_process_rows !< number of rows in the grid. INTEGER , PUBLIC :: num_process_columns !< number of columns in the grid. INTEGER , PUBLIC :: num_process_slices !< number of 2D slices in the grid. INTEGER , PUBLIC :: slice_size !< the size of a 2D slice. !! Identiy current process INTEGER , PUBLIC :: my_slice !< which slice is the current process in. INTEGER , PUBLIC :: my_row !< which row is the current process in. INTEGER , PUBLIC :: my_column !< which column is the current process in. !! Ranks for communication INTEGER , PUBLIC :: global_rank !< current process rank amongst processes. !> rank for within slice communication. INTEGER , PUBLIC :: within_slice_rank !> rank for between slice communication. INTEGER , PUBLIC :: between_slice_rank INTEGER , PUBLIC :: column_rank !< rank for within column communication. INTEGER , PUBLIC :: row_rank !< rank for within row communication. !! Communicators for communication INTEGER , PUBLIC :: global_comm !< communicator with every other process. INTEGER , PUBLIC :: row_comm !< communicator within a row. INTEGER , PUBLIC :: column_comm !< communicator within a column. INTEGER , PUBLIC :: within_slice_comm !< communicator within a slice. INTEGER , PUBLIC :: between_slice_comm !< communicator between slices. INTEGER , PUBLIC :: grid_error !< stores errors from MPI calls. INTEGER , PUBLIC :: RootID = 0 !< Which rank is root? !! Blocked communication INTEGER , PUBLIC :: block_multiplier !< Block scaling factor. INTEGER , PUBLIC :: number_of_blocks_columns !< number of column blocks. INTEGER , PUBLIC :: number_of_blocks_rows !< number of row blocks. !> blocked communicator within a row. INTEGER , DIMENSION (:), ALLOCATABLE , PUBLIC :: blocked_row_comm !> blocked communicator within a column. INTEGER , DIMENSION (:), ALLOCATABLE , PUBLIC :: blocked_column_comm !> blocked communicator within a slice. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: blocked_within_slice_comm !> blocked communicator between slices. INTEGER , DIMENSION (:,:), ALLOCATABLE , PUBLIC :: blocked_between_slice_comm !> The maximum number of openmp threads. INTEGER :: omp_max_threads END TYPE ProcessGrid_t !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The default process grid. TYPE ( ProcessGrid_t ), TARGET , PUBLIC , SAVE :: global_grid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructProcessGrid PUBLIC :: ConstructNewProcessGrid PUBLIC :: IsRoot PUBLIC :: SplitProcessGrid PUBLIC :: CopyProcessGrid PUBLIC :: DestructProcessGrid !! Accessors for grid information PUBLIC :: GetMySlice PUBLIC :: GetMyRow PUBLIC :: GetMyColumn PUBLIC :: ComputeGridSize PUBLIC :: WriteProcessGridInfo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE ConstructProcessGrid MODULE PROCEDURE ConstructProcessGrid_full MODULE PROCEDURE ConstructProcessGrid_onlyslice END INTERFACE ConstructProcessGrid INTERFACE ConstructNewProcessGrid MODULE PROCEDURE ConstructNewProcessGrid_full MODULE PROCEDURE ConstructNewProcessGrid_onlyslice END INTERFACE ConstructNewProcessGrid CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup the default process grid. SUBROUTINE ConstructProcessGrid_full ( world_comm , process_rows , & & process_columns , process_slices , be_verbose_in ) !> A communicator that every process in the grid is a part of. INTEGER , INTENT ( IN ) :: world_comm !> The number of grid rows. INTEGER , INTENT ( IN ) :: process_rows !> The number of grid columns. INTEGER , INTENT ( IN ) :: process_columns !> The number of grid slices. INTEGER , INTENT ( IN ) :: process_slices !> Set true to print process grid info. LOGICAL , INTENT ( IN ), OPTIONAL :: be_verbose_in !! Local Data LOGICAL :: be_verbose !! Process Optional Parameters IF ( PRESENT ( be_verbose_in )) THEN be_verbose = be_verbose_in ELSE be_verbose = . FALSE . END IF CALL ConstructNewProcessGrid ( global_grid , world_comm , process_rows , & & process_columns , process_slices ) END SUBROUTINE ConstructProcessGrid_full !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup a process grid specifying only the slices SUBROUTINE ConstructProcessGrid_onlyslice ( world_comm , process_slices_in , & & be_verbose_in ) !> A communicator that every process in the grid is a part of. INTEGER , INTENT ( IN ) :: world_comm !> The number of grid slices. INTEGER , INTENT ( IN ), OPTIONAL :: process_slices_in !> Set true to print process grid info. LOGICAL , INTENT ( IN ), OPTIONAL :: be_verbose_in !! Local Data LOGICAL :: be_verbose INTEGER :: process_rows , process_columns , process_slices INTEGER :: total_processors INTEGER :: ierr !! Total processors CALL MPI_COMM_SIZE ( world_comm , total_processors , ierr ) !! Process Optional Parameters IF ( PRESENT ( be_verbose_in )) THEN be_verbose = be_verbose_in ELSE be_verbose = . FALSE . END IF IF ( PRESENT ( process_slices_in )) THEN process_slices = process_slices_in ELSE CALL ComputeNumSlices ( total_processors , process_slices ) END IF !! Create a 3D grid CALL ComputeGridSize ( total_processors , process_slices , process_rows , & & process_columns ) !! Now call the full setup CALL ConstructProcessGrid ( world_comm , process_rows , process_columns , & & process_slices , be_verbose ) END SUBROUTINE ConstructProcessGrid_onlyslice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Construct a process grid. SUBROUTINE ConstructNewProcessGrid_full ( grid , world_comm , process_rows , & & process_columns , process_slices ) !> The grid to construct TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: grid !> A communicator that every process in the grid is a part of. INTEGER , INTENT ( IN ) :: world_comm !> The number of grid rows. INTEGER , INTENT ( IN ) :: process_rows !> The number of grid columns. INTEGER , INTENT ( IN ) :: process_columns !> The number of grid slices. INTEGER , INTENT ( IN ) :: process_slices !! Local Data INTEGER :: column_block_multiplier INTEGER :: row_block_multiplier INTEGER :: II , JJ #ifdef _OPENMP INTEGER :: num_threads #endif INTEGER :: ierr TYPE ( Error_t ) :: err CALL ConstructError ( err ) CALL MPI_COMM_DUP ( world_comm , grid % global_comm , ierr ) !! Grid Dimensions grid % num_process_rows = process_rows grid % num_process_columns = process_columns grid % num_process_slices = process_slices CALL MPI_COMM_SIZE ( grid % global_comm , grid % total_processors , ierr ) grid % slice_size = grid % total_processors / grid % num_process_slices !! Do a sanity check IF ( grid % num_process_rows * grid % num_process_columns & & * grid % num_process_slices . NE . grid % total_processors ) THEN CALL SetGenericError ( err , & & \"you did not specify a consistent process grid size\" , . TRUE .) END IF IF ( grid % num_process_slices . GT . 1 ) THEN IF ( MOD ( MAX ( grid % num_process_rows , grid % num_process_columns ), & & MIN ( grid % num_process_rows , grid % num_process_columns )) & & . NE . 0 ) THEN CALL SetGenericError ( err , & & \"if slices >1, either rows or columns must be a multiple\" // & & \"of the other.\" , & & . TRUE .) END IF END IF !! Grid ID CALL MPI_COMM_RANK ( grid % global_comm , grid % global_rank , ierr ) grid % my_slice = grid % global_rank / grid % slice_size grid % my_row = MOD ( grid % global_rank , grid % slice_size ) / & & grid % num_process_columns grid % my_column = MOD ( grid % global_rank , grid % num_process_columns ) !! Grid Communicators CALL MPI_COMM_SPLIT ( grid % global_comm , grid % my_slice , grid % global_rank , & grid % within_slice_comm , ierr ) CALL MPI_COMM_RANK ( grid % within_slice_comm , grid % within_slice_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % global_comm , grid % within_slice_rank , & & grid % global_rank , grid % between_slice_comm , ierr ) CALL MPI_COMM_RANK ( grid % between_slice_comm , grid % between_slice_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_row , & & grid % global_rank , grid % row_comm , ierr ) CALL MPI_COMM_RANK ( grid % row_comm , grid % row_rank , ierr ) CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_column , & & grid % global_rank , grid % column_comm , ierr ) CALL MPI_COMM_RANK ( grid % column_comm , grid % column_rank , ierr ) !! Blocking Information column_block_multiplier = & & ( grid % num_process_rows / grid % num_process_columns ) * & & grid % num_process_slices IF ( column_block_multiplier . EQ . 0 ) THEN column_block_multiplier = grid % num_process_slices END IF row_block_multiplier = & & ( grid % num_process_columns / grid % num_process_rows ) * & & grid % num_process_slices IF ( row_block_multiplier . EQ . 0 ) THEN row_block_multiplier = 1 * grid % num_process_slices END IF !! The rule right now seems to be to have at least half as many blocks as !! threads. #if defined NOBLOCK grid % block_multiplier = 1 grid % omp_max_threads = 1 #elif defined _OPENMP !$omp PARALLEL num_threads = omp_get_num_threads () grid % omp_max_threads = omp_get_max_threads () !$omp end PARALLEL grid % block_multiplier = num_threads / & & ( column_block_multiplier + row_block_multiplier ) IF ( grid % block_multiplier . EQ . 0 ) THEN grid % block_multiplier = 1 END IF #else grid % block_multiplier = 1 #endif grid % number_of_blocks_columns = & & column_block_multiplier * grid % block_multiplier grid % number_of_blocks_rows = & & row_block_multiplier * grid % block_multiplier !! Create Blocked Communicators ALLOCATE ( grid % blocked_row_comm ( grid % number_of_blocks_rows )) ALLOCATE ( grid % blocked_column_comm ( grid % number_of_blocks_columns )) ALLOCATE ( grid % blocked_within_slice_comm ( grid % number_of_blocks_rows , & & grid % number_of_blocks_columns )) ALLOCATE ( grid % blocked_between_slice_comm ( grid % number_of_blocks_rows , & & grid % number_of_blocks_columns )) DO JJ = 1 , grid % number_of_blocks_columns DO II = 1 , grid % number_of_blocks_rows CALL MPI_COMM_SPLIT ( grid % global_comm , grid % my_slice , & & grid % global_rank , grid % blocked_within_slice_comm ( II , JJ ), & & ierr ) CALL MPI_COMM_SPLIT ( grid % global_comm , grid % within_slice_rank , & & grid % global_rank , grid % blocked_between_slice_comm ( II , JJ ), & & ierr ) END DO END DO DO JJ = 1 , grid % number_of_blocks_columns CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_column , & & grid % global_rank , grid % blocked_column_comm ( JJ ), ierr ) END DO DO II = 1 , grid % number_of_blocks_rows CALL MPI_COMM_SPLIT ( grid % within_slice_comm , grid % my_row , & & grid % global_rank , grid % blocked_row_comm ( II ), ierr ) END DO END SUBROUTINE ConstructNewProcessGrid_full !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Setup a process grid specifying only the slices SUBROUTINE ConstructNewProcessGrid_onlyslice ( grid , world_comm , & & process_slices_in ) !> The grid to construct TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: grid !> A communicator that every process in the grid is a part of. INTEGER , INTENT ( IN ) :: world_comm !> The number of grid slices. INTEGER , INTENT ( IN ), OPTIONAL :: process_slices_in !! Local Data INTEGER :: process_rows , process_columns , process_slices INTEGER :: total_processors INTEGER :: ierr !! Total processors CALL MPI_COMM_SIZE ( world_comm , total_processors , ierr ) !! Process Optional Parameters IF ( PRESENT ( process_slices_in )) THEN process_slices = process_slices_in ELSE CALL ComputeNumSlices ( total_processors , process_slices ) END IF !! Create a 3D grid CALL ComputeGridSize ( total_processors , process_slices , process_rows , & & process_columns ) !! Now call the full setup CALL ConstructNewProcessGrid ( grid , world_comm , process_rows , & & process_columns , process_slices ) END SUBROUTINE ConstructNewProcessGrid_onlyslice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Copy a process grid. !> Note that this makes a complete and independent copy of the process grid. !> Which of course means that whatever is currently stored in new_grid will !> be destroyed, so do not leave any matrices pointing to it. SUBROUTINE CopyProcessGrid ( old_grid , new_grid ) !> The grid to copy. TYPE ( ProcessGrid_t ), INTENT ( IN ) :: old_grid !> New_grid = old_grid TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: new_grid INTEGER :: II , JJ , ierr !! Safe Copy CALL DestructProcessGrid ( new_grid ) !! Copy all the basic data about a process new_grid % total_processors = old_grid % total_processors new_grid % num_process_rows = old_grid % num_process_rows new_grid % num_process_columns = old_grid % num_process_columns new_grid % num_process_slices = old_grid % num_process_slices new_grid % slice_size = old_grid % slice_size new_grid % my_slice = old_grid % my_slice new_grid % my_row = old_grid % my_row new_grid % my_column = old_grid % my_column new_grid % global_rank = old_grid % global_rank new_grid % within_slice_rank = old_grid % within_slice_rank new_grid % between_slice_rank = old_grid % between_slice_rank new_grid % column_rank = old_grid % column_rank new_grid % row_rank = old_grid % row_rank new_grid % block_multiplier = old_grid % block_multiplier new_grid % number_of_blocks_columns = old_grid % number_of_blocks_columns new_grid % number_of_blocks_rows = old_grid % number_of_blocks_rows new_grid % omp_max_threads = old_grid % omp_max_threads !! Allocate Blocks ALLOCATE ( new_grid % blocked_row_comm ( old_grid % number_of_blocks_rows )) ALLOCATE ( new_grid % blocked_column_comm ( old_grid % number_of_blocks_columns )) ALLOCATE ( new_grid % blocked_within_slice_comm (& & old_grid % number_of_blocks_rows , old_grid % number_of_blocks_columns )) ALLOCATE ( new_grid % blocked_between_slice_comm ( & & old_grid % number_of_blocks_rows , old_grid % number_of_blocks_columns )) !! Copy the communicators DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_row_comm ( II ), & & new_grid % blocked_row_comm ( II ), ierr ) END DO DO JJ = 1 , new_grid % number_of_blocks_columns CALL MPI_COMM_DUP ( old_grid % blocked_column_comm ( JJ ), & & new_grid % blocked_column_comm ( JJ ), ierr ) END DO DO JJ = 1 , new_grid % number_of_blocks_columns DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_within_slice_comm ( II , JJ ), & & new_grid % blocked_within_slice_comm ( II , JJ ), ierr ) END DO END DO DO JJ = 1 , new_grid % number_of_blocks_columns DO II = 1 , new_grid % number_of_blocks_rows CALL MPI_COMM_DUP ( old_grid % blocked_between_slice_comm ( II , JJ ), & & new_grid % blocked_between_slice_comm ( II , JJ ), ierr ) END DO END DO CALL MPI_COMM_DUP ( old_grid % global_comm , new_grid % global_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % row_comm , new_grid % row_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % column_comm , new_grid % column_comm , ierr ) CALL MPI_COMM_DUP ( old_grid % within_slice_comm , new_grid % within_slice_comm , & & ierr ) CALL MPI_COMM_DUP ( old_grid % between_slice_comm , & & new_grid % between_slice_comm , ierr ) END SUBROUTINE CopyProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Destruct a process grid. !> Be careful about doing this. Matrices have pointers to process grids. If !> you destruct a process grid without destructing the matrices pointing to !> it, they will become unusable. RECURSIVE SUBROUTINE DestructProcessGrid ( grid_in ) !> The grid to destruct. If none specified this destroys the global grid. TYPE ( ProcessGrid_t ), OPTIONAL , INTENT ( INOUT ) :: grid_in !! Counters INTEGER :: II , JJ INTEGER :: Ierr !! Handle optional parameters IF (. NOT . PRESENT ( grid_in )) THEN CALL DestructProcessGrid ( global_grid ) ELSE !! Destruct IF ( ALLOCATED ( grid_in % blocked_row_comm )) THEN CALL MPI_COMM_FREE ( grid_in % global_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % row_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % column_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % within_slice_comm , ierr ) CALL MPI_COMM_FREE ( grid_in % between_slice_comm , ierr ) DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_row_comm ( II ), ierr ) END DO DEALLOCATE ( grid_in % blocked_row_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_column_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns CALL MPI_COMM_FREE ( grid_in % blocked_column_comm ( JJ ), ierr ) END DO DEALLOCATE ( grid_in % blocked_column_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_within_slice_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_within_slice_comm ( II , JJ ), & & ierr ) END DO END DO DEALLOCATE ( grid_in % blocked_within_slice_comm ) END IF IF ( ALLOCATED ( grid_in % blocked_between_slice_comm )) THEN DO JJ = 1 , grid_in % number_of_blocks_columns DO II = 1 , grid_in % number_of_blocks_rows CALL MPI_COMM_FREE ( grid_in % blocked_between_slice_comm ( II , JJ ), & & ierr ) END DO END DO DEALLOCATE ( grid_in % blocked_between_slice_comm ) END IF END IF END SUBROUTINE DestructProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Given a process grid, this splits it into two grids of even size SUBROUTINE SplitProcessGrid ( old_grid , new_grid , my_color , split_slice , & & between_grid_comm ) !> The old grid to split TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: old_grid !> The new grid that we are creating TYPE ( ProcessGrid_t ), INTENT ( INOUT ) :: new_grid !> A color value indicating which set this process was split into INTEGER , INTENT ( OUT ) :: my_color !> True if we were able to split along slices. LOGICAL , INTENT ( OUT ) :: split_slice !> A communicator for sending messages between groups. INTEGER , INTENT ( OUT ) :: between_grid_comm !! Local Variables - new grid INTEGER :: new_comm INTEGER :: rows , cols , slices INTEGER :: midpoint !! For Between Comm INTEGER :: between_color , between_rank INTEGER :: left_grid_size !! Temporary INTEGER :: ierr split_slice = . FALSE . !! Handle base case IF ( old_grid % total_processors . EQ . 1 ) THEN rows = 1 cols = 1 slices = 1 my_color = 0 between_rank = 0 !! First preferentially try to split along slices ELSE IF ( old_grid % num_process_slices . GT . 1 ) THEN midpoint = old_grid % num_process_slices / 2 cols = old_grid % num_process_columns rows = old_grid % num_process_rows IF ( old_grid % my_slice . LT . midpoint ) THEN my_color = 0 slices = midpoint ELSE my_color = 1 slices = old_grid % num_process_slices - midpoint END IF between_rank = old_grid % my_slice split_slice = . TRUE . left_grid_size = midpoint * cols * rows !! Next try to split the bigger direction ELSE IF ( old_grid % num_process_rows . GT . old_grid % num_process_columns ) THEN midpoint = old_grid % num_process_rows / 2 cols = old_grid % num_process_columns slices = 1 IF ( old_grid % my_row . LT . midpoint ) THEN my_color = 0 rows = midpoint ELSE my_color = 1 rows = old_grid % num_process_rows - midpoint END IF between_rank = old_grid % my_row left_grid_size = midpoint * cols * slices !! Default Case ELSE midpoint = old_grid % num_process_columns / 2 slices = 1 rows = old_grid % num_process_rows IF ( old_grid % my_column . LT . midpoint ) THEN my_color = 0 cols = midpoint ELSE my_color = 1 cols = old_grid % num_process_columns - midpoint END IF between_rank = old_grid % my_column left_grid_size = midpoint * slices * rows END IF !! Construct CALL MPI_COMM_SPLIT ( old_grid % global_comm , my_color , old_grid % global_rank , & & new_comm , ierr ) CALL ConstructNewProcessGrid ( new_grid , new_comm , rows , cols , slices ) !! For sending data between grids between_color = MOD ( new_grid % global_rank , left_grid_size ) CALL MPI_COMM_SPLIT ( old_grid % global_comm , between_color , between_rank , & & between_grid_comm , ierr ) END SUBROUTINE SplitProcessGrid !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Check if the current process is the root process. FUNCTION IsRoot ( grid_in ) RESULT ( is_root ) !! Parameters !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid_in !> True if the current process is root. LOGICAL :: is_root IF ( PRESENT ( grid_in )) THEN is_root = ( grid_in % global_rank . EQ . 0 ) ELSE is_root = ( global_grid % global_rank . EQ . 0 ) END IF END FUNCTION IsRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the slice of the current process. FUNCTION GetMySlice ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> Slice number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_slice ELSE return_val = global_grid % my_slice END IF END FUNCTION GetMySlice !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the column of the current process. FUNCTION GetMyColumn ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> The column number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_column ELSE return_val = global_grid % my_column END IF END FUNCTION GetMyColumn !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the row of the current process. FUNCTION GetMyRow ( grid ) RESULT ( return_val ) !> The process grid. TYPE ( ProcessGrid_t ), INTENT ( IN ), OPTIONAL :: grid !> The row number of the current process. INTEGER :: return_val IF ( PRESENT ( grid )) THEN return_val = grid % my_row ELSE return_val = global_grid % my_row END IF END FUNCTION GetMyRow !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sometimes we only want to specify for a process grid the number of slices !> and then automatically compute the right number of rows and columns. SUBROUTINE ComputeGridSize ( total_processors , set_slices , rows , columns ) !> Total processors in the grid INTEGER , INTENT ( IN ) :: total_processors !> Desired number of slices INTEGER , INTENT ( IN ) :: set_slices !> Computed number of rows INTEGER , INTENT ( OUT ) :: rows !> Computed number of columns INTEGER , INTENT ( OUT ) :: columns !! Local variables INTEGER :: slice_size , size_search INTEGER :: II rows = 1 columns = 1 slice_size = total_processors / set_slices size_search = FLOOR ( SQRT ( REAL ( slice_size ))) DO II = size_search , 1 , - 1 IF ( MOD ( slice_size , II ) . EQ . 0 ) THEN rows = II columns = slice_size / II EXIT END IF END DO END SUBROUTINE ComputeGridSize !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pick an appropriate number of process slices for this calculation. !> This routine will focus on whether we can make a valid process grid with !> several slices. SUBROUTINE ComputeNumSlices ( total_processors , slices ) !> Total processors in the grid. INTEGER , INTENT ( IN ) :: total_processors !> Number of slices to use. INTEGER , INTENT ( OUT ) :: slices !! Local Variables INTEGER :: slice_size INTEGER :: slice_dim LOGICAL :: found !! Try manually values [4, 3, 2]. If they do not work, give up and use 1. found = . FALSE . DO slices = MIN ( 4 , total_processors ), 2 , - 1 slice_size = total_processors / slices IF ( slice_size * slices . NE . total_processors ) CYCLE !! First try a square grid. slice_dim = FLOOR ( SQRT ( REAL ( slice_size ))) IF ( slice_dim * slice_dim . EQ . slice_size ) THEN FOUND = . TRUE . EXIT END IF !! If not, we try a grid where the rows are twice the number of columns. slice_dim = FLOOR ( SQRT ( REAL ( slice_size / 2 ))) IF ( slice_dim * slice_dim * 2 . EQ . slice_size ) THEN FOUND = . TRUE . EXIT END IF END DO IF (. NOT . FOUND ) slices = 1 END SUBROUTINE ComputeNumSlices !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out some basic information about this process grid to the log. RECURSIVE SUBROUTINE WriteProcessGridInfo ( this ) !> The grid to print about. If not specified, global information printed. TYPE ( ProcessGrid_t ), OPTIONAL , INTENT ( IN ) :: this IF ( PRESENT ( this )) THEN CALL WriteHeader ( \"Process Grid\" ) CALL EnterSubLog CALL WriteListElement ( key = \"Process Rows\" , & & VALUE = this % num_process_rows ) CALL WriteListElement ( key = \"Process Columns\" , & & VALUE = this % num_process_columns ) CALL WriteListElement ( key = \"Process Slices\" , & & VALUE = this % num_process_slices ) CALL WriteListElement ( key = \"Column Blocks\" , & & VALUE = this % number_of_blocks_columns ) CALL WriteListElement ( key = \"Row Blocks\" , & & VALUE = this % number_of_blocks_rows ) CALL ExitSubLog ELSE CALL WriteProcessGridInfo ( global_grid ) END IF END SUBROUTINE WriteProcessGridInfo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ProcessGridModule","tags":"","loc":"sourcefile/processgridmodule.f90.html"},{"title":"TripletModule.F90 – NTPoly","text":"Contents Modules TripletModule Source Code TripletModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for the triplet data type. !> Each one stores two indices and a value. This is related to sparse matrices, !> the referencing indices are usually rows and columns. MODULE TripletModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX , & & MPINTINTEGER USE ErrorModule , ONLY : Error_t , CheckMPIError USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a triplet of integer, integer, double. TYPE , PUBLIC :: Triplet_r INTEGER :: index_column !< column value. INTEGER :: index_row !< row value. REAL ( NTREAL ) :: point_value !< actual value at those indices. END TYPE Triplet_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A data type for a triplet of integer, integer, complex. TYPE , PUBLIC :: Triplet_c INTEGER :: index_column !< column value. INTEGER :: index_row !< row value. COMPLEX ( NTCOMPLEX ) :: point_value !< actual value at those indices. END TYPE Triplet_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SetTriplet PUBLIC :: GetTripletValues PUBLIC :: CompareTriplets PUBLIC :: GetMPITripletType_r PUBLIC :: GetMPITripletType_c PUBLIC :: ConvertTripletType !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE SetTriplet MODULE PROCEDURE SetTriplet_r MODULE PROCEDURE SetTriplet_c END INTERFACE SetTriplet INTERFACE GetTripletValues MODULE PROCEDURE GetTripletValues_r MODULE PROCEDURE GetTripletValues_c END INTERFACE GetTripletValues INTERFACE CompareTriplets MODULE PROCEDURE CompareTriplets_r MODULE PROCEDURE CompareTriplets_c END INTERFACE CompareTriplets INTERFACE ConvertTripletType MODULE PROCEDURE ConvertTripletToReal MODULE PROCEDURE ConvertTripletToComplex END INTERFACE ConvertTripletType CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the values of a triplet (real). PURE SUBROUTINE SetTriplet_r ( this , index_column , index_row , point_value ) !> The triplet to set the values of. TYPE ( Triplet_r ), INTENT ( INOUT ) :: this !> The column value. INTEGER , INTENT ( IN ) :: index_column !> The row value. INTEGER , INTENT ( IN ) :: index_row !> The value at that point. REAL ( NTREAL ), INTENT ( IN ) :: point_value #include \"triplet_includes/SetTriplet.f90\" END SUBROUTINE SetTriplet_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the values of a triplet (complex). PURE SUBROUTINE SetTriplet_c ( this , index_column , index_row , point_value ) !> The triplet to set the values of. TYPE ( Triplet_c ), INTENT ( INOUT ) :: this !> The column value. INTEGER , INTENT ( IN ) :: index_column !> The row value. INTEGER , INTENT ( IN ) :: index_row !> The value at that point. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: point_value #include \"triplet_includes/SetTriplet.f90\" END SUBROUTINE SetTriplet_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the values of a triplet. PURE SUBROUTINE GetTripletValues_r ( this , index_column , index_row , & & point_value ) !> The triplet to extract the values of. TYPE ( Triplet_r ), INTENT ( IN ) :: this !> Column value. INTEGER , INTENT ( OUT ) :: index_column !> Row value. INTEGER , INTENT ( OUT ) :: index_row !> Actual stored value. REAL ( NTREAL ), INTENT ( OUT ) :: point_value #include \"triplet_includes/GetTriplet.f90\" END SUBROUTINE GetTripletValues_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the values of a triplet. PURE SUBROUTINE GetTripletValues_c ( this , index_column , index_row , & & point_value ) !> The triplet to extract the values of. TYPE ( Triplet_c ), INTENT ( IN ) :: this !> Column value. INTEGER , INTENT ( OUT ) :: index_column !> Row value. INTEGER , INTENT ( OUT ) :: index_row !> Actual stored value. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: point_value #include \"triplet_includes/GetTriplet.f90\" END SUBROUTINE GetTripletValues_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compare two triplets based on their index values, first by column and !> second by row. Returns A < B. PURE FUNCTION CompareTriplets_r ( tripA , tripB ) RESULT ( islessthan ) !> First triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: tripA !> Second triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: tripB !> A < B. LOGICAL :: islessthan #include \"triplet_includes/CompareTriplets.f90\" END FUNCTION CompareTriplets_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compare two triplets based on their index values (complex), first by !> column and second by row. Returns A < B. PURE FUNCTION CompareTriplets_c ( tripA , tripB ) RESULT ( islessthan ) !> First triplet. TYPE ( Triplet_c ), INTENT ( IN ) :: tripA !> Second triplet. TYPE ( Triplet_c ), INTENT ( IN ) :: tripB !> A < B. LOGICAL :: islessthan #include \"triplet_includes/CompareTriplets.f90\" END FUNCTION CompareTriplets_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Returns an MPI derived data type for a triplet (Real). !> We statically store this derived type so that we do not have to recreate !> it every time this function is called. Thus this functional call should !> add very little overhead. FUNCTION GetMPITripletType_r () RESULT ( mpi_triplet_type ) !> MPI Derived Type INTEGER :: mpi_triplet_type !! Local Data INTEGER , DIMENSION ( 3 ) :: triplet_sub_types INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION ( 3 ) :: triplet_displacement INTEGER , DIMENSION ( 3 ) :: triplet_block_length INTEGER :: bytes_per_int , bytes_per_double INTEGER :: ierr CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) CALL MPI_Type_extent ( MPINTREAL , bytes_per_double , ierr ) triplet_block_length = [ 1 , 1 , 1 ] triplet_displacement = [ 0 , bytes_per_int , 2 * bytes_per_int ] triplet_sub_types = [ MPINTINTEGER , MPINTINTEGER , MPINTREAL ] CALL MPI_Type_create_struct ( 3 , triplet_block_length , & & triplet_displacement , triplet_sub_types , mpi_triplet_type , ierr ) CALL MPI_Type_commit ( mpi_triplet_type , ierr ) END FUNCTION GetMPITripletType_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Returns an MPI derived data type for a triplet (complex). !> We statically store this derived type so that we do not have to recreate !> it every time this function is called. Thus this functional call should !> add very little overhead. FUNCTION GetMPITripletType_c () RESULT ( mpi_triplet_type ) !> MPI Derived Type INTEGER :: mpi_triplet_type !! Local Data INTEGER , DIMENSION ( 3 ) :: triplet_sub_types INTEGER ( KIND = MPI_ADDRESS_KIND ), DIMENSION ( 3 ) :: triplet_displacement INTEGER , DIMENSION ( 3 ) :: triplet_block_length INTEGER :: bytes_per_int , bytes_per_double TYPE ( Error_t ) :: error_check LOGICAL :: error_occured INTEGER :: ierr CALL MPI_Type_extent ( MPINTINTEGER , bytes_per_int , ierr ) CALL MPI_Type_extent ( MPINTCOMPLEX , bytes_per_double , ierr ) triplet_block_length = [ 1 , 1 , 1 ] triplet_displacement = [ 0 , bytes_per_int , 2 * bytes_per_int ] triplet_sub_types = [ MPINTINTEGER , MPINTINTEGER , MPINTCOMPLEX ] CALL MPI_Type_create_struct ( 3 , triplet_block_length , & & triplet_displacement , triplet_sub_types , mpi_triplet_type , ierr ) CALL MPI_Type_commit ( mpi_triplet_type , ierr ) error_occured = CheckMPIError ( error_check , \"Creation of MPINTCOMPLEX\" , & & ierr , . TRUE .) END FUNCTION GetMPITripletType_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a complex triplet to a real triplet. SUBROUTINE ConvertTripletToReal ( cin_triplet , rout_triplet ) !> The starting triplet TYPE ( Triplet_c ), INTENT ( IN ) :: cin_triplet !> Real valued triplet. TYPE ( Triplet_r ), INTENT ( INOUT ) :: rout_triplet rout_triplet % index_row = cin_triplet % index_row rout_triplet % index_column = cin_triplet % index_column rout_triplet % point_value = REAL ( cin_triplet % point_value , KIND = NTREAL ) END SUBROUTINE ConvertTripletToReal !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Convert a real triplet to a complex triplet. SUBROUTINE ConvertTripletToComplex ( rin_triplet , cout_triplet ) !> The starting triplet. TYPE ( Triplet_r ), INTENT ( IN ) :: rin_triplet !> Complex valued triplet. TYPE ( Triplet_c ), INTENT ( INOUT ) :: cout_triplet cout_triplet % index_row = rin_triplet % index_row cout_triplet % index_column = rin_triplet % index_column cout_triplet % point_value = CMPLX ( rin_triplet % point_value , 0.0_NTREAL , & & KIND = NTCOMPLEX ) END SUBROUTINE ConvertTripletToComplex !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE TripletModule","tags":"","loc":"sourcefile/tripletmodule.f90.html"},{"title":"LoggingModule.F90 – NTPoly","text":"Contents Modules LoggingModule Source Code LoggingModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for writing data to the log file. MODULE LoggingModule USE DataTypesModule , ONLY : NTReal IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTEGER , SAVE :: CurrentLevel = 0 LOGICAL , SAVE :: IsActive = . FALSE . INTEGER , SAVE :: UNIT = 6 LOGICAL , SAVE :: file_open = . FALSE . INTEGER , SAVE :: initial_offset = 0 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ActivateLogger PUBLIC :: DeactivateLogger PUBLIC :: IsLoggerActive !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: EnterSubLog PUBLIC :: ExitSubLog PUBLIC :: WriteElement PUBLIC :: WriteHeader PUBLIC :: WriteListElement !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: SetInitialOffset PUBLIC :: SetLoggerLevel PUBLIC :: GetLoggerLevel !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE WriteListElement MODULE PROCEDURE WriteListElement_bool MODULE PROCEDURE WriteListElement_float MODULE PROCEDURE WriteListElement_int MODULE PROCEDURE WriteListElement_string END INTERFACE WriteListElement INTERFACE WriteElement MODULE PROCEDURE WriteElement_bool MODULE PROCEDURE WriteElement_float MODULE PROCEDURE WriteElement_int MODULE PROCEDURE WriteElement_string END INTERFACE WriteElement CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Activate the logger. SUBROUTINE ActivateLogger ( start_document_in , file_name_in , unit_in ) !> If this is a new document we can write the start document marker. LOGICAL , INTENT ( IN ), OPTIONAL :: start_document_in !> An optional file name for writing to. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: file_name_in !> An optional fortran i/o unit override. INTEGER , INTENT ( IN ), OPTIONAL :: unit_in IsActive = . TRUE . IF ( PRESENT ( unit_in )) THEN UNIT = unit_in END IF IF ( PRESENT ( file_name_in )) THEN IF (. NOT . PRESENT ( unit_in )) THEN UNIT = 14 END IF OPEN ( unit = UNIT , file = file_name_in ) file_open = . TRUE . END IF IF ( PRESENT ( start_document_in )) THEN IF ( start_document_in ) THEN WRITE ( UNIT , '(A3)' ) \"---\" initial_offset = 1 END IF END IF END SUBROUTINE ActivateLogger !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Deactivate the logger. SUBROUTINE DeactivateLogger IsActive = . FALSE . IF ( file_open ) THEN CLOSE ( UNIT ) END IF UNIT = 6 CurrentLevel = 0 END SUBROUTINE DeactivateLogger !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Check if the logger is currently active FUNCTION IsLoggerActive () RESULT ( active ) LOGICAL :: active active = IsActive END FUNCTION IsLoggerActive !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Call this subroutine when you enter into a section with verbose output SUBROUTINE EnterSubLog CurrentLevel = CurrentLevel + 1 END SUBROUTINE EnterSubLog !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Call this subroutine when you exit a section with verbose output SUBROUTINE ExitSubLog CurrentLevel = CurrentLevel - 1 END SUBROUTINE ExitSubLog !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set a manual initial offset spacing. SUBROUTINE SetInitialOffset ( offset ) !> Number of spaces to offset INTEGER , INTENT ( IN ) :: offset initial_offset = offset END SUBROUTINE SetInitialOffset !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a header to the log. SUBROUTINE WriteHeader ( header_value ) !> The text of the header. CHARACTER ( LEN =* ), INTENT ( IN ) :: header_value IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) header_value WRITE ( UNIT , '(A1)' ) \":\" END IF END SUBROUTINE WriteHeader !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_bool ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. LOGICAL , INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key IF ( VALUE ) THEN WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": True\" ELSE WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": False\" END IF WRITE ( UNIT , * ) END IF END SUBROUTINE WriteElement_bool !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_float ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A float value to write. REAL ( NTReal ), INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(ES22.14)' , ADVANCE = 'no' ) VALUE WRITE ( UNIT , * ) END IF END SUBROUTINE WriteElement_float !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_int ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. INTEGER , INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(I20)' , ADVANCE = 'no' ) VALUE WRITE ( UNIT , * ) END IF END SUBROUTINE WriteElement_int !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a element. SUBROUTINE WriteElement_string ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A text value to write. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) VALUE WRITE ( UNIT , * ) END IF END SUBROUTINE WriteElement_string !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_bool ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A bool value to write. LOGICAL , INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key IF ( VALUE ) THEN WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": True\" ELSE WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": False\" END IF WRITE ( UNIT , * ) END IF END SUBROUTINE WriteListElement_bool !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_float ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A float value to write. REAL ( NTReal ), INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(ES22.14)' , ADVANCE = 'no' ) VALUE WRITE ( UNIT , * ) END IF END SUBROUTINE WriteListElement_float !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_int ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> An integer value to write. INTEGER , INTENT ( IN ) :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(I10)' , ADVANCE = 'no' ) VALUE WRITE ( UNIT , * ) END IF END SUBROUTINE WriteListElement_int !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Write out a list element. SUBROUTINE WriteListElement_string ( key , VALUE ) !> Some text to write. CHARACTER ( LEN =* ), INTENT ( IN ) :: key !> A text value to write. CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: VALUE IF ( IsActive ) THEN CALL WriteIndent WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \"- \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) key IF ( PRESENT ( VALUE )) THEN WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) \": \" WRITE ( UNIT , '(A)' , ADVANCE = 'no' ) VALUE END IF WRITE ( UNIT , * ) END IF END SUBROUTINE WriteListElement_string !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Writes out the indentation needed for this level SUBROUTINE WriteIndent INTEGER :: II DO II = 1 , initial_offset WRITE ( UNIT , '(A1)' , ADVANCE = 'NO' ) \" \" END DO DO II = 1 , CurrentLevel * 2 WRITE ( UNIT , '(A1)' , ADVANCE = 'NO' ) \" \" END DO END SUBROUTINE WriteIndent !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Set the logging level manually SUBROUTINE SetLoggerLevel ( level ) INTEGER , INTENT ( IN ) :: level CurrentLevel = level END SUBROUTINE SetLoggerLevel !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Get the current logging level FUNCTION GetLoggerLevel () RESULT ( level ) INTEGER :: level level = CurrentLevel END FUNCTION GetLoggerLevel !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE LoggingModule","tags":"","loc":"sourcefile/loggingmodule.f90.html"},{"title":"PSMatrixAlgebraModule.F90 – NTPoly","text":"Contents Modules PSMatrixAlgebraModule Source Code PSMatrixAlgebraModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Performing Distributed Sparse Matrix Algebra Operations. MODULE PSMatrixAlgebraModule USE DataTypesModule , ONLY : NTREAL , MPINTREAL , NTCOMPLEX , MPINTCOMPLEX USE GemmTasksModule USE MatrixReduceModule , ONLY : ReduceHelper_t , ReduceAndComposeMatrixSizes , & & ReduceAndComposeMatrixData , ReduceAndComposeMatrixCleanup , & & ReduceAndSumMatrixSizes , ReduceAndSumMatrixData , & & ReduceAndSumMatrixCleanup , TestReduceSizeRequest , & & TestReduceInnerRequest , TestReduceDataRequest USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & CheckMemoryPoolValidity , DestructMatrixMemoryPool , & & ConstructMatrixMemoryPool USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , ConvertMatrixToComplex , ConjugateMatrix , & & MergeMatrixLocalBlocks , IsIdentity USE SMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixGrandSum , & & PairwiseMultiplyMatrix , IncrementMatrix , ScaleMatrix , & & MatrixColumnNorm USE SMatrixModule , ONLY : Matrix_lsr , Matrix_lsc , DestructMatrix , CopyMatrix ,& & TransposeMatrix , ComposeMatrixColumns , MatrixToTripletList USE TripletListModule , ONLY : TripletList_r , TripletList_c USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: MatrixSigma PUBLIC :: MatrixMultiply PUBLIC :: MatrixGrandSum PUBLIC :: PairwiseMultiplyMatrix PUBLIC :: MatrixNorm PUBLIC :: DotMatrix PUBLIC :: IncrementMatrix PUBLIC :: ScaleMatrix PUBLIC :: MatrixTrace PUBLIC :: SimilarityTransform !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE MatrixSigma MODULE PROCEDURE MatrixSigma_ps END INTERFACE MatrixSigma INTERFACE MatrixMultiply MODULE PROCEDURE MatrixMultiply_ps END INTERFACE MatrixMultiply INTERFACE MatrixGrandSum MODULE PROCEDURE MatrixGrandSum_psr MODULE PROCEDURE MatrixGrandSum_psc END INTERFACE MatrixGrandSum INTERFACE PairwiseMultiplyMatrix MODULE PROCEDURE PairwiseMultiplyMatrix_ps END INTERFACE PairwiseMultiplyMatrix INTERFACE MatrixNorm MODULE PROCEDURE MatrixNorm_ps END INTERFACE MatrixNorm INTERFACE DotMatrix MODULE PROCEDURE DotMatrix_psr MODULE PROCEDURE DotMatrix_psc END INTERFACE DotMatrix INTERFACE IncrementMatrix MODULE PROCEDURE IncrementMatrix_ps END INTERFACE IncrementMatrix INTERFACE ScaleMatrix MODULE PROCEDURE ScaleMatrix_psr MODULE PROCEDURE ScaleMatrix_psc END INTERFACE ScaleMatrix INTERFACE MatrixTrace MODULE PROCEDURE MatrixTrace_psr END INTERFACE MatrixTrace CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute sigma for the inversion method. !> See \\cite ozaki2001efficient for details. SUBROUTINE MatrixSigma_ps ( this , sigma_value ) !> The matrix to compute the sigma value of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> Sigma REAL ( NTREAL ), INTENT ( OUT ) :: sigma_value !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: column_sigma_contribution !! Counters/Temporary INTEGER :: II , JJ TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define LMAT merged_local_data_c #include \"distributed_algebra_includes/MatrixSigma.f90\" #undef LMAT ELSE #define LMAT merged_local_data_r #include \"distributed_algebra_includes/MatrixSigma.f90\" #undef LMAT ENDIF END SUBROUTINE MatrixSigma_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Multiply two matrices together, and add to the third. !> C := alpha*matA*matB+ beta*matC SUBROUTINE MatrixMultiply_ps ( matA , matB , matC , alpha_in , beta_in , & & threshold_in , memory_pool_in ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> matC = alpha*matA*matB + beta*matC TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC !> Scales the multiplication REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> Scales matrix we sum on to. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: beta_in !> For flushing values to zero. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> A memory pool for the calculation. TYPE ( MatrixMemoryPool_p ), OPTIONAL , INTENT ( INOUT ) :: memory_pool_in !! Local Versions of Optional Parameter TYPE ( Matrix_ps ) :: matAConverted TYPE ( Matrix_ps ) :: matBConverted REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: beta REAL ( NTREAL ) :: threshold TYPE ( MatrixMemoryPool_p ) :: memory_pool !! Handle the optional parameters IF (. NOT . PRESENT ( alpha_in )) THEN alpha = 1.0_NTREAL ELSE alpha = alpha_in END IF IF (. NOT . PRESENT ( beta_in )) THEN beta = 0.0_NTREAL ELSE beta = beta_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN threshold = 0.0_NTREAL ELSE threshold = threshold_in END IF !! Setup Memory Pool IF ( PRESENT ( memory_pool_in )) THEN IF ( matA % is_complex ) THEN IF (. NOT . CheckMemoryPoolValidity ( memory_pool_in , matA )) THEN CALL DestructMatrixMemoryPool ( memory_pool_in ) CALL ConstructMatrixMemoryPool ( memory_pool_in , matA ) END IF ELSE IF (. NOT . CheckMemoryPoolValidity ( memory_pool_in , matB )) THEN CALL DestructMatrixMemoryPool ( memory_pool_in ) CALL ConstructMatrixMemoryPool ( memory_pool_in , matB ) END IF END IF ELSE IF ( matA % is_complex ) THEN CALL ConstructMatrixMemoryPool ( memory_pool , matA ) ELSE CALL ConstructMatrixMemoryPool ( memory_pool , matB ) END IF END IF !! Perform Upcasting IF ( matB % is_complex . AND . . NOT . matA % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , matAConverted ) IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_psc ( matAConverted , matB , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_psc ( matAConverted , matB , matC , alpha , beta , & & threshold , memory_pool ) END IF ELSE IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , matBConverted ) IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_psc ( matA , matBConverted , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_psc ( matA , matBConverted , matC , alpha , beta , & & threshold , memory_pool ) END IF ELSE IF ( matA % is_complex . AND . matB % is_complex ) THEN IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_psc ( matA , matB , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_psc ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) END IF ELSE IF ( PRESENT ( memory_pool_in )) THEN CALL MatrixMultiply_psr ( matA , matB , matC , alpha , beta , & & threshold , memory_pool_in ) ELSE CALL MatrixMultiply_psr ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) END IF END IF CALL DestructMatrixMemoryPool ( memory_pool ) CALL DestructMatrix ( matAConverted ) CALL DestructMatrix ( matBConverted ) END SUBROUTINE MatrixMultiply_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The actual implementation of matrix multiply is here. Takes the !> same parameters as the standard multiply, but nothing is optional. SUBROUTINE MatrixMultiply_psr ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) !! Parameters TYPE ( Matrix_ps ), INTENT ( IN ) :: matA TYPE ( Matrix_ps ), INTENT ( IN ) :: matB TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC REAL ( NTREAL ), INTENT ( IN ) :: alpha REAL ( NTREAL ), INTENT ( IN ) :: beta REAL ( NTREAL ), INTENT ( IN ) :: threshold TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: memory_pool !! Temporary Matrices TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: AdjacentABlocks TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: LocalRowContribution TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredRowContribution TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredRowContributionT TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: TransposedBBlocks TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: LocalColumnContribution TYPE ( Matrix_lsr ), DIMENSION (:), ALLOCATABLE :: GatheredColumnContribution TYPE ( Matrix_lsr ), DIMENSION (:,:), ALLOCATABLE :: SliceContribution #define LMAT local_data_r #define MPGRID memory_pool%grid_r #include \"distributed_algebra_includes/MatrixMultiply.f90\" #undef LMAT #undef MPGRID END SUBROUTINE MatrixMultiply_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> The actual implementation of matrix multiply is here. Takes the !> same parameters as the standard multiply, but nothing is optional. SUBROUTINE MatrixMultiply_psc ( matA , matB , matC , alpha , beta , & & threshold , memory_pool ) !! Parameters TYPE ( Matrix_ps ), INTENT ( IN ) :: matA TYPE ( Matrix_ps ), INTENT ( IN ) :: matB TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC REAL ( NTREAL ), INTENT ( IN ) :: alpha REAL ( NTREAL ), INTENT ( IN ) :: beta REAL ( NTREAL ), INTENT ( IN ) :: threshold TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ) :: memory_pool !! Temporary Matrices TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: AdjacentABlocks TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: LocalRowContribution TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredRowContribution TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredRowContributionT TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: TransposedBBlocks TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: LocalColumnContribution TYPE ( Matrix_lsc ), DIMENSION (:), ALLOCATABLE :: GatheredColumnContribution TYPE ( Matrix_lsc ), DIMENSION (:,:), ALLOCATABLE :: SliceContribution #define LMAT local_data_c #define MPGRID memory_pool%grid_c #include \"distributed_algebra_includes/MatrixMultiply.f90\" #undef LMAT #undef MPGRID END SUBROUTINE MatrixMultiply_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum up the elements in a matrix into a single value. SUBROUTINE MatrixGrandSum_psr ( this , sum ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The sum of all elements. REAL ( NTREAL ), INTENT ( OUT ) :: sum !! Local Data INTEGER :: II , JJ REAL ( NTREAL ) :: temp_r COMPLEX ( NTCOMPLEX ) :: temp_c INTEGER :: ierr #define MPIDATATYPE MPINTREAL IF ( this % is_complex ) THEN #define TEMP temp_c #define LMAT local_data_c #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP ELSE #define TEMP temp_r #define LMAT local_data_r #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP END IF #undef MPIDATATYPE END SUBROUTINE MatrixGrandSum_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Sum up the elements in a matrix into a single value. SUBROUTINE MatrixGrandSum_psc ( this , sum ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The sum of all elements. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: sum !! Local Data INTEGER :: II , JJ REAL ( NTREAL ) :: temp_r COMPLEX ( NTCOMPLEX ) :: temp_c INTEGER :: ierr #define MPIDATATYPE MPINTCOMPLEX IF ( this % is_complex ) THEN #define TEMP temp_c #define LMAT local_data_c #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP ELSE #define TEMP temp_r #define LMAT local_data_r #include \"distributed_algebra_includes/MatrixGrandSum.f90\" #undef LMAT #undef TEMP END IF #undef MPIDATATYPE END SUBROUTINE MatrixGrandSum_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Elementwise multiplication. C_ij = A_ij * B_ij. !> Also known as a Hadamard product. RECURSIVE SUBROUTINE PairwiseMultiplyMatrix_ps ( matA , matB , matC ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> matC = MatA mult MatB. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matC !! Local Data TYPE ( Matrix_ps ) :: converted_matrix INTEGER :: II , JJ IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , converted_matrix ) CALL PairwiseMultiplyMatrix ( matA , converted_matrix , matC ) CALL DestructMatrix ( converted_matrix ) ELSE IF (. NOT . matA % is_complex . AND . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , converted_matrix ) CALL PairwiseMultiplyMatrix ( converted_matrix , matB , matC ) CALL DestructMatrix ( converted_matrix ) ELSE IF ( matA % is_complex . AND . matB % is_complex ) THEN #define LMAT local_data_c #include \"distributed_algebra_includes/PairwiseMultiply.f90\" #undef LMAT ELSE #define LMAT local_data_r #include \"distributed_algebra_includes/PairwiseMultiply.f90\" #undef LMAT END IF END SUBROUTINE PairwiseMultiplyMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the norm of a distributed sparse matrix along the rows. FUNCTION MatrixNorm_ps ( this ) RESULT ( norm_value ) !> The matrix to compute the norm of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The norm value of the full distributed sparse matrix. REAL ( NTREAL ) :: norm_value !! Local Data REAL ( NTREAL ), DIMENSION (:), ALLOCATABLE :: local_norm TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define LMAT merged_local_data_c #include \"distributed_algebra_includes/MatrixNorm.f90\" #undef LMAT ELSE #define LMAT merged_local_data_r #include \"distributed_algebra_includes/MatrixNorm.f90\" #undef LMAT END IF END FUNCTION MatrixNorm_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(Matrix A,Matrix B) !> Note that a dot product is the sum of elementwise multiplication, not !> traditional matrix multiplication. SUBROUTINE DotMatrix_psr ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> The dot product. REAL ( NTREAL ), INTENT ( OUT ) :: product #include \"distributed_algebra_includes/DotMatrix.f90\" END SUBROUTINE DotMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(Matrix A,Matrix B) !> Note that a dot product is the sum of elementwise multiplication, not !> traditional matrix multiplication. SUBROUTINE DotMatrix_psc ( matA , matB , product ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( IN ) :: matB !> The dot product. COMPLEX ( NTCOMPLEX ), INTENT ( OUT ) :: product #include \"distributed_algebra_includes/DotMatrix.f90\" END SUBROUTINE DotMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Matrix B = alpha*Matrix A + Matrix B (AXPY) !> This will utilize the sparse vector increment routine. RECURSIVE SUBROUTINE IncrementMatrix_ps ( matA , matB , alpha_in , threshold_in ) !> Matrix A. TYPE ( Matrix_ps ), INTENT ( IN ) :: matA !> Matrix B. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: matB !> Multiplier (default = 1.0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> For flushing values to zero (default = 0). REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !! Local Data TYPE ( Matrix_ps ) :: converted_matrix REAL ( NTREAL ) :: alpha REAL ( NTREAL ) :: threshold INTEGER :: II , JJ !! Optional Parameters IF (. NOT . PRESENT ( alpha_in )) THEN alpha = 1.0_NTREAL ELSE alpha = alpha_in END IF IF (. NOT . PRESENT ( threshold_in )) THEN threshold = 0.0_NTREAL ELSE threshold = threshold_in END IF IF ( matA % is_complex . AND . . NOT . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matB , converted_matrix ) CALL IncrementMatrix ( matA , converted_matrix , alpha , threshold ) CALL CopyMatrix ( converted_matrix , matB ) ELSE IF (. NOT . matA % is_complex . AND . matB % is_complex ) THEN CALL ConvertMatrixToComplex ( matA , converted_matrix ) CALL IncrementMatrix ( converted_matrix , matB , alpha , threshold ) ELSE IF ( matA % is_complex . AND . matB % is_complex ) THEN #define LMAT local_data_c #include \"distributed_algebra_includes/IncrementMatrix.f90\" #undef LMAT ELSE #define LMAT local_data_r #include \"distributed_algebra_includes/IncrementMatrix.f90\" #undef LMAT END IF CALL DestructMatrix ( converted_matrix ) END SUBROUTINE IncrementMatrix_ps !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a distributed sparse matrix by a constant. SUBROUTINE ScaleMatrix_psr ( this , constant ) !> Matrix to scale. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A constant scale factor. REAL ( NTREAL ), INTENT ( IN ) :: constant !! Local Data INTEGER :: II , JJ IF ( this % is_complex ) THEN #define LOCALDATA local_data_c #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA ELSE #define LOCALDATA local_data_r #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA END IF END SUBROUTINE ScaleMatrix_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Will scale a distributed sparse matrix by a constant. RECURSIVE SUBROUTINE ScaleMatrix_psc ( this , constant ) !> Matrix to scale. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: this !> A constant scale factor. COMPLEX ( NTCOMPLEX ), INTENT ( IN ) :: constant !! Local Data TYPE ( Matrix_ps ) :: this_c INTEGER :: II , JJ IF ( this % is_complex ) THEN #define LOCALDATA local_data_c #include \"distributed_algebra_includes/ScaleMatrix.f90\" #undef LOCALDATA ELSE CALL ConvertMatrixToComplex ( this , this_c ) CALL ScaleMatrix_psc ( this_c , constant ) CALL CopyMatrix ( this_c , this ) CALL DestructMatrix ( this_c ) END IF END SUBROUTINE ScaleMatrix_psc !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the trace of the matrix. SUBROUTINE MatrixTrace_psr ( this , trace_value ) !> The matrix to compute the trace of. TYPE ( Matrix_ps ), INTENT ( IN ) :: this !> The trace value of the full distributed sparse matrix. REAL ( NTREAL ), INTENT ( OUT ) :: trace_value !! Local data TYPE ( TripletList_r ) :: triplet_list_r TYPE ( TripletList_c ) :: triplet_list_c !! Counters/Temporary INTEGER :: II TYPE ( Matrix_lsr ) :: merged_local_data_r TYPE ( Matrix_lsc ) :: merged_local_data_c INTEGER :: ierr IF ( this % is_complex ) THEN #define TLIST triplet_list_c #define LMAT merged_local_data_c #define MPIDATATYPE MPINTCOMPLEX #include \"distributed_algebra_includes/MatrixTrace.f90\" #undef MPIDATATYPE #undef LMAT #undef TLIST ELSE #define TLIST triplet_list_r #define LMAT merged_local_data_r #define MPIDATATYPE MPINTREAL #include \"distributed_algebra_includes/MatrixTrace.f90\" #undef MPIDATATYPE #undef LMAT #undef TLIST END IF END SUBROUTINE MatrixTrace_psr !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Transform a matrix B = P * A * P&#94;-1 !! This routine will check if P is the identity matrix, and if so !! just return A. SUBROUTINE SimilarityTransform ( A , P , PInv , ResMat , pool_in , threshold_in ) !> The matrix to transform TYPE ( Matrix_ps ), INTENT ( IN ) :: A !> The left matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: P !> The right matrix. TYPE ( Matrix_ps ), INTENT ( IN ) :: PInv !> The computed matrix P * A * P&#94;-1 TYPE ( Matrix_ps ), INTENT ( INOUT ) :: ResMat !> A matrix memory pool. TYPE ( MatrixMemoryPool_p ), INTENT ( INOUT ), OPTIONAL :: pool_in !> The threshold for removing small elements. REAL ( NTREAL ), INTENT ( IN ), OPTIONAL :: threshold_in !! Local variables TYPE ( MatrixMemoryPool_p ) :: pool TYPE ( Matrix_ps ) :: TempMat REAL ( NTREAL ) :: threshold !! Optional Parameters IF (. NOT . PRESENT ( threshold_in )) THEN threshold = 0.0_NTREAL ELSE threshold = threshold_in END IF IF (. NOT . PRESENT ( pool_in )) THEN CALL ConstructMatrixMemoryPool ( pool , A ) END IF !! Check if P is the identity matrix, if so we can exit early. IF ( IsIdentity ( P )) THEN CALL CopyMatrix ( A , ResMat ) ELSE !! Compute IF ( PRESENT ( pool_in )) THEN CALL MatrixMultiply ( P , A , TempMat , & & threshold_in = threshold , memory_pool_in = pool_in ) CALL MatrixMultiply ( TempMat , PInv , ResMat , & & threshold_in = threshold , memory_pool_in = pool_in ) ELSE CALL MatrixMultiply ( P , A , TempMat , & & threshold_in = threshold , memory_pool_in = pool ) CALL MatrixMultiply ( TempMat , PInv , ResMat , & & threshold_in = threshold , memory_pool_in = pool ) END IF END IF !! Cleanup IF (. NOT . PRESENT ( pool_in )) THEN CALL DestructMatrixMemoryPool ( pool ) END IF CALL DestructMatrix ( TempMat ) END SUBROUTINE SimilarityTransform !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE PSMatrixAlgebraModule","tags":"","loc":"sourcefile/psmatrixalgebramodule.f90.html"},{"title":"ErrorModule.F90 – NTPoly","text":"Contents Modules ErrorModule Source Code ErrorModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module to do handle error passing. MODULE ErrorModule USE NTMPIModule IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: ConstructError PUBLIC :: SetGenericError PUBLIC :: SetCustomError PUBLIC :: CheckMPIError PUBLIC :: CheckAllocError PUBLIC :: ErrorOccurred PUBLIC :: PrintError PUBLIC :: Cleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A type that can be passed around to accumulate errors. TYPE , PUBLIC :: Error_t PRIVATE !> Flag for whether or not an error has occurred. LOGICAL :: error_set !> Detailed description of the error. CHARACTER ( LEN = 1000 ) :: error_description !> Store a failed MPI call error. INTEGER :: mpi_error !> Flag for whether mpi error occurred. LOGICAL :: mpi_error_set !> Store a bad allocation call error. INTEGER :: alloc_error !> Flag for whether alloc error occurred. LOGICAL :: alloc_error_set !> Store a custom error. INTEGER :: custom_error !> Flag for whether a custom error occurred. LOGICAL :: custom_error_set END TYPE Error_t CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Default constructor for an error type. SUBROUTINE ConstructError ( this ) !> The newly constructed error type TYPE ( Error_t ), INTENT ( INOUT ) :: this this % error_set = . FALSE . this % mpi_error_set = . FALSE . this % alloc_error_set = . FALSE . END SUBROUTINE ConstructError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call if a generic error has occurred. SUBROUTINE SetGenericError ( this , error_description , immediate_cleanup_in ) !> The error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( LEN = * ), INTENT ( in ) :: error_description !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments immediate_cleanup = . FALSE . IF ( PRESENT ( immediate_cleanup_in )) immediate_cleanup = immediate_cleanup_in !! Set Flags and Variables this % error_description = error_description this % error_set = . TRUE . IF ( immediate_cleanup ) THEN CALL Cleanup ( this ) END IF END SUBROUTINE SetGenericError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! SUBROUTINE SetCustomError ( this , error_code , error_description , & & immediate_cleanup_in ) TYPE ( Error_t ), INTENT ( INOUT ) :: this INTEGER , INTENT ( IN ) :: error_code CHARACTER ( LEN = * ), INTENT ( IN ) :: error_description LOGICAL , INTENT ( IN ), OPTIONAL :: immediate_cleanup_in !! Local Data LOGICAL :: immediate_cleanup immediate_cleanup = . FALSE . IF ( PRESENT ( immediate_cleanup_in )) immediate_cleanup = immediate_cleanup_in this % error_description = error_description this % error_set = . TRUE . this % custom_error = error_code this % custom_error_set = . TRUE . IF ( immediate_cleanup ) THEN CALL Cleanup ( this ) END IF END SUBROUTINE SetCustomError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call to check if an MPI error has occurred. FUNCTION CheckMPIError ( this , error_description , mpi_error , & & immediate_cleanup_in ) RESULT ( error_occurred ) !> The error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( LEN = * ), INTENT ( in ) :: error_description !> The error variable produced by mpi. INTEGER , INTENT ( in ) :: mpi_error !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !> True if an error has occurred, false otherwise. LOGICAL :: error_occurred !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments immediate_cleanup = . FALSE . IF ( PRESENT ( immediate_cleanup_in )) immediate_cleanup = immediate_cleanup_in !! Check Error IF (. NOT . mpi_error . EQ . MPI_SUCCESS ) THEN this % mpi_error_set = . TRUE . this % mpi_error = mpi_error CALL SetGenericError ( this , error_description , immediate_cleanup ) END IF error_occurred = ErrorOccurred ( this ) END FUNCTION CheckMPIError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Routine to call if an alloc error has occurred. FUNCTION CheckAllocError ( this , error_description , alloc_error , & & immediate_cleanup_in ) RESULT ( error_occurred ) !> This the error variable to be set. TYPE ( Error_t ), INTENT ( inout ) :: this !> Some string describing the details of the error. CHARACTER ( LEN = * ), INTENT ( in ) :: error_description !> The error variable produced by alloc. INTEGER , INTENT ( in ) :: alloc_error !> If true, the cleanup error handler is called. LOGICAL , INTENT ( in ), OPTIONAL :: immediate_cleanup_in !> True if an error has occurred, false otherwise. LOGICAL :: error_occurred !! Local Data LOGICAL :: immediate_cleanup !! Process Optional Arguments IF ( PRESENT ( immediate_cleanup_in )) immediate_cleanup = immediate_cleanup_in !! Check Error IF (. NOT . alloc_error . EQ . 0 ) THEN this % alloc_error_set = . TRUE . this % alloc_error = alloc_error CALL SetGenericError ( this , error_description , immediate_cleanup ) END IF error_occurred = ErrorOccurred ( this ) END FUNCTION CheckAllocError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Check if an error has occurred or not. FUNCTION ErrorOccurred ( this ) RESULT ( occurred ) !> The error variable to check. TYPE ( Error_t ), INTENT ( in ) :: this !> True if an error has occurred, false otherwise. LOGICAL :: occurred occurred = this % error_set END FUNCTION ErrorOccurred !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Print out that an error has occurred. SUBROUTINE PrintError ( this ) !> The error to print out. TYPE ( Error_t ), INTENT ( in ) :: this !! Local Data CHARACTER ( LEN = 80 ) :: error_string INTEGER :: error_string_len INTEGER :: error_string_error !! Print Out Information About The Error IF ( ErrorOccurred ( this )) THEN WRITE ( * , '(A)' ) \"# An error has occurred.\" IF ( this % alloc_error_set ) THEN WRITE ( * , '(A)' ) \"# Of type: alloc error.\" WRITE ( * , '(I3)' ) this % alloc_error ELSE IF ( this % mpi_error_set ) THEN WRITE ( * , '(A)' ) \"# Of type: mpi error.\" CALL MPI_Error_String ( this % mpi_error , error_string , & & error_string_len , error_string_error ) WRITE ( * , '(A)' ) TRIM ( error_string ) ELSE WRITE ( * , '(A)' ) \"# Of type: generic error.\" END IF WRITE ( * , '(A)' ) \"# Details:\" WRITE ( * , '(A)' , ADVANCE = 'no' ) \"#\" WRITE ( * , '(A)' ) TRIM ( this % error_description ) ELSE WRITE ( * , '(A)' ) \"# No Error Occured, but PrintError was Called\" END IF END SUBROUTINE PrintError !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> As a last case resort, this will print an error message and quit. SUBROUTINE Cleanup ( this ) !> The error which has caused the need to cleanup the program. TYPE ( Error_t ), INTENT ( in ) :: this !! Local Data INTEGER :: abort_error CALL PrintError ( this ) IF ( this % mpi_error_set ) THEN CALL MPI_Abort ( MPI_COMM_WORLD , this % mpi_error , abort_error ) ELSE CALL MPI_Abort ( MPI_COMM_WORLD , MPI_ERR_UNKNOWN , abort_error ) END IF END SUBROUTINE Cleanup !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE ErrorModule","tags":"","loc":"sourcefile/errormodule.f90.html"},{"title":"SquareRootSolversModule.F90 – NTPoly","text":"Contents Modules SquareRootSolversModule Source Code SquareRootSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Square Root of a Matrix. MODULE SquareRootSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenBoundsModule , ONLY : GershgorinBounds USE EigenSolversModule , ONLY : DenseMatrixFunction USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteListElement , & & WriteHeader , WriteElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , MatrixNorm , & & IncrementMatrix , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , ConstructSolverParameters , & & CopySolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: SquareRoot PUBLIC :: DenseSquareRoot PUBLIC :: InverseSquareRoot PUBLIC :: DenseInverseSquareRoot CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root of a matrix. SUBROUTINE SquareRoot ( InputMat , OutputMat , solver_parameters_in , order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !> Order of polynomial for calculation (default 5). INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Call routine with the desired order. IF ( PRESENT ( order_in )) THEN CALL SquareRootSelector ( InputMat , OutputMat , params , . FALSE .,& & order_in ) ELSE CALL SquareRootSelector ( InputMat , OutputMat , params , . FALSE .) END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE SquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the matrix square root function (dense version). SUBROUTINE DenseSquareRoot ( Mat , OutputMat , solver_parameters_in ) !> The matrix to compute the square root of. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The computed matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Square Root Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( Mat , OutputMat , SquareRootLambda , & & params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE DenseSquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the inverse square root of a matrix. SUBROUTINE InverseSquareRoot ( InputMat , OutputMat , solver_parameters_in , & & order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The resulting matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !> Order of polynomial for calculation (default 5). INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF !! Call routine with the desired order. IF ( PRESENT ( order_in )) THEN CALL SquareRootSelector ( InputMat , OutputMat , params , . TRUE ., order_in ) ELSE CALL SquareRootSelector ( InputMat , OutputMat , params , . TRUE .) END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE InverseSquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Computes the matrix inverse square root function (dense version). SUBROUTINE DenseInverseSquareRoot ( Mat , OutputMat , solver_parameters_in ) !> The matrix to compute the inverse square root of. TYPE ( Matrix_ps ), INTENT ( IN ) :: Mat !> The computed matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Square Root Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( Mat , OutputMat , InverseSquareRootLambda , params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE DenseInverseSquareRoot !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> This routine picks the appropriate solver method SUBROUTINE SquareRootSelector ( InputMat , OutputMat , params , & & compute_inverse , order_in ) !> The matrix to compute. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The Matrix computed. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters about how to solve. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> True if we are computing the inverse square root. LOGICAL , INTENT ( IN ) :: compute_inverse !> The polynomial degree to use (optional, default = 5) INTEGER , INTENT ( IN ), OPTIONAL :: order_in !! Local Variables INTEGER :: order IF ( PRESENT ( order_in )) THEN order = order_in ELSE order = 5 END IF SELECT CASE ( order ) CASE ( 2 ) CALL NewtonSchultzISROrder2 ( InputMat , OutputMat , params , & & compute_inverse ) CASE DEFAULT CALL NewtonSchultzISRTaylor ( InputMat , OutputMat , params , & & order , compute_inverse ) END SELECT END SUBROUTINE SquareRootSelector !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root or inverse square root of a matrix. !> Based on the Newton-Schultz algorithm presented in: \\cite jansik2007linear SUBROUTINE NewtonSchultzISROrder2 ( InMat , OutMat , params , compute_inverse ) !> The matrix to compute TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> Mat&#94;-1/2 or Mat&#94;1/2. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> Whether to compute the inverse square root. LOGICAL , INTENT ( IN ) :: compute_inverse !! Local Variables REAL ( NTREAL ) :: lambda TYPE ( Matrix_ps ) :: X_k , T_k , Temp , Identity TYPE ( Matrix_ps ) :: SquareRootMat TYPE ( Matrix_ps ) :: InverseSquareRootMat !! Temporary Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: max_between INTEGER :: II REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: mpool IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Newton Schultz Inverse Square Root\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"jansik2007linear\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( X_k , InMat ) CALL ConstructEmptyMatrix ( SquareRootMat , InMat ) CALL ConstructEmptyMatrix ( InverseSquareRootMat , InMat ) CALL ConstructEmptyMatrix ( T_k , InMat ) CALL ConstructEmptyMatrix ( Temp , InMat ) CALL ConstructEmptyMatrix ( Identity , InMat ) CALL FillMatrixIdentity ( Identity ) !! Compute the lambda scaling value. CALL GershgorinBounds ( InMat , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0 / max_between !! Initialize CALL FillMatrixIdentity ( InverseSquareRootMat ) CALL CopyMatrix ( InMat , SquareRootMat ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( SquareRootMat , SquareRootMat , & & params % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( InverseSquareRootMat , InverseSquareRootMat , & & params % BalancePermutation , memorypool_in = mpool ) END IF !! Iterate. IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations !! Compute X_k CALL MatrixMultiply ( SquareRootMat , InverseSquareRootMat , X_k , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL GershgorinBounds ( X_k , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0 / max_between CALL ScaleMatrix ( X_k , lambda ) !! Check if Converged CALL CopyMatrix ( Identity , Temp ) CALL IncrementMatrix ( X_k , Temp , & & alpha_in = - 1.0_NTREAL ) norm_value = MatrixNorm ( Temp ) !! Compute T_k CALL CopyMatrix ( Identity , T_k ) CALL ScaleMatrix ( T_k , 3.0_NTREAL ) CALL IncrementMatrix ( X_k , T_k , & & alpha_in = - 1.0_NTREAL ) CALL ScaleMatrix ( T_k , 0.5_NTREAL ) !! Compute Z_k+1 CALL CopyMatrix ( InverseSquareRootMat , Temp ) CALL MatrixMultiply ( Temp , T_k , InverseSquareRootMat , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL ScaleMatrix ( InverseSquareRootMat , SQRT ( lambda )) !! Compute Y_k+1 CALL CopyMatrix ( SquareRootMat , Temp ) CALL MatrixMultiply ( T_k , Temp , SquareRootMat , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL ScaleMatrix ( SquareRootMat , SQRT ( lambda )) IF ( params % be_verbose ) THEN CALL WriteElement ( key = \"Convergence\" , VALUE = norm_value ) END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( InverseSquareRootMat ) END IF IF ( compute_inverse ) THEN CALL CopyMatrix ( InverseSquareRootMat , OutMat ) ELSE CALL CopyMatrix ( SquareRootMat , OutMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & params % BalancePermutation , memorypool_in = mpool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( Temp ) CALL DestructMatrix ( X_k ) CALL DestructMatrix ( SquareRootMat ) CALL DestructMatrix ( InverseSquareRootMat ) CALL DestructMatrix ( T_k ) CALL DestructMatrixMemoryPool ( mpool ) END SUBROUTINE NewtonSchultzISROrder2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the square root or inverse square root of a matrix. !> Based on the Newton-Schultz algorithm with higher order polynomials. SUBROUTINE NewtonSchultzISRTaylor ( InMat , OutMat , params , & & taylor_order , compute_inverse ) !> Matrix to Compute TYPE ( Matrix_ps ), INTENT ( IN ) :: InMat !> Mat&#94;-1/2 or Mat&#94;1/2. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutMat !> Parameters for the solver. TYPE ( SolverParameters_t ), INTENT ( IN ) :: params !> Order of polynomial to use. INTEGER , INTENT ( IN ) :: taylor_order !> Whether to compute the inverse square root or not. LOGICAL , INTENT ( IN ) :: compute_inverse !! Local Variables REAL ( NTREAL ) :: lambda REAL ( NTREAL ) :: aa , bb , cc , dd REAL ( NTREAL ) :: a , b , c , d TYPE ( Matrix_ps ) :: X_k , Temp , Temp2 , Identity TYPE ( Matrix_ps ) :: SquareRootMat TYPE ( Matrix_ps ) :: InverseSquareRootMat !! Temporary Variables REAL ( NTREAL ) :: e_min , e_max REAL ( NTREAL ) :: max_between INTEGER :: II REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: mpool IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Newton Schultz Inverse Square Root\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"jansik2007linear\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( X_k , InMat ) CALL ConstructEmptyMatrix ( SquareRootMat , InMat ) CALL ConstructEmptyMatrix ( InverseSquareRootMat , InMat ) CALL ConstructEmptyMatrix ( Temp , InMat ) IF ( taylor_order == 5 ) THEN CALL ConstructEmptyMatrix ( Temp2 , InMat ) END IF CALL ConstructEmptyMatrix ( Identity , InMat ) CALL FillMatrixIdentity ( Identity ) !! Compute the lambda scaling value. CALL GershgorinBounds ( InMat , e_min , e_max ) max_between = MAX ( ABS ( e_min ), ABS ( e_max )) lambda = 1.0_NTREAL / max_between !! Initialize CALL FillMatrixIdentity ( InverseSquareRootMat ) CALL CopyMatrix ( InMat , SquareRootMat ) CALL ScaleMatrix ( SquareRootMat , lambda ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( SquareRootMat , SquareRootMat , & & params % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = mpool ) CALL PermuteMatrix ( InverseSquareRootMat , InverseSquareRootMat , & & params % BalancePermutation , memorypool_in = mpool ) END IF !! Iterate. IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations !! Compute X_k = Z_k * Y_k - I CALL MatrixMultiply ( InverseSquareRootMat , SquareRootMat , X_k , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( Identity , X_k , - 1.0_NTREAL ) norm_value = MatrixNorm ( X_k ) SELECT CASE ( taylor_order ) CASE ( 3 ) !! Compute X_k&#94;2 CALL MatrixMultiply ( X_k , X_k , Temp , & & threshold_in = params % threshold , memory_pool_in = mpool ) !! X_k = I - 1/2 X_k + 3/8 X_k&#94;2 + ... CALL ScaleMatrix ( X_k , - 0.5_NTREAL ) CALL IncrementMatrix ( Identity , X_k ) CALL IncrementMatrix ( Temp , X_k , 0.375_NTREAL ) CASE ( 5 ) !! Compute p(x) = x&#94;4 + A*x&#94;3 + B*x&#94;2 + C*x + D !! Scale to make coefficient of x&#94;4 equal to 1 aa = - 4 0.0_NTREAL / 3 5.0_NTREAL bb = 4 8.0_NTREAL / 3 5.0_NTREAL cc = - 6 4.0_NTREAL / 3 5.0_NTREAL dd = 12 8.0_NTREAL / 3 5.0_NTREAL !! The method of Knuth !! p = (z+x+b) * (z+c) + d !! z = x * (x+a) !! a = (A-1)/2 !! b = B*(a+1) - C - a*(a+1)*(a+1) !! c = B - b - a*(a+1) !! d = D - b*c a = ( aa - 1.0_NTREAL ) / 2.0_NTREAL b = bb * ( a + 1.0_NTREAL ) - cc - a * ( a + 1.0_NTREAL ) ** 2 c = bb - b - a * ( a + 1.0_NTREAL ) d = dd - b * c !! Compute Temp = z = x * (x+a) CALL MatrixMultiply ( X_k , X_k , Temp , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( X_k , Temp , & & alpha_in = a ) !! Compute Temp2 = z + x + b CALL CopyMatrix ( Identity , Temp2 ) CALL ScaleMatrix ( Temp2 , b ) CALL IncrementMatrix ( X_k , Temp2 ) CALL IncrementMatrix ( Temp , Temp2 ) !! Compute Temp = z + c CALL IncrementMatrix ( Identity , Temp , c ) !! Compute X_k = (z+x+b) * (z+c) + d = Temp2 * Temp + d CALL MatrixMultiply ( Temp2 , Temp , X_k , & & threshold_in = params % threshold , memory_pool_in = mpool ) CALL IncrementMatrix ( Identity , X_k , d ) !! Scale back to the target coefficients CALL ScaleMatrix ( X_k , 3 5.0_NTREAL / 12 8.0_NTREAL ) END SELECT !! Compute Z_k+1 = Z_k * X_k CALL CopyMatrix ( InverseSquareRootMat , Temp ) CALL MatrixMultiply ( X_k , Temp , InverseSquareRootMat , & & threshold_in = params % threshold , memory_pool_in = mpool ) !! Compute Y_k+1 = X_k * Y_k CALL CopyMatrix ( SquareRootMat , Temp ) CALL MatrixMultiply ( Temp , X_k , SquareRootMat , & & threshold_in = params % threshold , memory_pool_in = mpool ) IF ( params % be_verbose ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II ) CALL PrintMatrixInformation ( InverseSquareRootMat ) END IF IF ( compute_inverse ) THEN CALL ScaleMatrix ( InverseSquareRootMat , SQRT ( lambda )) CALL CopyMatrix ( InverseSquareRootMat , OutMat ) ELSE CALL ScaleMatrix ( SquareRootMat , 1.0_NTREAL / SQRT ( lambda )) CALL CopyMatrix ( SquareRootMat , OutMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutMat , OutMat , & & params % BalancePermutation , memorypool_in = mpool ) END IF !! Cleanup IF ( params % be_verbose ) THEN CALL ExitSubLog END IF CALL DestructMatrix ( X_k ) CALL DestructMatrix ( SquareRootMat ) CALL DestructMatrix ( InverseSquareRootMat ) CALL DestructMatrix ( Temp ) IF ( taylor_order == 5 ) THEN CALL DestructMatrix ( Temp2 ) END IF CALL DestructMatrix ( Identity ) CALL DestructMatrixMemoryPool ( mpool ) END SUBROUTINE NewtonSchultzISRTaylor !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical square root function. FUNCTION SquareRootLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = SQRT ( val ) END FUNCTION SquareRootLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical inverse square root function. FUNCTION InverseSquareRootLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = 1.0 / SQRT ( val ) END FUNCTION InverseSquareRootLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SquareRootSolversModule","tags":"","loc":"sourcefile/squarerootsolversmodule.f90.html"},{"title":"SVectorModule.F90 – NTPoly","text":"Contents Modules SVectorModule Source Code SVectorModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A module for handling compressed vectors. !> Compressed vectors are stored in two lists. The first is a list of indices, !> the second a list of values. MODULE SVectorModule USE DataTypesModule , ONLY : NTREAL , NTCOMPLEX IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! PUBLIC :: AddSparseVectors PUBLIC :: DotSparseVectors PUBLIC :: PairwiseMultiplyVectors !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! INTERFACE AddSparseVectors MODULE PROCEDURE AddSparseVectors_r MODULE PROCEDURE AddSparseVectors_c END INTERFACE AddSparseVectors INTERFACE DotSparseVectors MODULE PROCEDURE DotSparseVectors_r MODULE PROCEDURE DotSparseVectors_c END INTERFACE DotSparseVectors INTERFACE PairwiseMultiplyVectors MODULE PROCEDURE PairwiseMultiplyVectors_r MODULE PROCEDURE PairwiseMultiplyVectors_c END INTERFACE PairwiseMultiplyVectors CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add together two sparse vectors. C = A + alpha*B !> The values that are returned for C are only valid in the range !> (1:total_values_c). We do not do an automatic shrinking of the array !> to keep this routine low in overhead. PURE SUBROUTINE AddSparseVectors_r ( inner_index_a , values_a , inner_index_b , & & values_b , inner_index_c , values_c , total_values_c , alpha_in , threshold_in ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: values_c !> Value to scale VecB by. Optional, default is 1.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> for flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> The total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Local Variables REAL ( NTREAL ) :: working_value_a , working_value_b #include \"sparse_includes/AddSparseVectors.f90\" END SUBROUTINE AddSparseVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Add together two sparse vectors. C = A + alpha*B !> The values that are returned for C are only valid in the range !> (1:total_values_c). We do not do an automatic shrinking of the array !> to keep this routine low in overhead. PURE SUBROUTINE AddSparseVectors_c ( inner_index_a , values_a , inner_index_b , & & values_b , inner_index_c , values_c , total_values_c , alpha_in , threshold_in ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( OUT ) :: values_c !> Value to scale VecB by. Optional, default is 1.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: alpha_in !> for flushing values to zero. Default value is 0.0. REAL ( NTREAL ), OPTIONAL , INTENT ( IN ) :: threshold_in !> The total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Local Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b #include \"sparse_includes/AddSparseVectors.f90\" END SUBROUTINE AddSparseVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(A,B) PURE FUNCTION DotSparseVectors_r ( inner_index_a , values_a , inner_index_b , & & values_b ) RESULT ( product ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> Dot product. REAL ( NTREAL ) :: product !! Temporary Variables REAL ( NTREAL ) :: working_value_a , working_value_b #include \"sparse_includes/DotSparseVectors.f90\" END FUNCTION DotSparseVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> product = dot(A,B) PURE FUNCTION DotSparseVectors_c ( inner_index_a , values_a , inner_index_b , & & values_b ) RESULT ( product ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> Dot product. COMPLEX ( NTCOMPLEX ) :: product !! Temporary Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b #include \"sparse_includes/DotSparseVectors.f90\" END FUNCTION DotSparseVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply Vectors C = A Mult B PURE SUBROUTINE PairwiseMultiplyVectors_r ( inner_index_a , values_a , & & inner_index_b , values_b , inner_index_c , values_c , total_values_c ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices computed for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. REAL ( NTREAL ), DIMENSION (:), INTENT ( IN ) :: values_b !> List of values computed for C. REAL ( NTREAL ), DIMENSION (:), INTENT ( OUT ) :: values_c !> This is the total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Temporary Variables REAL ( NTREAL ) :: working_value_a , working_value_b #include \"sparse_includes/PairwiseMultiplyVectors.f90\" END SUBROUTINE PairwiseMultiplyVectors_r !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Pairwise Multiply Vectors C = A Mult B PURE SUBROUTINE PairwiseMultiplyVectors_c ( inner_index_a , values_a , & & inner_index_b , values_b , inner_index_c , values_c , total_values_c ) !> List of indices for A. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_a !> List of indices for B. INTEGER , DIMENSION (:), INTENT ( IN ) :: inner_index_b !> List of indices computed for C. INTEGER , DIMENSION (:), INTENT ( OUT ) :: inner_index_c !> List of values for A. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_a !> List of values for B. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( IN ) :: values_b !> This is the total number of values in C. COMPLEX ( NTCOMPLEX ), DIMENSION (:), INTENT ( OUT ) :: values_c !> This is the total number of values in C. INTEGER , INTENT ( OUT ) :: total_values_c !! Temporary Variables COMPLEX ( NTCOMPLEX ) :: working_value_a , working_value_b #include \"sparse_includes/PairwiseMultiplyVectors.f90\" END SUBROUTINE PairwiseMultiplyVectors_c !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE SVectorModule","tags":"","loc":"sourcefile/svectormodule.f90.html"},{"title":"InverseSolversModule.F90 – NTPoly","text":"Contents Modules InverseSolversModule Source Code InverseSolversModule.F90 Source Code !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> A Module For Computing The Inverse of a Matrix. MODULE InverseSolversModule USE DataTypesModule , ONLY : NTREAL USE EigenSolversModule , ONLY : DenseMatrixFunction USE LoadBalancerModule , ONLY : PermuteMatrix , UndoPermuteMatrix USE LoggingModule , ONLY : EnterSubLog , ExitSubLog , WriteHeader , & & WriteElement , WriteListElement USE PMatrixMemoryPoolModule , ONLY : MatrixMemoryPool_p , & & DestructMatrixMemoryPool USE PSMatrixAlgebraModule , ONLY : MatrixMultiply , IncrementMatrix , & & MatrixNorm , MatrixSigma , ScaleMatrix USE PSMatrixModule , ONLY : Matrix_ps , ConstructEmptyMatrix , CopyMatrix , & & DestructMatrix , FillMatrixIdentity , PrintMatrixInformation USE SolverParametersModule , ONLY : SolverParameters_t , PrintParameters , & & DestructSolverParameters , CopySolverParameters , & & ConstructSolverParameters IMPLICIT NONE PRIVATE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !! Solvers PUBLIC :: Invert PUBLIC :: DenseInvert PUBLIC :: PseudoInverse CONTAINS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the inverse of a matrix. !> An implementation of the method of Hotelling \\cite palser1998canonical. SUBROUTINE Invert ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to invert. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The inverse of that matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables REAL ( NTREAL ) :: sigma TYPE ( Matrix_ps ) :: Temp1 , Temp2 , Identity TYPE ( Matrix_ps ) :: BalancedMat !! Temporary Variables INTEGER :: II REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Inverse Solver\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"palser1998canonical\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL ConstructEmptyMatrix ( Temp1 , InputMat ) CALL ConstructEmptyMatrix ( Temp2 , InputMat ) CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL ConstructEmptyMatrix ( BalancedMat , InputMat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( InputMat , BalancedMat , & & params % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( InputMat , BalancedMat ) END IF !! Compute Sigma CALL MatrixSigma ( BalancedMat , sigma ) !! Create Inverse Guess CALL CopyMatrix ( BalancedMat , OutputMat ) CALL ScaleMatrix ( OutputMat , sigma ) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations IF ( params % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF CALL MatrixMultiply ( OutputMat , BalancedMat , Temp1 , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Check if Converged CALL CopyMatrix ( Identity , Temp2 ) CALL IncrementMatrix ( Temp1 , Temp2 , - 1.0_NTREAL ) norm_value = MatrixNorm ( Temp2 ) CALL DestructMatrix ( Temp2 ) CALL MatrixMultiply ( Temp1 , OutputMat , Temp2 , alpha_in = - 1.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Save a copy of the last inverse matrix CALL CopyMatrix ( OutputMat , Temp1 ) CALL ScaleMatrix ( OutputMat , 2.0_NTREAL ) CALL IncrementMatrix ( Temp2 , OutputMat , & & threshold_in = params % threshold ) IF ( norm_value . LE . params % converge_diff ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( BalancedMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE Invert !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the inverse of a matrix using the eigendecomposition. SUBROUTINE DenseInvert ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute the pseudo inverse of. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The pseudoinverse of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Inverse Solver\" ) CALL EnterSubLog END IF !! Apply CALL DenseMatrixFunction ( InputMat , OutputMat , InvertLambda , params ) IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructSolverParameters ( params ) END SUBROUTINE DenseInvert !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Compute the pseudoinverse of a matrix. !> An implementation of the method of Hotelling \\cite palser1998canonical. SUBROUTINE PseudoInverse ( InputMat , OutputMat , solver_parameters_in ) !> The matrix to compute the pseudo inverse of. TYPE ( Matrix_ps ), INTENT ( IN ) :: InputMat !> The pseudoinverse of the input matrix. TYPE ( Matrix_ps ), INTENT ( INOUT ) :: OutputMat !> Parameters for the solver TYPE ( SolverParameters_t ), INTENT ( IN ), OPTIONAL :: solver_parameters_in !! Handling Optional Parameters TYPE ( SolverParameters_t ) :: params !! Local Variables REAL ( NTREAL ) :: sigma TYPE ( Matrix_ps ) :: Temp1 , Temp2 , Identity TYPE ( Matrix_ps ) :: BalancedMat !! Temporary Variables INTEGER :: II REAL ( NTREAL ) :: norm_value TYPE ( MatrixMemoryPool_p ) :: pool !! Optional Parameters IF ( PRESENT ( solver_parameters_in )) THEN CALL CopySolverParameters ( solver_parameters_in , params ) ELSE CALL ConstructSolverParameters ( params ) END IF IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Inverse Solver\" ) CALL EnterSubLog CALL WriteHeader ( \"Citations\" ) CALL EnterSubLog CALL WriteListElement ( \"palser1998canonical\" ) CALL ExitSubLog CALL PrintParameters ( params ) END IF !! Construct All The Necessary Matrices CALL ConstructEmptyMatrix ( OutputMat , InputMat ) CALL ConstructEmptyMatrix ( Temp1 , InputMat ) CALL ConstructEmptyMatrix ( Temp2 , InputMat ) CALL ConstructEmptyMatrix ( Identity , InputMat ) CALL ConstructEmptyMatrix ( BalancedMat , InputMat ) CALL FillMatrixIdentity ( Identity ) !! Load Balancing Step IF ( params % do_load_balancing ) THEN CALL PermuteMatrix ( Identity , Identity , & & params % BalancePermutation , memorypool_in = pool ) CALL PermuteMatrix ( InputMat , BalancedMat , & & params % BalancePermutation , memorypool_in = pool ) ELSE CALL CopyMatrix ( InputMat , BalancedMat ) END IF !! Compute Sigma CALL MatrixSigma ( BalancedMat , sigma ) !! Create Inverse Guess CALL CopyMatrix ( BalancedMat , OutputMat ) CALL ScaleMatrix ( OutputMat , sigma ) !! Iterate IF ( params % be_verbose ) THEN CALL WriteHeader ( \"Iterations\" ) CALL EnterSubLog END IF II = 1 norm_value = params % converge_diff + 1.0_NTREAL DO II = 1 , params % max_iterations IF ( params % be_verbose . AND . II . GT . 1 ) THEN CALL WriteListElement ( key = \"Convergence\" , VALUE = norm_value ) END IF CALL MatrixMultiply ( OutputMat , BalancedMat , Temp1 , & & threshold_in = params % threshold , memory_pool_in = pool ) CALL MatrixMultiply ( Temp1 , OutputMat , Temp2 , alpha_in = - 1.0_NTREAL , & & threshold_in = params % threshold , memory_pool_in = pool ) !! Save a copy of the last inverse matrix CALL CopyMatrix ( OutputMat , Temp1 ) CALL ScaleMatrix ( OutputMat , 2.0_NTREAL ) CALL IncrementMatrix ( Temp2 , OutputMat , & & threshold_in = params % threshold ) !! Check if Converged CALL IncrementMatrix ( OutputMat , Temp1 , - 1.0_NTREAL ) norm_value = MatrixNorm ( Temp1 ) !! Sometimes the first few values don't change so much, so that's why !! I added the outer counter check IF ( norm_value . LE . params % converge_diff . AND . II . GT . 3 ) THEN EXIT END IF END DO IF ( params % be_verbose ) THEN CALL ExitSubLog CALL WriteElement ( key = \"Total Iterations\" , VALUE = II - 1 ) CALL PrintMatrixInformation ( OutputMat ) END IF !! Undo Load Balancing Step IF ( params % do_load_balancing ) THEN CALL UndoPermuteMatrix ( OutputMat , OutputMat , & & params % BalancePermutation , memorypool_in = pool ) END IF IF ( params % be_verbose ) THEN CALL ExitSubLog END IF !! Cleanup CALL DestructMatrix ( Temp1 ) CALL DestructMatrix ( Temp2 ) CALL DestructMatrix ( BalancedMat ) CALL DestructMatrixMemoryPool ( pool ) CALL DestructSolverParameters ( params ) END SUBROUTINE PseudoInverse !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !> Prototypical inversion for mapping. FUNCTION InvertLambda ( val ) RESULT ( outval ) REAL ( KIND = NTREAL ), INTENT ( IN ) :: val REAL ( KIND = NTREAL ) :: outval outval = 1.0 / val END FUNCTION InvertLambda !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! END MODULE InverseSolversModule","tags":"","loc":"sourcefile/inversesolversmodule.f90.html"},{"title":"EigenExa_s.F90 – NTPoly","text":"Contents Source Code EigenExa_s.F90 Source Code !! Allocate Eigen Exa CALL InitializeEigenExa ( A , nvals , PRESENT ( eigenvectors_in ), exa ) !! Allocate Memory ALLOCATE ( AD ( exa % local_rows , exa % local_cols )) AD = 0 ALLOCATE ( VD ( exa % local_rows , exa % local_cols )) VD = 0 ALLOCATE ( WD ( exa % mat_dim )) WD = 0 !! Convert to EigenExa #ifdef ISCOMPLEX CALL NTToEigen_c ( A , AD , exa ) #else CALL NTToEigen_r ( A , AD , exa ) #endif !! Calculate #ifdef ISCOMPLEX CALL Compute_c ( AD , VD , WD , exa ) #else CALL Compute_r ( AD , VD , WD , exa ) #endif !! Convert Back IF ( PRESENT ( eigenvectors_in )) THEN CALL ConstructEmptyMatrix ( eigenvectors_in , A ) #ifdef ISCOMPLEX CALL EigenToNT_c ( VD , eigenvectors_in , params , exa ) #else CALL EigenToNT_r ( VD , eigenvectors_in , params , exa ) #endif END IF CALL ConstructEmptyMatrix ( eigenvalues , A ) CALL ExtractEigenvalues ( WD , eigenvalues , exa ) !! Cleanup #ifdef ISCOMPLEX CALL CleanUp_c ( AD , VD , WD ) #else CALL CleanUp_r ( AD , VD , WD ) #endif IF ( params % be_verbose ) THEN IF ( PRESENT ( eigenvectors_in )) THEN CALL PrintMatrixInformation ( eigenvectors_in ) END IF CALL ExitSubLog END IF","tags":"","loc":"sourcefile/eigenexa_s.f90.html"}]}