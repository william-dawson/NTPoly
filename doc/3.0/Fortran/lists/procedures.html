<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Documentation for NTPoly">
    <meta name="author" content="" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; NTPoly
</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
      <link href="../css/user.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
        <![endif]-->

         <script src="../js/jquery-2.1.3.min.js"></script>
         <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">NTPoly </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
                 data-toggle="dropdown" role="button"
                 aria-haspopup="true"
                 aria-expanded="false">
                 Contents <span class="caret"></span>
              </a>
              <ul class="dropdown-menu">
                    <li><a href="../lists/files.html">Source Files</a></li>
                  <li><a href="../lists/modules.html">Modules</a></li>
                  <li><a href="../lists/procedures.html">Procedures</a></li>
                  <li><a href="../lists/types.html">Derived Types</a></li>
              </ul>
            </li>
                <li class="visible-xs hidden-sm visible-lg">
                  <a href="../lists/files.html">Source Files</a>
                </li>
              <li class="visible-xs hidden-sm visible-lg">
                <a href="../lists/modules.html">Modules</a>
              </li>
              <li class="visible-xs hidden-sm visible-lg">
                <a href="../lists/procedures.html">Procedures</a>
              </li>
              <li class="visible-xs hidden-sm visible-lg">
                <a href="../lists/types.html">Derived Types</a>
              </li>
          </ul>
            <form action="../search.html" class="navbar-form navbar-right" role="search">
              <div class="form-group">
                <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
              </div>
              <!--
                  <button type="submit" class="btn btn-default">Submit</button>
                  -->
            </form>
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr><td><a href='../proc/activatelogger.html'>ActivateLogger</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Activate the logger.</p></td></tr>
			   <tr><td><a href='../interface/addsparsevectors.html'>AddSparseVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/appendtotripletlist.html'>AppendToTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/appendtovector.html'>AppendToVector</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/broadcastvector.html'>BroadcastVector</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/cgsolver.html'>CGSolver</a></td><td><a href='../module/linearsolversmodule.html'>LinearSolversModule</a></td><td>Subroutine</td><td><p>Solve the matrix equation AX = B using the conjugate gradient method.</p></td></tr>
			   <tr><td><a href='../proc/checkallocerror.html'>CheckAllocError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Routine to call if an alloc error has occurred.</p></td></tr>
			   <tr><td><a href='../interface/checkmemorypoolvalidity.html'>CheckMemoryPoolValidity</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/checkmemorypoolvalidity~2.html'>CheckMemoryPoolValidity</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/checkmpierror.html'>CheckMPIError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Routine to call to check if an MPI error has occurred.</p></td></tr>
			   <tr><td><a href='../proc/choleskydecomposition.html'>CholeskyDecomposition</a></td><td><a href='../module/linearsolversmodule.html'>LinearSolversModule</a></td><td>Subroutine</td><td><p>Compute The Cholesky Decomposition of a Hermitian Positive Definite matrix.
This is a really naive implementation, that might be worth revisiting.</p></td></tr>
			   <tr><td><a href='../proc/cleanup.html'>Cleanup</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>As a last case resort, this will print an error message and quit.</p></td></tr>
			   <tr><td><a href='../interface/commsplitmatrix.html'>CommSplitMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/comparetriplets.html'>CompareTriplets</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/composematrix.html'>ComposeMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/composematrix~2.html'>ComposeMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/composematrixcolumns.html'>ComposeMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/compute.html'>Compute</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/compute~2.html'>Compute</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/compute~3.html'>Compute</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/computedenseexponential.html'>ComputeDenseExponential</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computedensefoe.html'>ComputeDenseFOE</a></td><td><a href='../module/fermioperatormodule.html'>FermiOperatorModule</a></td><td>Subroutine</td><td><p>Compute the density matrix using a dense routine.</p></td></tr>
			   <tr><td><a href='../proc/computedenselogarithm.html'>ComputeDenseLogarithm</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computeexponential.html'>ComputeExponential</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/computeexponentialpade.html'>ComputeExponentialPade</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix using a pade approximation.
Be warned, the pade method can result in a lot of intermediate fill.</p></td></tr>
			   <tr><td><a href='../proc/computeexponentialtaylor.html'>ComputeExponentialTaylor</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the exponential of a matrix using a taylor series expansion.
This is only really useful if you have a very small spectrum, because
quite a bit of scaling is required.</p></td></tr>
			   <tr><td><a href='../proc/computegridsize.html'>ComputeGridSize</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Sometimes we only want to specify for a process grid the number of slices
and then automatically compute the right number of rows and columns.</p></td></tr>
			   <tr><td><a href='../proc/computeinverseroot.html'>ComputeInverseRoot</a></td><td><a href='../module/rootsolversmodule.html'>RootSolversModule</a></td><td>Subroutine</td><td><p>Compute a general inverse matrix root.</p></td></tr>
			   <tr><td><a href='../proc/computelogarithm.html'>ComputeLogarithm</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the logarithm of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/computelogarithmtaylor.html'>ComputeLogarithmTaylor</a></td><td><a href='../module/exponentialsolversmodule.html'>ExponentialSolversModule</a></td><td>Subroutine</td><td><p>Compute the logarithm of a matrix using a taylor series expansion.</p></td></tr>
			   <tr><td><a href='../proc/computeroot.html'>ComputeRoot</a></td><td><a href='../module/rootsolversmodule.html'>RootSolversModule</a></td><td>Subroutine</td><td><p>Compute a general matrix root.</p></td></tr>
			   <tr><td><a href='../interface/conjugatematrix.html'>ConjugateMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/conjugatematrix~2.html'>ConjugateMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/constructdefaultpermutation.html'>ConstructDefaultPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that preserves the original order.</p></td></tr>
			   <tr><td><a href='../interface/constructdiag.html'>ConstructDiag</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructemptymatrix.html'>ConstructEmptyMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructemptymatrix~2.html'>ConstructEmptyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructemptymatrix~3.html'>ConstructEmptyMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/constructerror.html'>ConstructError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Default constructor for an error type.</p></td></tr>
			   <tr><td><a href='../proc/constructlimitedrandompermutation.html'>ConstructLimitedRandomPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that has a random order, but there is no
permutation from beyond the actual matrix dimension.</p></td></tr>
			   <tr><td><a href='../interface/constructmatrixdfroms.html'>ConstructMatrixDFromS</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixfrombinary.html'>ConstructMatrixFromBinary</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixfromfile.html'>ConstructMatrixFromFile</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixfrommatrixmarket.html'>ConstructMatrixFromMatrixMarket</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixfromtripletlist.html'>ConstructMatrixFromTripletList</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixmemorypool.html'>ConstructMatrixMemoryPool</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixmemorypool~2.html'>ConstructMatrixMemoryPool</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructmatrixsfromd.html'>ConstructMatrixSFromD</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructnewprocessgrid.html'>ConstructNewProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructpolynomial.html'>ConstructPolynomial</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructpolynomial~2.html'>ConstructPolynomial</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructpolynomial~3.html'>ConstructPolynomial</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/constructprocessgrid.html'>ConstructProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/constructrandompermutation.html'>ConstructRandomPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that has a random order.
Implements Knuth shuffle.</p></td></tr>
			   <tr><td><a href='../proc/constructranklookup.html'>ConstructRankLookup</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Subroutine</td><td><p>Construct a lookup for columns</p></td></tr>
			   <tr><td><a href='../proc/constructreversepermutation.html'>ConstructReversePermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Constructs a permutation that reverses the original order.</p></td></tr>
			   <tr><td><a href='../proc/constructsolverparameters.html'>ConstructSolverParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Construct a data type which stores iterative solver parameters.</p></td></tr>
			   <tr><td><a href='../interface/constructtripletlist.html'>ConstructTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/convertmatrixtocomplex.html'>ConvertMatrixToComplex</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Converts the current matrix to a complex type matrix.</p></td></tr>
			   <tr><td><a href='../proc/convertmatrixtoreal.html'>ConvertMatrixToReal</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Converts the current matrix to a real type matrix.</p></td></tr>
			   <tr><td><a href='../interface/convertmatrixtype.html'>ConvertMatrixType</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/converttripletlisttype.html'>ConvertTripletListType</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/converttriplettype.html'>ConvertTripletType</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/copymatrix.html'>CopyMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/copymatrix~2.html'>CopyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/copymatrix~3.html'>CopyMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/copypermutation.html'>CopyPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Copy one permutation to another in a safe way.</p></td></tr>
			   <tr><td><a href='../proc/copyprocessgrid.html'>CopyProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Copy a process grid.
Note that this makes a complete and independent copy of the process grid.
Which of course means that whatever is currently stored in new_grid will
be destroyed, so do not leave any matrices pointing to it.</p></td></tr>
			   <tr><td><a href='../proc/copysolverparameters.html'>CopySolverParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../interface/copytripletlist.html'>CopyTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/cosine.html'>Cosine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the cosine of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/deactivatelogger.html'>DeactivateLogger</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Deactivate the logger.</p></td></tr>
			   <tr><td><a href='../proc/densecosine.html'>DenseCosine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the cosine of a matrix. (dense version).</p></td></tr>
			   <tr><td><a href='../proc/densedensity.html'>DenseDensity</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix using a dense routine.</p></td></tr>
			   <tr><td><a href='../proc/denseinversesquareroot.html'>DenseInverseSquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Computes the matrix inverse square root function (dense version).</p></td></tr>
			   <tr><td><a href='../proc/denseinvert.html'>DenseInvert</a></td><td><a href='../module/inversesolversmodule.html'>InverseSolversModule</a></td><td>Subroutine</td><td><p>Compute the inverse of a matrix using the eigendecomposition.</p></td></tr>
			   <tr><td><a href='../proc/densematrixfunction.html'>DenseMatrixFunction</a></td><td><a href='../module/eigensolversmodule.html'>EigenSolversModule</a></td><td>Subroutine</td><td><p>Apply an arbitrary matrix function defined by a matrix map as a</p></td></tr>
			   <tr><td><a href='../proc/densesignfunction.html'>DenseSignFunction</a></td><td><a href='../module/signsolversmodule.html'>SignSolversModule</a></td><td>Subroutine</td><td><p>Computes the matrix sign function (dense version).</p></td></tr>
			   <tr><td><a href='../proc/densesine.html'>DenseSine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the sine of a matrix. (dense version).</p></td></tr>
			   <tr><td><a href='../proc/densesquareroot.html'>DenseSquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Computes the matrix square root function (dense version).</p></td></tr>
			   <tr><td><a href='../interface/destructmatrix.html'>DestructMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructmatrix~2.html'>DestructMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructmatrix~3.html'>DestructMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructmatrixmemorypool.html'>DestructMatrixMemoryPool</a></td><td><a href='../module/pmatrixmemorypoolmodule.html'>PMatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructmatrixmemorypool~2.html'>DestructMatrixMemoryPool</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/destructpermutation.html'>DestructPermutation</a></td><td><a href='../module/permutationmodule.html'>PermutationModule</a></td><td>Subroutine</td><td><p>Destruct a permutation object.</p></td></tr>
			   <tr><td><a href='../interface/destructpolynomial.html'>DestructPolynomial</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructpolynomial~2.html'>DestructPolynomial</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/destructpolynomial~3.html'>DestructPolynomial</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/destructprocessgrid.html'>DestructProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Destruct a process grid.
Be careful about doing this. Matrices have pointers to process grids. If
you destruct a process grid without destructing the matrices pointing to
it, they will become unusable.</p></td></tr>
			   <tr><td><a href='../proc/destructsolverparameters.html'>DestructSolverParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Cleanup the solver parameters datastructure.</p></td></tr>
			   <tr><td><a href='../interface/destructtripletlist.html'>DestructTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/dotallhelper.html'>DotAllHelper</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/dotallpivoted.html'>DotAllPivoted</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/dotmatrix.html'>DotMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/dotmatrix~2.html'>DotMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/dotsparsevectors.html'>DotSparseVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/eigendecomposition.html'>EigenDecomposition</a></td><td><a href='../module/eigensolversmodule.html'>EigenSolversModule</a></td><td>Subroutine</td><td><p>Compute the eigendecomposition of a matrix.</p></td></tr>
			   <tr><td><a href='../interface/eigendecomposition.html'>EigenDecomposition</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/energydensitymatrix.html'>EnergyDensityMatrix</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the energy-weighted density matrix.</p></td></tr>
			   <tr><td><a href='../proc/entersublog.html'>EnterSubLog</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Call this subroutine when you enter into a section with verbose output</p></td></tr>
			   <tr><td><a href='../proc/erroroccurred.html'>ErrorOccurred</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Function</td><td><p>Check if an error has occurred or not.</p></td></tr>
			   <tr><td><a href='../proc/exitsublog.html'>ExitSubLog</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Call this subroutine when you exit a section with verbose output</p></td></tr>
			   <tr><td><a href='../interface/extractmatrixcolumn.html'>ExtractMatrixColumn</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/extractmatrixrow.html'>ExtractMatrixRow</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/factorizedcompute.html'>FactorizedCompute</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/factorizedcompute~2.html'>FactorizedCompute</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fillmatrixdense.html'>FillMatrixDense</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fillmatrixfromtripletlist.html'>FillMatrixFromTripletList</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fillmatrixidentity.html'>FillMatrixIdentity</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fillmatrixpermutation.html'>FillMatrixPermutation</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/filtermatrix.html'>FilterMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/gathermatrixcolumn.html'>GatherMatrixColumn</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/gathermatrixtoprocess.html'>GatherMatrixToProcess</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/gershgorinbounds.html'>GershgorinBounds</a></td><td><a href='../module/eigenboundsmodule.html'>EigenBoundsModule</a></td><td>Subroutine</td><td><p>Compute a bounds on the minimum and maximum eigenvalue of a matrix.
Uses the Gershgorin theorem.</p></td></tr>
			   <tr><td><a href='../proc/getloggerlevel.html'>GetLoggerLevel</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Function</td><td><p>Get the current logging level</p></td></tr>
			   <tr><td><a href='../interface/getmatrixactualdimension.html'>GetMatrixActualDimension</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixblock.html'>GetMatrixBlock</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixcolumns.html'>GetMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixloadbalance.html'>GetMatrixLoadBalance</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixlogicaldimension.html'>GetMatrixLogicalDimension</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixrows.html'>GetMatrixRows</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/getmatrixsize.html'>GetMatrixSize</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/getmatrixslice.html'>GetMatrixSlice</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Copy an arbitrary slice from a matrix into a new smaller matrix.
NTPoly only works with square matrices, so if the number of rows and
columns is different the matrix is resized to the maximum size.</p></td></tr>
			   <tr><td><a href='../interface/getmatrixtripletlist.html'>GetMatrixTripletList</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/getmpitriplettype_c.html'>GetMPITripletType_c</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Function</td><td><p>Returns an MPI derived data type for a triplet (complex).
We statically store this derived type so that we do not have to recreate
it every time this function is called. Thus this functional call should
add very little overhead.</p></td></tr>
			   <tr><td><a href='../proc/getmpitriplettype_r.html'>GetMPITripletType_r</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Function</td><td><p>Returns an MPI derived data type for a triplet (Real).
We statically store this derived type so that we do not have to recreate
it every time this function is called. Thus this functional call should
add very little overhead.</p></td></tr>
			   <tr><td><a href='../proc/getmycolumn.html'>GetMyColumn</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the column of the current process.</p></td></tr>
			   <tr><td><a href='../proc/getmyrow.html'>GetMyRow</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the row of the current process.</p></td></tr>
			   <tr><td><a href='../proc/getmyslice.html'>GetMySlice</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Get the slice of the current process.</p></td></tr>
			   <tr><td><a href='../interface/getpivot.html'>GetPivot</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/gettripletat.html'>GetTripletAt</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/gettripletlistsize.html'>GetTripletListSize</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/gettripletvalues.html'>GetTripletValues</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/hpcp.html'>HPCP</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the HPCP method.
Based on the algorithm presented in \cite truflandier2016communication.</p></td></tr>
			   <tr><td><a href='../interface/incrementmatrix.html'>IncrementMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/incrementmatrix~2.html'>IncrementMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/incrementmatrix~3.html'>IncrementMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/inversesquareroot.html'>InverseSquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Compute the inverse square root of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/invert.html'>Invert</a></td><td><a href='../module/inversesolversmodule.html'>InverseSolversModule</a></td><td>Subroutine</td><td><p>Compute the inverse of a matrix.
An implementation of the method of Hotelling \cite palser1998canonical.</p></td></tr>
			   <tr><td><a href='../proc/isidentity.html'>IsIdentity</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Function</td><td><p>Determine if this is the identity matrix.</p></td></tr>
			   <tr><td><a href='../proc/isloggeractive.html'>IsLoggerActive</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Function</td><td><p>Check if the logger is currently active</p></td></tr>
			   <tr><td><a href='../proc/isroot.html'>IsRoot</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Function</td><td><p>Check if the current process is the root process.</p></td></tr>
			   <tr><td><a href='../proc/lowdinextrapolate.html'>LowdinExtrapolate</a></td><td><a href='../module/geometryoptimizationmodule.html'>GeometryOptimizationModule</a></td><td>Subroutine</td><td><p>Create a new guess at the Density Matrix after updating the geometry.
Based on the lowdin algorithm in \cite exner2002comparison .</p></td></tr>
			   <tr><td><a href='../proc/mapmatrix_psc.html'>MapMatrix_psc</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Subroutine</td><td><p>Given a distributed matrix, apply this procedure to each element (complex).</p></td></tr>
			   <tr><td><a href='../proc/mapmatrix_psr.html'>MapMatrix_psr</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Subroutine</td><td><p>Given a distributed matrix, apply this procedure to each element (real).</p></td></tr>
			   <tr><td><a href='../interface/maptripletlist.html'>MapTripletList</a></td><td><a href='../module/matrixmapsmodule.html'>MatrixMapsModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixcolumnnorm.html'>MatrixColumnNorm</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixgrandsum.html'>MatrixGrandSum</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixgrandsum~2.html'>MatrixGrandSum</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixmultiply.html'>MatrixMultiply</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixmultiply~2.html'>MatrixMultiply</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixnorm.html'>MatrixNorm</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixnorm~2.html'>MatrixNorm</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixnorm~3.html'>MatrixNorm</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixsigma.html'>MatrixSigma</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixtotripletlist.html'>MatrixToTripletList</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/matrixtrace.html'>MatrixTrace</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/mcweenystep.html'>McWeenyStep</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Take one McWeeny Step DOut = 3<em>DSD - 2</em>DSDSD</p></td></tr>
			   <tr><td><a href='../interface/mergematrixlocalblocks.html'>MergeMatrixLocalBlocks</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/multiplymatrix.html'>MultiplyMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pairwisemultiplymatrix.html'>PairwiseMultiplyMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pairwisemultiplymatrix~2.html'>PairwiseMultiplyMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pairwisemultiplyvectors.html'>PairwiseMultiplyVectors</a></td><td><a href='../module/svectormodule.html'>SVectorModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/parsemmheader.html'>ParseMMHeader</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Function</td><td><p>Parse a matrix market header.</p></td></tr>
			   <tr><td><a href='../proc/permutematrix.html'>PermuteMatrix</a></td><td><a href='../module/loadbalancermodule.html'>LoadBalancerModule</a></td><td>Subroutine</td><td><p>Apply a permutation to a matrix.</p></td></tr>
			   <tr><td><a href='../proc/pivotedcholeskydecomposition.html'>PivotedCholeskyDecomposition</a></td><td><a href='../module/analysismodule.html'>AnalysisModule</a></td><td>Subroutine</td><td><p>Compute The Pivoted Cholesky Decomposition of a Hermitian Semi-Definite
matrix. This is one way to generate localized orbitals.</p></td></tr>
			   <tr><td><a href='../proc/pm.html'>PM</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the PM method.
Based on the PM algorithm presented in \cite palser1998canonical</p></td></tr>
			   <tr><td><a href='../proc/polardecomposition.html'>PolarDecomposition</a></td><td><a href='../module/signsolversmodule.html'>SignSolversModule</a></td><td>Subroutine</td><td><p>Computes the polar decomposition of a matrix Mat = U*H.</p></td></tr>
			   <tr><td><a href='../proc/powerbounds.html'>PowerBounds</a></td><td><a href='../module/eigenboundsmodule.html'>EigenBoundsModule</a></td><td>Subroutine</td><td><p>Compute a bounds on the maximum eigenvalue of a matrix.
Uses The Power Method.</p></td></tr>
			   <tr><td><a href='../proc/printalltimers.html'>PrintAllTimers</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for each timer on this process.</p></td></tr>
			   <tr><td><a href='../proc/printalltimersdistributed.html'>PrintAllTimersDistributed</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for each timer based on the max value across
processes.</p></td></tr>
			   <tr><td><a href='../proc/printerror.html'>PrintError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Print out that an error has occurred.</p></td></tr>
			   <tr><td><a href='../interface/printmatrix.html'>PrintMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/printmatrix~2.html'>PrintMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/printmatrixinformation.html'>PrintMatrixInformation</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/printparameters.html'>PrintParameters</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Print out the iterative solver parameter values.</p></td></tr>
			   <tr><td><a href='../proc/printtimer.html'>PrintTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Print out the elapsed time for a given timer.</p></td></tr>
			   <tr><td><a href='../proc/pseudoinverse.html'>PseudoInverse</a></td><td><a href='../module/inversesolversmodule.html'>InverseSolversModule</a></td><td>Subroutine</td><td><p>Compute the pseudoinverse of a matrix.
An implementation of the method of Hotelling \cite palser1998canonical.</p></td></tr>
			   <tr><td><a href='../proc/purificationextrapolate.html'>PurificationExtrapolate</a></td><td><a href='../module/geometryoptimizationmodule.html'>GeometryOptimizationModule</a></td><td>Subroutine</td><td><p>Create a new guess at the Density Matrix after updating the geometry.
Based on the purification algorithm in \cite niklasson2010trace .</p></td></tr>
			   <tr><td><a href='../interface/redistributetripletlists.html'>RedistributeTripletLists</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandcomposematrix.html'>ReduceAndComposeMatrix</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandcomposematrixcleanup.html'>ReduceAndComposeMatrixCleanup</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandcomposematrixdata.html'>ReduceAndComposeMatrixData</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandcomposematrixsizes.html'>ReduceAndComposeMatrixSizes</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandsummatrix.html'>ReduceAndSumMatrix</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandsummatrixcleanup.html'>ReduceAndSumMatrixCleanup</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandsummatrixdata.html'>ReduceAndSumMatrixData</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/reduceandsummatrixsizes.html'>ReduceAndSumMatrixSizes</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/reducedimension.html'>ReduceDimension</a></td><td><a href='../module/analysismodule.html'>AnalysisModule</a></td><td>Subroutine</td><td><p>When we want to only compute the first n eigenvalues of a matrix, this
routine will project out the higher eigenvalues.</p></td></tr>
			   <tr><td><a href='../proc/registertimer.html'>RegisterTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Register a timer with the timer module.  Call this before using that timer.</p></td></tr>
			   <tr><td><a href='../proc/resizematrix.html'>ResizeMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>Change the size of a matrix.
If the new size is smaller, then values outside that range are deleted.
IF the new size is bigger, zero padding is applied.
Warning: this requires a full data redistribution.</p></td></tr>
			   <tr><td><a href='../interface/resizetripletlist.html'>ResizeTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/scaleandfold.html'>ScaleAndFold</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the Scale and Fold
method. Based on the method of \cite rubensson2011nonmonotonic .
Note that for this method, you must provide the value of the homo and
lumo gap. It is not necessary for these to be accurate, but give a
conservative value.</p></td></tr>
			   <tr><td><a href='../interface/scalematrix.html'>ScaleMatrix</a></td><td><a href='../module/smatrixalgebramodule.html'>SMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/scalematrix~2.html'>ScaleMatrix</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/scalesquaretrigonometrytaylor.html'>ScaleSquareTrigonometryTaylor</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute trigonometric functions of a matrix using a taylor series.</p></td></tr>
			   <tr><td><a href='../interface/setcoefficient.html'>SetCoefficient</a></td><td><a href='../module/chebyshevsolversmodule.html'>ChebyshevSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/setcoefficient~2.html'>SetCoefficient</a></td><td><a href='../module/hermitesolversmodule.html'>HermiteSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/setcoefficient~3.html'>SetCoefficient</a></td><td><a href='../module/polynomialsolversmodule.html'>PolynomialSolversModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/setcustomerror.html'>SetCustomError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/setgenericerror.html'>SetGenericError</a></td><td><a href='../module/errormodule.html'>ErrorModule</a></td><td>Subroutine</td><td><p>Routine to call if a generic error has occurred.</p></td></tr>
			   <tr><td><a href='../proc/setinitialoffset.html'>SetInitialOffset</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Set a manual initial offset spacing.</p></td></tr>
			   <tr><td><a href='../proc/setloggerlevel.html'>SetLoggerLevel</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Set the logging level manually</p></td></tr>
			   <tr><td><a href='../proc/setmatrixprocessgrid.html'>SetMatrixProcessGrid</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Subroutine</td><td><p>When you want to change the process grid of a matrix, you can call
this routine with the new process grid value. Data will be automatically
redistributed.</p></td></tr>
			   <tr><td><a href='../proc/setparametersbeverbose.html'>SetParametersBeVerbose</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the verbosity.</p></td></tr>
			   <tr><td><a href='../proc/setparametersconvergediff.html'>SetParametersConvergeDiff</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the convergence difference.</p></td></tr>
			   <tr><td><a href='../proc/setparametersloadbalance.html'>SetParametersLoadBalance</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the load balance.</p></td></tr>
			   <tr><td><a href='../proc/setparametersmaxiterations.html'>SetParametersMaxIterations</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the max iterations.</p></td></tr>
			   <tr><td><a href='../proc/setparametersstepthreshold.html'>SetParametersStepThreshold</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the step threshold.</p></td></tr>
			   <tr><td><a href='../proc/setparametersthreshold.html'>SetParametersThreshold</a></td><td><a href='../module/solverparametersmodule.html'>SolverParametersModule</a></td><td>Subroutine</td><td><p>Set the value of the threshold.</p></td></tr>
			   <tr><td><a href='../interface/setpoolsparsity.html'>SetPoolSparsity</a></td><td><a href='../module/matrixmemorypoolmodule.html'>MatrixMemoryPoolModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/settriplet.html'>SetTriplet</a></td><td><a href='../module/tripletmodule.html'>TripletModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/settripletat.html'>SetTripletAt</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/shifttripletlist.html'>ShiftTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/signfunction.html'>SignFunction</a></td><td><a href='../module/signsolversmodule.html'>SignSolversModule</a></td><td>Subroutine</td><td><p>Computes the matrix sign function.</p></td></tr>
			   <tr><td><a href='../proc/similaritytransform.html'>SimilarityTransform</a></td><td><a href='../module/psmatrixalgebramodule.html'>PSMatrixAlgebraModule</a></td><td>Subroutine</td><td><p>Transform a matrix B = P * A * P^-1</p></td></tr>
			   <tr><td><a href='../proc/sine.html'>Sine</a></td><td><a href='../module/trigonometrysolversmodule.html'>TrigonometrySolversModule</a></td><td>Subroutine</td><td><p>Compute the sine of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/singularvaluedecomposition.html'>SingularValueDecomposition</a></td><td><a href='../module/singularvaluesolversmodule.html'>SingularValueSolversModule</a></td><td>Subroutine</td><td><p>Compute the singular values and singular vectors of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/snapmatrixtosparsitypattern.html'>SnapMatrixToSparsityPattern</a></td><td><a href='../module/matrixconversionmodule.html'>MatrixConversionModule</a></td><td>Subroutine</td><td><p>Some codes use a fixed sparsity pattern for a matrix instead of filtering
small values. Using this routine, the matrix is filled to have the same
pattern as the second matrix argument. Zeros of the sparsity pattern are
left in, whereas values outside the sparsity are removed. This can 
faciliate conversion between formats.</p></td></tr>
			   <tr><td><a href='../interface/sorttripletlist.html'>SortTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/splitmatrix.html'>SplitMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/splitmatrix~2.html'>SplitMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/splitmatrixcolumns.html'>SplitMatrixColumns</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/splitmatrixtolocalblocks.html'>SplitMatrixToLocalBlocks</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/splitprocessgrid.html'>SplitProcessGrid</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Given a process grid, this splits it into two grids of even size</p></td></tr>
			   <tr><td><a href='../proc/squareroot.html'>SquareRoot</a></td><td><a href='../module/squarerootsolversmodule.html'>SquareRootSolversModule</a></td><td>Subroutine</td><td><p>Compute the square root of a matrix.</p></td></tr>
			   <tr><td><a href='../proc/starttimer.html'>StartTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Start the clock running for a given timer.</p></td></tr>
			   <tr><td><a href='../proc/stoptimer.html'>StopTimer</a></td><td><a href='../module/timermodule.html'>TimerModule</a></td><td>Subroutine</td><td><p>Stop the clock for a given timer.</p></td></tr>
			   <tr><td><a href='../interface/symmetrizetripletlist.html'>SymmetrizeTripletList</a></td><td><a href='../module/tripletlistmodule.html'>TripletListModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/testreducedatarequest.html'>TestReduceDataRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the data of the matrices is complete.</p></td></tr>
			   <tr><td><a href='../proc/testreduceinnerrequest.html'>TestReduceInnerRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the inner indices of the matrices is complete.</p></td></tr>
			   <tr><td><a href='../proc/testreducesizerequest.html'>TestReduceSizeRequest</a></td><td><a href='../module/matrixreducemodule.html'>MatrixReduceModule</a></td><td>Function</td><td><p>Test if a request for the size of the matrices is complete.</p></td></tr>
			   <tr><td><a href='../interface/transposematrix.html'>TransposeMatrix</a></td><td><a href='../module/smatrixmodule.html'>SMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/transposematrix~2.html'>TransposeMatrix</a></td><td><a href='../module/dmatrixmodule.html'>DMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/transposematrix~3.html'>TransposeMatrix</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/trs2.html'>TRS2</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the TRS2 method.
Based on the TRS2 algorithm presented in \cite niklasson2002.</p></td></tr>
			   <tr><td><a href='../proc/trs4.html'>TRS4</a></td><td><a href='../module/densitymatrixsolversmodule.html'>DensityMatrixSolversModule</a></td><td>Subroutine</td><td><p>Compute the density matrix from a Hamiltonian using the TRS4 method.
Based on the TRS4 algorithm presented in \cite niklasson2002</p></td></tr>
			   <tr><td><a href='../proc/undopermutematrix.html'>UndoPermuteMatrix</a></td><td><a href='../module/loadbalancermodule.html'>LoadBalancerModule</a></td><td>Subroutine</td><td><p>Undo a permutation applied to a matrix.</p></td></tr>
			   <tr><td><a href='../interface/unpackcholesky.html'>UnpackCholesky</a></td><td><a href='../module/choleskymodule.html'>CholeskyModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/wom_c.html'>WOM_C</a></td><td><a href='../module/fermioperatormodule.html'>FermiOperatorModule</a></td><td>Subroutine</td><td><p>Compute the density matrix according to the wave operator minization</p></td></tr>
			   <tr><td><a href='../proc/wom_gc.html'>WOM_GC</a></td><td><a href='../module/fermioperatormodule.html'>FermiOperatorModule</a></td><td>Subroutine</td><td><p>Compute the density matrix according to the wave operator minization</p></td></tr>
			   <tr><td><a href='../interface/writeelement.html'>WriteElement</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/writeheader.html'>WriteHeader</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Subroutine</td><td><p>Write out a header to the log.</p></td></tr>
			   <tr><td><a href='../interface/writelistelement.html'>WriteListElement</a></td><td><a href='../module/loggingmodule.html'>LoggingModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/writematrixtobinary.html'>WriteMatrixToBinary</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/writematrixtomatrixmarket.html'>WriteMatrixToMatrixMarket</a></td><td><a href='../module/psmatrixmodule.html'>PSMatrixModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/writemmline.html'>WriteMMLine</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/writemmline_f.html'>WriteMMLine_f</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			   <tr><td><a href='../proc/writemmline_ff.html'>WriteMMLine_ff</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			   <tr><td><a href='../proc/writemmline_ii.html'>WriteMMLine_ii</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			   <tr><td><a href='../proc/writemmline_iif.html'>WriteMMLine_iif</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			   <tr><td><a href='../proc/writemmline_iiff.html'>WriteMMLine_iiff</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write a single line that would correspond to a matrix market entry.</p></td></tr>
			   <tr><td><a href='../proc/writemmsize.html'>WriteMMSize</a></td><td><a href='../module/matrixmarketmodule.html'>MatrixMarketModule</a></td><td>Subroutine</td><td><p>Write the line describing the size of the matrix</p></td></tr>
			   <tr><td><a href='../proc/writeprocessgridinfo.html'>WriteProcessGridInfo</a></td><td><a href='../module/processgridmodule.html'>ProcessGridModule</a></td><td>Subroutine</td><td><p>Write out some basic information about this process grid to the log.</p></td></tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row">
          <div class="col-xs-6 col-md-6"><p>NTPoly was developed by <br>&copy; 2023 
</p>
          </div>
          <div class="col-xs-6 col-md-6">
            <p class="text-right">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript
         ================================================== -->
         <!-- Placed at the end of the document so the pages load faster -->
    <!--
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
        -->
        <script src="../js/bootstrap.min.js"></script>
        <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
        <script src="../js/ie10-viewport-bug-workaround.js"></script>

        <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>