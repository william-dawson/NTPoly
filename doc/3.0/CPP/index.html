<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NTPoly: Project Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">NTPoly
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Project Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__Users_wddawson_Desktop_NTPoly_ReadMe"></a> <img src="https://github.com/william-dawson/NTPoly/workflows/CI/badge.svg" alt="Build Status" style="pointer-events: none;" class="inline"/></p>
<p><a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> is a massively parallel library for computing the functions of sparse, Hermitian matrices based on polynomial expansions. For sufficiently sparse matrices, most of the matrix functions in <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> can be computed in linear time.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Set Up Guide</h1>
<p><a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> is freely available and open source under the MIT license. It can be downloaded from the <a href="https://github.com/william-dawson/NTPoly">Github</a> repository. We of course recommend that you download a <a href="https://github.com/william-dawson/NTPoly/releases">release version</a> to get started.</p>
<p>Installing <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> requires the following software:</p>
<ul>
<li>A Fortran Compiler.</li>
<li>An MPI Installation (MPI-3 Standard+).</li>
<li>CMake (Version 3.2+).</li>
<li>BLAS: for multiplying dense matrices, if they emerge in the calculation.</li>
<li>LAPACK: for dense solvers.</li>
</ul>
<p>The following optional software can greatly enhance the <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> experience:</p>
<ul>
<li>A C++ Compiler for building C++ bindings.</li>
<li>Ford: for building documentation.</li>
<li>Doxygen: for building C++ documentation.</li>
<li>SWIG (Version 3.0+): for building the Python bindings.</li>
<li>Python (Version 2.7+): if you would like python bindings.</li>
<li>MPI4PY: for testing.</li>
<li>SciPy: for testing.</li>
<li>NumPy: for testing.</li>
<li>EigenExa: for dense, parallel calculations.</li>
</ul>
<p><a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> uses CMake as a build system. First, take a look in the Targets directory. You'll find a list of <code>.cmake</code> files which have example configurations on popular systems. You should copy one of these files, and create your own mymachine.cmake file. Then, cd into the Build directory, and type: </p><blockquote class="doxtable">
<p>&zwj;cmake -DCMAKE_TOOLCHAIN_FILE=../Targets/mymachine.cmake .. </p>
</blockquote>
<p>After that you can build using: </p><blockquote class="doxtable">
<p>&zwj;make </p>
</blockquote>
<p>And for the documentation: </p><blockquote class="doxtable">
<p>&zwj;make doc </p>
</blockquote>
<p>If you aren't cross compiling and have built the python bindings, you can perform local tests using: </p><blockquote class="doxtable">
<p>&zwj;make test </p>
</blockquote>
<p>There are a few options you can pass to CMake to modify the build. A few useful standard options are:</p><ul>
<li><code>-DCMAKE_BUILD_TYPE=</code> <code>Debug</code> or <code>Release</code>.</li>
<li><code>-DCMAKE_INSTALL_PREFIX=</code> followed by the path to your desired install directory.</li>
</ul>
<p>There are also some custom options special for <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a>:</p><ul>
<li><code>-DFORTRAN_ONLY=</code> set to <code>Yes</code> if you only want to build the Fortran bindings.</li>
<li><code>-DNOSWIG=</code> set to <code>Yes</code> if you don't want to build Python bindings.</li>
<li><code>-DUSE_MPIH=</code> on some systems, there is no <code>use mpi</code> feature for Fortran, just <code>#include "mpi.h"</code>. You can set this option to activate the later.</li>
<li><code>-DNOIALLGATHER=</code> on older MPI implementations, there is no non blocking collective operations. You can disable this feature using this option, but beware this might reduce performance.</li>
</ul>
<p><a href="https://william-dawson.github.io/NTPoly/documentation/">Online documentation</a> is also available. Further details about the library can be found on the <a href="https://github.com/william-dawson/NTPoly/wiki">Wiki</a>.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Basic Theory</h1>
<p>The theory of matrix functions is a long studied branch of matrix algebra. Matrix functions have a wide range of applications, including graph problems, differential equations, and materials science. Common examples of matrix functions include the matrix exponential:</p>
<blockquote class="doxtable">
<p>&zwj;f(A) = e^A. </p>
</blockquote>
<p>from the study of networks, or the inverse square root:</p>
<blockquote class="doxtable">
<p>&zwj;f(A) = A^(-1/2) </p>
</blockquote>
<p>from quantum chemistry. <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> is a massively parallel library that can be used to compute a variety of matrix using polynomial expansions. Consider for example the Taylor series expansion of a function <em>f(x)</em> .</p>
<blockquote class="doxtable">
<p>&zwj;f(x) = f(0) + f'(0)x + f''(0)x^2/2! + ... </p>
</blockquote>
<p>We can imagine expanding this from the function of a single variable, to a function of a matrix:</p>
<blockquote class="doxtable">
<p>&zwj;f(A) = f(0) + f'(0)A + f''(0)A^2/2! + ... </p>
</blockquote>
<p>where matrices can be summed using matrix addition, and raised to a power using matrix multiplication. At the heart of <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> are polynomial expansions like this. We implement not only Taylor expansions, but also Chebyshev polynomial expansions, and other specialized expansions based on the function of interest.</p>
<p>When the input matrix <em>A</em> and the output matrix <em>f(A)</em> are sparse, we can replace the dense matrix addition and multiplication routines with sparse matrix routines. This allows us to use <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> to efficiently compute many functions of sparse matrices.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Getting Start With Examples</h1>
<p>In the examples directory, there are a number of different example programs that use <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a>. You can check the ReadMe.md file in each example directory to learn how to build and run each example. The simplest example is PremadeMatrix, which includes sample output you can compare to.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Feature Outline</h1>
<p>The following features and methods have been implemented in <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a>:</p>
<ul>
<li>General Polynomials<ul>
<li>Standard Polynomials</li>
<li>Chebyshev Polynomials</li>
<li>Hermite Polynomials</li>
</ul>
</li>
<li>Transcendental Functions<ul>
<li>Trigonometric Functions</li>
<li>Exponential and Logarithm</li>
</ul>
</li>
<li>Matrix Roots<ul>
<li>Square Root and Inverse Square Root</li>
<li>Matrix <em>p</em> th Root</li>
</ul>
</li>
<li>Quantum Chemistry<ul>
<li>Density Matrix Purification</li>
<li>Chemical Potential Calculation</li>
<li>Geometry Optimization</li>
</ul>
</li>
<li>Other<ul>
<li>Matrix Inverse/Moore-Penrose Pseudo Inverse</li>
<li>Sign Function/Polar Decomposition</li>
<li>Interface to Dense Eigen/Singular Value Decomposition</li>
<li>Load Balancing Matrices</li>
<li>File I/O</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Citation</h1>
<p>A description of the techniques used in <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a> can be found in the following Computer Physics Communications paper:</p>
<blockquote class="doxtable">
<p>&zwj;Dawson, William, and Takahito Nakajima. "Massively parallel sparse matrix
function calculations with NTPoly." Computer Physics Communications (2017). </p>
</blockquote>
<p>Please cite this paper in accordance to the practices in your field.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
How To Contribute</h1>
<p>To begin contributing to <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a>, take a look at the <a href="https://github.com/william-dawson/NTPoly/wiki">Wiki</a> pages. The <a href="https://github.com/william-dawson/NTPoly/blob/master/CONTRIBUTING.md">Contributing Guide</a> provides an overview of best development practices. Additionally, there is a <a href="https://github.com/william-dawson/NTPoly/wiki/Adding-New-Functionality-(Example)">Adding New Functionality</a> page which documents how one would go about adding a matrix function to <a class="el" href="namespace_n_t_poly.html" title="C++ interface to NTPoly.">NTPoly</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
